[1,["4674guSUlLh7foe9+0Wy80@74b97","08Wvpn2ItPoZgBHu/SeFT+@7cf56","08Wvpn2ItPoZgBHu/SeFT+@20215","a5mCTHezdMLphU6QeZYTLW@aea57","f6SJZOjTJB/JrJeh5xTdF7","c6GiNLTeFAtr7AzM4tXI7V@08c4b","539LjOuRRPx4uc7JxRmdLo@9f4ef","12Y9dMgWdJKJGmTiZyQR9H@a804a","988gVVT7FOCI9SkTJaRaE7","22CThsxUNNMJa+NMBI1L+/@80a65","b8Ku7qQuNKXY2rymG/4D6V@f1d1b","12Y9dMgWdJKJGmTiZyQR9H@2e76e","c89m0XNRpI2qEsAhLShXXE","2ewRRY+FVJeLFN8+1c9pf6","479Qz1IvtC47kkrNQAlSyn@f1645","7dj5uJT9FMn6OrOOx83tfK@f9941","30vAjbzhZJEpbYDnXmXNdY","ee3SVh1E1LnKSvTtx1WGgn","faOQTwwKRHZ5aempJi1L5Y@f9941","b1FUYWxdFBmLpi+9r3B1PD","34N9wwBTBI2YZbUsVypPl+@1428f","0aURjCpPVBhri2qcuUN5sL@6c48a","a2PL7DZbVHi7gY6tJh+QPb@97af3","a8tfBGFuxImZpmSqCAoxAE@21008","57iXjMusJCRofJD3zHTcbL@6c48a","daYfa7rt5GFbNnr2JsKDiS","e1NI33MgFOD67gpnKr4yEM@f9941","a2PL7DZbVHi7gY6tJh+QPb@625f0","5cmM8dt+ZHxZ5CIm9C8E7Y@f9941","632ngiNtRKcbOV5fhxNhPs@16077","01K5KwRv5P96jo+Gzf6SNV","4a1KyCtCRCiJGZVPxayD6s@746db","58kTshdWBGXr5sCHnlbyk7","30dLUtCmNGVoUhQPMfo6s8@6c48a","1aHOGd6olAX6qgyquhJvpG@6c48a","08Wvpn2ItPoZgBHu/SeFT+@54131","22CThsxUNNMJa+NMBI1L+/@0f0c6","8aNqc8vHlI/qD2J3ucUy7a@6c48a","d1NGQ2rJZCcbhjH0/erZWw","33m5huIv9CHad7Hfo4V8kI@ba9dd","33m5huIv9CHad7Hfo4V8kI@9566e","34N9wwBTBI2YZbUsVypPl+@73b7f","1brw/JvvpFnIvdrxpFCgMZ","ad6KFa3MpLPITG9kdqyHW7","dfboMJo/dNYZqKGUtVaUmi@f9941","1c1d0cw+ZP+raTJ7De4Ani","09si8Gbo5OQqP89D7e+PgZ@035e3","294p7jB+xO86nlJXahkzXX@5fda8","82nXySPgtJOIkPs/cGQORx@f9941","06nywtm39HApwdK96BokgU@f9941","a3m+qer39DH5/DZMuhW+Mi@f9941","dc6rcRC5lHF6fwGgFZNYRV@f9941","23G6xiO/xFyZmLy3/pWdn0@f9941","a3kJW5HJ9JkYtJyUmljCEn@f9941","d8KK6AvuhFLrWEi/ssaSFX@f9941","c76kQm0YVFzr8jX7GY3u7n@f9941","64eOkjsgxBTKmizG3FKweK@f9941","14cXhCTF5Ph4rfD4Ya+FzK@f9941","20g1ukYUVPvKWKBRznAKo+@f9941","a8GRgVbDVBPYim598ow7MB@6c48a","74tTPLKWpNZ5FqPYi+DPO3@6c48a","30oTdZBxZPkLvep5dAv4Sd","3bUdyEl7pFeqeZmtTiWAdj@6c48a","a9XSr8ONxFQZYuAMtXZS/+@0c9f3","a9XSr8ONxFQZYuAMtXZS/+@fb4da","cc1qKfEdxEa4MwAXq99wlZ@6c48a","08Wvpn2ItPoZgBHu/SeFT+@ff494","09si8Gbo5OQqP89D7e+PgZ@e3923","09si8Gbo5OQqP89D7e+PgZ@03a2f","09si8Gbo5OQqP89D7e+PgZ@a86b2","09si8Gbo5OQqP89D7e+PgZ@58ee9","09si8Gbo5OQqP89D7e+PgZ@5bcce","09si8Gbo5OQqP89D7e+PgZ@e9f8d","15ccpsbqlNDJtL3UaXOsMB@6c48a","12eZIX4JBERa3yeqnadr4o@6c48a","20g1ukYUVPvKWKBRznAKo+@6c48a","22CThsxUNNMJa+NMBI1L+/@8f2cf","22CThsxUNNMJa+NMBI1L+/@57fdc","22CThsxUNNMJa+NMBI1L+/@889f2","22CThsxUNNMJa+NMBI1L+/@93a3a","22CThsxUNNMJa+NMBI1L+/@8ab69","22CThsxUNNMJa+NMBI1L+/@3aa3b","22CThsxUNNMJa+NMBI1L+/@46eb1","22CThsxUNNMJa+NMBI1L+/@57684","22CThsxUNNMJa+NMBI1L+/@ed7ce","22CThsxUNNMJa+NMBI1L+/@a6050","22CThsxUNNMJa+NMBI1L+/@18faa","22CThsxUNNMJa+NMBI1L+/@92970","22CThsxUNNMJa+NMBI1L+/@0fe00","22CThsxUNNMJa+NMBI1L+/@c8a13","22CThsxUNNMJa+NMBI1L+/@527cc","22CThsxUNNMJa+NMBI1L+/@92786","22CThsxUNNMJa+NMBI1L+/@30aad","22CThsxUNNMJa+NMBI1L+/@46676","22CThsxUNNMJa+NMBI1L+/@fe4f6","22CThsxUNNMJa+NMBI1L+/@e33d8","22CThsxUNNMJa+NMBI1L+/@d3300","22CThsxUNNMJa+NMBI1L+/@a2552","22CThsxUNNMJa+NMBI1L+/@f4480","22CThsxUNNMJa+NMBI1L+/@ddeb4","22CThsxUNNMJa+NMBI1L+/@31b9d","22CThsxUNNMJa+NMBI1L+/@5e640","e756pQxrdFda5GvzHAOMPH@f9941","51a8Gd+BBDs6RrP5M/c+LZ@f9941","294p7jB+xO86nlJXahkzXX@044d5","294p7jB+xO86nlJXahkzXX@e743e","f2MUzeWN1ORIDZIHuB36+/@6c48a","33m5huIv9CHad7Hfo4V8kI@a557d","33m5huIv9CHad7Hfo4V8kI@7adbd","33m5huIv9CHad7Hfo4V8kI@16e77","33m5huIv9CHad7Hfo4V8kI@b2870","33m5huIv9CHad7Hfo4V8kI@c3696","33m5huIv9CHad7Hfo4V8kI@8631f","33m5huIv9CHad7Hfo4V8kI@6ed8f","33m5huIv9CHad7Hfo4V8kI@bd0ed","33m5huIv9CHad7Hfo4V8kI@906dc","34N9wwBTBI2YZbUsVypPl+@9d032","34N9wwBTBI2YZbUsVypPl+@61f0a","34N9wwBTBI2YZbUsVypPl+@56cfc","34N9wwBTBI2YZbUsVypPl+@ed50d","34N9wwBTBI2YZbUsVypPl+@0e5d5","34N9wwBTBI2YZbUsVypPl+@e1fc8","34N9wwBTBI2YZbUsVypPl+@3a7c7","34N9wwBTBI2YZbUsVypPl+@719cb","35JwKxA7pM5YdtoQ06ezlo@6c48a","a3bM8ilfpPWo2M1jdW9tcc","0ccz58HL5BeJqdVJUyHTz/@9d093","0ccz58HL5BeJqdVJUyHTz/@0b4a2","30dLUtCmNGVoUhQPMfo6s8@f9941","f7S2XWZKVPDKnQ8BBwvWuz@f9941","ee6CB+OqBH64XRkzwwrO7P@f9941","6eqaaH6q5IOIwZuhKAyJyu@f9941","53yKV3JzVCa4+2RUE75ubB@12028","9bHmVqwctHsZZH5aoaWpic@f1d1b","60vkmPDoBNcoa/U1f/oYWa@c26ac","22CThsxUNNMJa+NMBI1L+/@63bdd","62Cbs3RFpHao2N8ZveAKW0@b4e6b","539LjOuRRPx4uc7JxRmdLo@99380","eflXeqsj5ALI0vSh2Hnp2p@2794d","a1Vi9z25lPe6C5RvDuIqho@246f1","aaVwhXzU5L3Ys/oNmVI1bj@f9941","b7BvemIvtBUblBV6IY6USS@f9941","01+Z0Sd9VCU6oXyuz8f3EE@f9941","1fSMUSjVhC+q1x5zbuIxO9@f9941","53ou3pPQ9DLKD1rwH0MuJ9@f9941","50BGdQN8JIq6keRFg7uFGG@f9941","32dSVaV4xLLpCe4PSJ4MEc@f9941","90Y8G0cHpJ7KBYz5YLC58n@f9941","7ddSxCkHZFu4fcuXaJ8RTR@f9941","39/HuxbgdEUa0QTEjKr56l@f9941","0bVk2hL6dPeYn4yYo4iLRN@f9941","baYQW/nORO2r4VeGVPxg2J@f9941","31HsZPVv9L/4RnJjvDqTIa@f9941","b0HNaPdE9LfLn13ojBZVea@f9941","a3i5VzRrFLTrGHHE6WqNdB@f9941","222znaKtVMmZd4N+z9kHjP","80Lg0aTqVEI7SBqadvTZIM@f9941","9batlAHiZPFbhJuNEys03J@f9941","35JwKxA7pM5YdtoQ06ezlo@f9941","e52aziXD1KA7Wfr7EiOWED@f9941","d7BIpLas9NnqEr2tRxM8tj@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","12eZIX4JBERa3yeqnadr4o@f9941","71/aTxlgxADJAEXUaaWFrw@b47c0","4674guSUlLh7foe9+0Wy80@5fc01","4674guSUlLh7foe9+0Wy80@7c1da","479Qz1IvtC47kkrNQAlSyn@4b44a","479Qz1IvtC47kkrNQAlSyn@45656","4a1KyCtCRCiJGZVPxayD6s@71b28","4a1KyCtCRCiJGZVPxayD6s@7c026","4a1KyCtCRCiJGZVPxayD6s@8d61f","51a8Gd+BBDs6RrP5M/c+LZ@6c48a","53yKV3JzVCa4+2RUE75ubB@9f753","53yKV3JzVCa4+2RUE75ubB@0bd78","53yKV3JzVCa4+2RUE75ubB@6f86c","53yKV3JzVCa4+2RUE75ubB@e7fcf","53yKV3JzVCa4+2RUE75ubB@5d526","53yKV3JzVCa4+2RUE75ubB@7a1b4","54TknWPwVPqJqeCR+Y/Czo@6c48a","a9XSr8ONxFQZYuAMtXZS/+@9d7db","33m5huIv9CHad7Hfo4V8kI@72ba1","deL3HBfqtEUL1KpsCqh/yZ","5cmM8dt+ZHxZ5CIm9C8E7Y@6c48a","60vkmPDoBNcoa/U1f/oYWa@039bc","60vkmPDoBNcoa/U1f/oYWa@9984c","632ngiNtRKcbOV5fhxNhPs@d0c80","632ngiNtRKcbOV5fhxNhPs@09210","632ngiNtRKcbOV5fhxNhPs@1bdde","6eqaaH6q5IOIwZuhKAyJyu@6c48a","7dj5uJT9FMn6OrOOx83tfK@6c48a","80Lg0aTqVEI7SBqadvTZIM@6c48a","82nXySPgtJOIkPs/cGQORx@6c48a","90Y8G0cHpJ7KBYz5YLC58n@6c48a","95EkngnxZFbYuFpsqVTaFr@6c48a","9bHmVqwctHsZZH5aoaWpic@7a1b4","9bHmVqwctHsZZH5aoaWpic@89309","9bHmVqwctHsZZH5aoaWpic@3fb77","9bHmVqwctHsZZH5aoaWpic@5e934","9bHmVqwctHsZZH5aoaWpic@12151","9bHmVqwctHsZZH5aoaWpic@f834e","9bHmVqwctHsZZH5aoaWpic@19d1a","9bHmVqwctHsZZH5aoaWpic@faac9","9batlAHiZPFbhJuNEys03J@6c48a","a34ZOaV1NJzIczzvzv4fT+@6c48a","a1Vi9z25lPe6C5RvDuIqho@00138","a1Vi9z25lPe6C5RvDuIqho@ba536","a2PL7DZbVHi7gY6tJh+QPb@e12a4","a2PL7DZbVHi7gY6tJh+QPb@ec770","a3i5VzRrFLTrGHHE6WqNdB@6c48a","78hREfnuhHEaBACAJlbwog","5fZ0CDT95P7rNvTuNxfvCZ","a5mCTHezdMLphU6QeZYTLW@266ac","a8tfBGFuxImZpmSqCAoxAE@039bc","a8tfBGFuxImZpmSqCAoxAE@e9ead","a9XSr8ONxFQZYuAMtXZS/+@cbc68","a9XSr8ONxFQZYuAMtXZS/+@6aba6","a9XSr8ONxFQZYuAMtXZS/+@03b7b","a9XSr8ONxFQZYuAMtXZS/+@2dc64","a9XSr8ONxFQZYuAMtXZS/+@af108","a9XSr8ONxFQZYuAMtXZS/+@2ec48","a9XSr8ONxFQZYuAMtXZS/+@7403c","a9XSr8ONxFQZYuAMtXZS/+@97af5","a9XSr8ONxFQZYuAMtXZS/+@ddd1c","aaVwhXzU5L3Ys/oNmVI1bj@6c48a","6e8d7+eZdHeps1wYhZ/4Bm","b8Ku7qQuNKXY2rymG/4D6V@625f0","b8Ku7qQuNKXY2rymG/4D6V@1ea26","b8Ku7qQuNKXY2rymG/4D6V@bde88","e9PRAh6IhGK6NaRS2eW0wY","c6GiNLTeFAtr7AzM4tXI7V@09016","d7BIpLas9NnqEr2tRxM8tj@6c48a","6dU/FrEkNNvJ7CkNGiEMfh","dc6rcRC5lHF6fwGgFZNYRV@6c48a","dfboMJo/dNYZqKGUtVaUmi@6c48a","e52aziXD1KA7Wfr7EiOWED@6c48a","e756pQxrdFda5GvzHAOMPH@6c48a","ee6CB+OqBH64XRkzwwrO7P@6c48a","eflXeqsj5ALI0vSh2Hnp2p@924ab","eflXeqsj5ALI0vSh2Hnp2p@6a93e","eflXeqsj5ALI0vSh2Hnp2p@b2e38","eflXeqsj5ALI0vSh2Hnp2p@43a9c","f7S2XWZKVPDKnQ8BBwvWuz@6c48a","faOQTwwKRHZ5aempJi1L5Y@6c48a"],["root","asset","node","value","_effectAsset","_mesh","targetInfo","_spriteFrame","_parent","spriteFrame","data","_textureSource","mainTexture","transparencyMap","target","_particleSystem","_mainTexture","source","_cpuMaterial","carItem","camera","_file","_defaultClip","_target","che","car","faguang","carTs","_cameraComponent","scene","speedLab","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite","_diffuseMapHDR","metallicMap"],[["cc.Node",["_name","_layer","_objFlags","_active","_id","__editorExtras__","_parent","_components","_lpos","_children","_lscale","_prefab","_lrot","_euler"],-3,1,9,5,2,5,4,5,5],"cc.SpriteFrame",["cc.Widget",["_alignFlags","_bottom","_originalWidth","_originalHeight","_top","_right","_left","node","__prefab","_target"],-4,1,4,1],["cc.Sprite",["_sizeMode","_type","_fillRange","_fillType","node","_spriteFrame","__prefab","_color","_fillCenter"],-1,1,6,4,5,5],"cc.ImageAsset",["cc.Label",["_string","_actualFontSize","_lineHeight","_overflow","_isBold","_enableWrapText","_fontSize","node","_color","__prefab"],-4,1,5,4],["cc.UITransform",["node","_contentSize","__prefab","_anchorPoint"],3,1,5,4,5],["cc.Node",["_name","_layer","_objFlags","_components","_children","_parent","_lpos","_prefab","_lscale","_lrot","_euler"],0,12,2,1,5,4,5,5,5],["cc.MeshRenderer",["_name","_enabled","node","_materials","bakeSettings","_mesh","__prefab"],1,1,3,4,6,4],["cc.BoxCollider",["_isTrigger","node","_size","_center","__prefab"],2,1,5,5,4],["cc.RigidBody",["_useGravity","_type","node","__prefab"],1,1,4],["cc.CurveRange",["mode","constant","multiplier","spline"],0,4],["cc.RealKeyframeValue",["interpolationMode","value","rightTangent","leftTangent"],-1],["cc.Material",["_states","_defines","_name","_techIdx","_props"],-1,12],["cc.Node",["_name","_objFlags","_components","_parent","_lpos","_lrot","_euler","_prefab"],1,2,1,5,5,5,4],["cc.TargetOverrideInfo",["propertyPath","targetInfo","source","target","sourceInfo"],2,4,1,1,4],["cc.Button",["node","_target","clickEvents","_normalColor","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite"],3,1,1,9,5,6,6,6,6],["cc.ParticleSystem",["_capacity","startSize3D","simulationSpeed","scaleSpace","_simulationSpace","duration","node","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","_noiseModule","__prefab"],-3,1,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],["cc.Material",["_props","_states","_defines","_name"],-1],["cc.Prefab",["_name"],2],["edf98QH2D1AUoCrtQlbxFrU",["key","node","__prefab"],2,1,4],["cc.UIOpacity",["_opacity","node"],2,1],["cc.Mask",["_type","_inverted","node"],1,1],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedChildren","mountedComponents"],1,9,9,9],["03ef5W+OBVL96o320PQMOvl",["cdTime","delayTime","luId","node","carItem"],0,1,6],["LocalizedSpriteItem",["language","spriteFrame"],2,6],["cc.Camera",["_far","_visibility","_projection","_priority","_orthoHeight","_clearFlags","node","_color"],-3,1,5],["cc.ParticleSystem2D",["duration","emissionRate","life","lifeVar","angleVar","startSize","startSizeVar","endSize","endSizeVar","startSpin","startSpinVar","endSpin","speed","speedVar","tangentialAccel","radialAccel","_totalParticles","playOnLoad","_custom","node","posVar","gravity","_startColorVar","_endColor","_endColorVar","_file"],-16,1,5,5,5,5,5,6],["cc.GradientRange",["_mode","colorMin","colorMax"],2,5,5],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.RotationOvertimeModule",["_enable","_separateAxes","x","y","z"],1,4,4,4],["cc.RealCurve",["_times","preExtrapolation","_values"],1,9],["cc.ParticleSystemRenderer",["_renderMode","_velocityScale","_mainTexture","_cpuMaterial"],1,6,6],"cc.TextureCube",["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Node",["_name","_parent","_children","_components","_lpos"],2,1,9,9,5],["cc.Node",["_name","_parent","_children","_components","_lpos","_lrot","_euler"],2,1,12,9,5,5,5],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["cc.PrefabInfo",["fileId","instance","nestedPrefabInstanceRoots","root","asset","targetOverrides"],0,1,1,9],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","instance","asset"],0,1,4,6],["cc.PrefabInfo",["root","asset","fileId","instance","targetOverrides","nestedPrefabInstanceRoots"],-2,2],["cc.PrefabInfo",["fileId","nestedPrefabInstanceRoots","root","instance","targetOverrides","asset"],1,1,4,9,6],["cc.PrefabInfo",["fileId","instance","root","asset","targetOverrides","nestedPrefabInstanceRoots"],1,1,1,9,2],["cc.CompPrefabInfo",["fileId"],2],["cc.ModelBakeSettings",[],3],["cc.ParticleAsset",["_name","_native"],1],["cc.BlockInputEvents",["node","__prefab"],3,1,4],["cc.TargetInfo",["localID"],2],["cc.Layout",["_resizeMode","_layoutType","_spacingX","node","__prefab"],0,1,4],["c0369d6w1dArLhzUn6m2cSV",["node","__prefab","icon","yingzi"],3,1,4,1,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Animation",["node","__prefab","_clips","_defaultClip"],3,1,4,3,6],["cc.SceneAsset",["_name"],2],["7a96bwb9fVPMJAX5PeyeZMy",["node"],3,1],["1bd472YvrBDLoDTsHGhTuKf",["node","che","camera","faguang","warnArr"],3,1,1,1,2,2],["5acceQDZwpHMa5bxJsUvaQ7",["node","target","car"],3,1,1,1],["530a8u/WxRG+K4JVUJRJNTT",["fovMax","fovMin","fov","node","carTs","camera","faguang"],0,1,1,1,1],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],2,1,9],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,4],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","lightProbeInfo"],3,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_distance","_shadowColor"],2,5],["cc.SkyboxInfo",["_diffuseMapHDR"],3,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["cc.LightProbeInfo",["_data"],3,4],["cc.LightProbesData",[],3],["cfe47QKymJG0YZDE2epIs5L",["node"],3,1],["cc.LabelShadow",["node","_offset"],3,1,5],["cc.LabelOutline",["node","_color"],3,1,5],["cc.Graphics",["node","_fillColor"],3,1,5],["ee3eb9KY/NLV6ZvVslC9grI",["node"],3,1],["c05c25C4xNAupWYMB93tIzp",["node","spriteList"],3,1,9],["0b358dK8zpLwLRoncNVrl9B",["node"],3,1],["71020G0TdFATqpc+etitfAC",["speed","node","luxian","lukouArr"],2,1,1,2],["e21642d7b9GcLYLpA1Tydhx",["node"],3,1],["cc.SpriteRenderer",["node","_materials","_spriteFrame"],3,1,3,6],["695c1BMMTNKJp0iGLtnRQiJ",["node","carTs","luxian"],3,1,1,1],["cc.DirectionalLight",["_colorTemperature","_illuminanceHDR","_shadowEnabled","node","_staticSettings"],0,1,4],["cc.StaticLightSettings",[],3],["cc.ShapeModule",["_enable","_shapeType","arcSpeed","_scale"],1,4,5],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.LimitVelocityOvertimeModule",["limitX","limitY","limitZ","limit"],3,4,4,4,4],["cc.TextureAnimationModule",["frameOverTime","startFrame"],3,4,4],["cc.NoiseModule",[],3],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["3edc7uRimxPuagQg3Yg2bRc",["speed","node","__prefab"],2,1,4]],[[64,0,1,2,2],[48,0,2],[63,0,1,2,3],[40,0,1,2,3,4,5,4],[0,2,5,6,11,3],[23,0,1,2,3],[65,0,1,2,2],[67,0,1,2,2],[11,1],[45,1],[38,0,1,2,3,4,5,5],[13,2,0,1,4,4],[6,0,1,1],[44,0,2],[66,0,1,2,2],[13,0,1,4,3],[35,0,1,2,3],[11,1,2],[8,2,6,3,4,5,1],[25,0,1,2],[19,1],[0,0,6,9,8,2],[0,0,9,11,2],[8,0,1,2,3,4,5,3],[3,4,5,1],[28,1],[8,0,2,3,4,5,2],[9,1,2,1],[0,0,6,9,8,12,13,2],[0,0,6,7,11,12,13,2],[0,0,1,6,7,8,10,3],[0,0,6,9,2],[0,0,6,7,8,10,2],[2,0,2,3,7,4],[3,0,4,5,2],[21,1,1],[0,0,6,7,11,8,12,13,2],[0,0,2,1,9,7,4],[0,0,2,1,6,7,4],[0,0,6,7,8,2],[0,0,6,7,11,8,2],[6,0,2,1,1],[3,0,4,7,5,2],[12,0,1,3],[6,0,1],[20,0,1,2],[9,1,1],[18,0,1,2,4],[0,2,5,11,3],[0,0,6,2],[0,0,2,1,6,9,7,8,4],[0,0,1,6,9,7,8,3],[0,0,6,9,8,10,2],[0,0,6,7,2],[0,0,6,7,11,8,10,2],[51,0,1,2,4],[83,0,1,1],[25,1,1],[11,0,3,2],[91,0,1,2,3,3],[92,0,1,2,3,1],[93,0,1,2,1],[94,0,1,2,3,1],[95,0,1,1],[96,1],[97,0,1,2,3,4,1],[19,0,2],[0,0,1,6,9,7,3],[0,0,2,1,6,7,8,4],[0,0,2,1,6,9,7,4],[0,0,1,6,7,10,3],[0,0,6,9,7,8,12,13,2],[0,0,6,7,8,12,13,2],[0,0,6,7,12,10,13,2],[0,0,1,6,9,8,10,3],[0,0,1,6,7,12,10,13,3],[0,0,3,6,8,3],[14,0,3,2,5,6,2],[2,0,6,5,4,1,2,3,7,8],[5,0,1,6,3,5,4,7,8,7],[22,0,2,2],[23,0,1,3,4,2,3],[60,0,1,2,2],[61,0,1,1],[62,0,1,1],[86,0,1],[29,1,1],[30,1,2,3,4,1],[31,2,3,4,1],[32,0,2,2],[33,0,3,2,2],[13,2,3,0,1,4,5],[0,0,1,6,9,7,11,8,3],[0,0,1,6,7,11,8,3],[0,0,6,9,11,8,12,13,2],[0,0,9,8,2],[0,0,3,1,6,9,7,4],[0,0,2,1,7,8,4],[0,0,1,6,7,3],[0,0,2,3,1,6,7,8,5],[0,0,1,6,7,8,3],[0,0,2,1,6,7,8,12,10,13,4],[0,0,6,7,8,12,10,13,2],[37,0,1,2,3,4,5,6,2],[6,0,1,3,1],[2,0,2,3,7,8,4],[3,4,6,5,1],[3,1,3,2,4,8,5,4],[15,0,2,3,1,2],[15,0,1,2],[54,0,1],[10,2,1],[59,0,1,2,3],[78,0,1],[24,0,1,2,3,4,4],[80,0,1,1],[87,0,1,2,1],[17,3,1,2,0,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,31,29,30,6],[32,1,0,2,3],[12,0,1,3,4],[18,3,0,1,2,5],[0,0,1,6,7,11,3],[0,0,1,6,7,11,12,10,13,3],[0,0,9,7,11,2],[0,0,2,9,3],[0,0,9,7,2],[0,0,2,9,7,3],[0,0,2,1,9,7,8,4],[0,0,1,9,7,3],[0,0,1,9,7,8,10,3],[0,0,2,1,4,9,7,8,5],[0,0,6,9,7,8,2],[0,0,4,6,9,7,3],[0,0,1,7,8,3],[0,0,6,8,2],[0,0,2,3,1,6,9,7,8,5],[0,0,2,1,6,9,7,8,10,4],[0,0,3,1,6,7,8,10,4],[0,0,3,1,6,7,8,12,13,4],[0,0,2,4,6,7,8,12,13,4],[0,0,4,6,7,3],[0,0,6,9,12,10,13,2],[0,0,1,6,7,8,12,10,13,3],[0,0,6,9,11,8,10,2],[0,0,9,7,11,10,2],[7,0,1,4,3,7,3],[7,0,1,4,3,8,3],[7,0,5,3,6,9,10,2],[7,0,2,1,5,3,6,4],[36,0,1,2,3,4,2],[14,0,1,3,2,4,3],[14,0,2,7,4,5,6,2],[39,0,1,2,3,4,5,4],[41,0,1,2,3,4,5,6],[42,0,1,2,3,4,5,3],[43,0,1,2,3,4,5,3],[8,2,3,4,5,1],[46,0,1,3],[6,0,2,1],[2,0,1,7,8,3],[2,0,5,1,7,4],[2,0,6,5,4,1,7,6],[2,0,1,7,3],[2,0,5,4,7,4],[2,0,4,1,2,3,7,9,6],[2,0,4,2,7,4],[2,0,7,2],[2,0,6,3,7,4],[47,0,1,1],[3,0,4,6,7,5,2],[3,1,0,2,4,6,4],[3,1,0,2,4,7,5,4],[15,0,2,4,3,1,2],[49,0,1,2,3,4,4],[5,0,1,2,3,5,7,9,6],[5,0,1,7,3],[5,0,1,6,2,4,7,8,6],[5,0,1,2,3,5,4,7,8,7],[5,0,1,6,2,3,4,7,8,7],[20,0,1,2,2],[50,0,1,2,3,1],[52,0,1,2,3,1],[53,0,2],[16,0,3,1,4,5,6,7,1],[16,0,2,1],[16,0,2,1,1],[21,0,1,2],[55,0,1,2,3,4,1],[56,0,1,2,1],[9,0,1,3,2,2],[9,0,1,4,3,2,2],[10,0,2,2],[10,1,2,2],[10,0,2,3,2],[57,0,1,2,3,4,5,6,4],[58,0,1,1],[22,1,2,2],[68,0,1,2,2],[69,0,1,2,3,2],[70,0,1,2,3,4,5,1],[71,0,1,2,3,4,2],[72,0,1,2],[73,0,1],[74,1],[75,1],[76,0,1],[77,1],[79,0,1,1],[24,0,1,3,4,3],[81,0,1,1],[82,0,1],[84,0,1],[26,0,1,6,3],[26,2,3,4,0,5,1,6,7,7],[85,0,1,2,3,2],[27,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,16,19,20,21,22,23,24,25,20],[27,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,19,20,21,22,23,24,25,18],[88,0,1,2,1],[89,0,1,2,3,4,4],[90,1],[17,1,2,0,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,31,29,30,4],[17,5,0,6,32,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3],[28,0,1,2,2],[11,0,2,3,3],[29,0,1,2],[30,0,1,2,3,4,2],[31,0,1,2,3,4,3],[12,0,1,2,4],[12,0,1,2,3,5],[33,1,2,2],[98,0,1,2,2]],[[[[91,"warn",1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"tilingOffset",8,[2,1,-1,0,0],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[33,12]],[[[16,".bin",1007565106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2520,"length":78,"count":39,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":59838,"length":1608,"count":804,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":2520,"count":35,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2598,"length":57240,"count":795,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5.039836406707764,-4.9297099113464355,0.3939473330974579],"maxPosition",8,[1,4.994390487670898,4.9462571144104,19.378662109375]]],-1],0,0,[],[],[]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0.641,"metallic":0.243,"specularIntensity":0},"emissive",8,[4,0],"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[12,4],[34,12]],[[[20],[22,"tree2",[-2],[10,"d3BBkeGjhYuoyllyVyuiuL",null,null,null,-1,0]],[29,"tree2_对象002",1,[[18,-3,[13,"fdFJiZ+nZSzIMBM+kmWvSk"],[0,1],[9],2]],[10,"88tJ49gbxc0qEBHrHAx2zJ",null,null,null,1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0],[-1,-2,5],[66,35,2]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{},{}],[[[{"roughness":0,"specularIntensity":0},"mainColor",8,[4,4278226943]],{},{},{}],11,0,0,0]]],0,0,[0],[4],[12]],[[[20],[22,"shuita",[-2],[10,"d5/ZT1sa5dxJJMAbjBKoSi",null,null,null,-1,0]],[36,"对象001",1,[[18,-3,[13,"00L7er0q9bTqSc3izhsxb/"],[0,1,2,3,4],[9],5]],[10,"d2X7sb0WVX76UMnP3Sc77y",null,null,null,1,0],[1,-18.781585693359375,1.3113437091760716e-7,-6.846620559692383],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0,0,0,0],[-1,-2,-3,-4,-5,5],[67,68,69,70,71,72]],[[[11,"Material__31.001",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288849836],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__33.001",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288849836],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__34.001",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288849836],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__32.001",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288849836],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.3,"transparencyFactor":0},"mainColor",8,[4,4288849836],"specularColor",8,[4,4284310121]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[16,".bin",3543641112,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":21312,"length":2556,"count":1278,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":24508,"length":48,"count":24,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":25196,"length":48,"count":24,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":25948,"length":54,"count":27,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":26642,"length":48,"count":24,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":21312,"count":333,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":23868,"length":640,"count":10,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":24556,"length":640,"count":10,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":25244,"length":704,"count":11,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":26002,"length":640,"count":10,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,16.05523109436035,0.20556972920894623,-0.49936047196388245],"maxPosition",8,[1,21.53075408935547,5.772448539733887,27.483335494995117]]],-1],0,0,[],[],[]],[[[16,".bin",3044963086,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":134496,"length":11646,"count":5823,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":134496,"count":2802,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.117631196975708,-3.393524408340454,-0.014780226163566113],"maxPosition",8,[1,1.1176315546035767,3.3935248851776123,2.411158800125122]]],-1],0,0,[],[],[]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4290559164],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[73,4]],[[[16,".bin",2489017538,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":1200,"count":600,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[16,".bin",2531713262,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[{"name":"speed","rect":{"x":0,"y":0,"width":131,"height":53},"offset":{"x":0,"y":0},"originalSize":{"width":131,"height":53},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-65.5,-26.5,0,65.5,-26.5,0,-65.5,26.5,0,65.5,26.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,53,131,53,0,0,131,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-65.5,"y":-26.5,"z":0},"maxPos":{"x":65.5,"y":26.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[74]],[[[157,"lihua",".plist"],-1],0,0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[75]],[[[11,"Material__45.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4292337378],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__56.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__42.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4292337378],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__54.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__46.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4292337378],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Barrels___pipes.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4284444855],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__53.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4284310121],"specularColor",8,[4,4288849836]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[11,"Material__57.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__39.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4287335564],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4285692288],"specularColor",8,[4,4289902524]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[16,".bin",2228162186,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22272,"length":1188,"count":594,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":30116,"length":492,"count":246,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":33808,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":37248,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":38256,"length":48,"count":24,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":47008,"length":792,"count":396,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[6],"indexView":{"offset":139320,"length":5112,"count":2556,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[7],"indexView":{"offset":147632,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[8],"indexView":{"offset":151072,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[9],"indexView":{"offset":154512,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[10],"indexView":{"offset":157952,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[11],"indexView":{"offset":159472,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[12],"indexView":{"offset":161324,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[13],"indexView":{"offset":162664,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[14],"indexView":{"offset":164260,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[15],"indexView":{"offset":165728,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[16],"indexView":{"offset":167324,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[17],"indexView":{"offset":168920,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[18],"indexView":{"offset":170516,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[19],"indexView":{"offset":171984,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[20],"indexView":{"offset":173580,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[21],"indexView":{"offset":175176,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[22],"indexView":{"offset":177028,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[23],"indexView":{"offset":178368,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[24],"indexView":{"offset":179708,"length":60,"count":30,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[25],"indexView":{"offset":182968,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[26],"indexView":{"offset":186408,"length":240,"count":120,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22272,"count":348,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":23460,"length":6656,"count":104,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":30608,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":34048,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":37488,"length":768,"count":12,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":38304,"length":8704,"count":136,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":47800,"length":91520,"count":1430,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":144432,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":147872,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":151312,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":154752,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":158192,"length":1280,"count":20,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":159532,"length":1792,"count":28,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":161384,"length":1280,"count":20,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":162724,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":164320,"length":1408,"count":22,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":165788,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":167384,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":168980,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":170576,"length":1408,"count":22,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":172044,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":173640,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":175236,"length":1792,"count":28,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":177088,"length":1280,"count":20,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":178428,"length":1280,"count":20,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":179768,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":183208,"length":3200,"count":50,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-19.000001907348633,-16.000001907348633,-0.0000015298987818823662],"maxPosition",8,[1,35.000003814697266,31.000001907348633,25]]],-1],0,0,[],[],[]],[[[20],[22,"workshop4",[-2],[10,"ee3VwsghVbmpo/rDOcTyf2",null,null,null,-1,0]],[36,"工厂",1,[[18,-3,[13,"6ajd+2Bo9dXINArXCN0AJL"],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26],[9],27]],[10,"83sbSNlExf2rJucvSrDdmJ",null,null,null,1,0],[1,0.7664013504981995,0,-6.846620559692383],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,5],[76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,9,36,100,101]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"metallic":0,"emissiveScale":0},"mainColor",8,[4,4288581736]],{},{}],11,0,0]]],0,0,[0],[4],[13]],[[[11,"Material__43.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4292337378],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Floor_outside.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4286809219],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[47,[{"metallic":0,"emissiveScale":0},{},{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}]]],0,0,[0],[4],[13]],[[[11,"Material__55.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__58.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__44.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4292337378],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__49.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__41.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4278190080],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__59.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288581736],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__50.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__47.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__51.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__40.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4278190080],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__48.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material__52.006",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288981655],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[66,"loading"],[145,"loading",33554432,[-11,-12],[[[41,-6,[13,"8fuH7S8oVJgKXYuWSKu1kw"],[5,720,1280]],[105,45,100,100,-7,[13,"35wIO6FFpEX4F8IfcbGON1"]],[168,-8,[13,"6exsxfDGNB9YJyPcmQZf8M"]],[169,0,-9,[13,"c0FodLu0pB35qucMcOhERb"],[4,4278190080],2],-10],4,4,4,4,1],[152,"18DHm6XMpAsr6zhFX96aQO",null,null,-5,0,[[108,["icon"],-2,-1,[1,["06QoCkDMBFgLt46yyG+Esl"]]],[108,["yingzi"],-4,-3,[1,["fcBLX4JEhH/rYw9x1dwzLo"]]]]]],[92,"bottomBox",33554432,1,[-16,-17],[[41,-13,[13,"f5E2Zc43JCdYDl9FdY/xQi"],[5,543.3399999999999,100]],[173,1,1,50,-14,[13,"a9AMsK/4BJdp75CJdMqYn+"]],[159,4,44.69200000000001,-15,[13,"0aKJJe5j1IUIjSgiG0iudR"]]],[10,"b1i9WV4lVMb71seYmFkfD9",null,null,null,1,0],[1,0,-545.308,0]],[121,"bg",33554432,1,[[41,-18,[13,"7dB3wlMpdB85yUEqDrb+Wu"],[5,720,1280]],[170,2,0,1,-19,[13,"e4JVt3n4ROWoixgwFBZb0E"]],[105,45,100,100,-20,[13,"94n4mU+ChCuagyQ0LljxqJ"]]],[10,"34pyTffC5Lqp5P82XWmjwh",null,null,null,1,0]],[92,"game",33554432,2,[-22,-23],[[158,-21,[13,"8du1n9UYdG251JCfBADoef"]]],[10,"aaySSlkM1OCK34UxJRLLrz",null,null,null,1,0],[1,-221.66999999999996,0,0]],[93,"yingzi",33554432,4,[[41,-24,[13,"4bcoZIegFBfI6AqCOjfQjD"],[5,89,21]],[106,-25,[13,"fbT1qazeNF8pnYOPQNGYp0"],0]],[10,"46oQGupa1Ikb5HTKWMtANu",null,null,null,1,0],[1,0,-45.773,0]],[122,"game",33554432,4,[[41,-26,[13,"257VZUlfdKlJxQNhKBKAth"],[5,100,64]],[106,-27,[13,"8fYzIOTNZK7a6cz05qbvQk"],1]],[10,"33azL8B0ZI6qQ8q/6sMmij",null,null,null,1,0],[3,0,0,-0.08715574274765817,0.9961946980917455],[1,-1,1,1],[1,0,0,-10]],[93,"Label3",33554432,2,[[41,-28,[13,"84hCeYcTpE8JEqL6BlFj9w"],[5,393.34,63]],[174,"正在加载可播放广告...",40,50,2,false,-29,[13,"e4ql7v3U1EJadts7uIFnSr"]],[179,"load.txt",-30,[13,"6deefTPjRDUbI1YOPNnHH+"]]],[10,"17z3QGdoJMZrhyLSZSoElj",null,null,null,1,0],[1,75.00000000000003,0,0]],[180,1,[13,"9eM4RYP8FMY7aBSgqK6gna"],6,5]],0,[0,14,2,0,17,8,0,14,2,0,17,8,0,0,1,0,2,1,0,2,1,0,2,1,0,2,1,0,-5,8,0,-1,3,0,-2,2,0,2,2,0,2,2,0,2,2,0,-1,4,0,-2,7,0,2,3,0,2,3,0,2,3,0,2,4,0,-1,5,0,-2,6,0,2,5,0,2,5,0,2,6,0,2,6,0,2,7,0,2,7,0,2,7,0,10,1,30],[0,0,0],[7,7,7],[102,103,15]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":2},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4284444855]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[20],[22,"guandao",[-2],[10,"39crQLrAJQPIwc4nRRIYEY",null,null,null,-1,0]],[36,"对象001",1,[[18,-3,[13,"99qfcEGdJc5Yabk7wBcHIe"],[0],[9],1]],[10,"ac9hqt031a1qSggcx3LNql",null,null,null,1,0],[1,-13.035655975341797,-0.000001220703097715159,-6.649961948394775],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0],[-1,5],[104,105]],[[[16,".bin",2929955473,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8832,"length":1032,"count":516,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8832,"count":138,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-30.778362274169922,0.837291419506073,-2.0164055824279785],"maxPosition",8,[1,-15.624131202697754,7.191027641296387,14.164653778076172]]],-1],0,0,[],[],[]],[[[55,"util/dcc/imported-metallic-roughness",[{"hash":3246930642,"name":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalStrength, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor.rgb;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = vec4(1.0,1.0,1.0,1.0);\n  float occlusionValue = 1.0;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture(occlusionMap, TEXTURE_UV);\n     float occlusionColorValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionColorValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n     occlusionValue = mix(1.0, occlusionColorValue, occlusion);\n  #endif\n  pbr.x = occlusionValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  pbr.y = max(0.02, roughnessValue);\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  pbr.z = metallicValue;\n  pbr.w = 0.5;\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      envSpec = mix(envmap, envSpec, fixedR.w);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = mix(envmap, EnvReflection(tex, R, roughness, mipCount), fixedR.w);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize);\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_IOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) ||\n            ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColorX = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_RGBE_OUTPUT || CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    #if !CC_USE_RGBE_OUTPUT && !CC_USE_FLOAT_OUTPUT && !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      fragColor0 = CCSurfacesDeferredOutput0(surfaceData);\n      fragColor1 = CCSurfacesDeferredOutput1(surfaceData);\n      fragColor2 = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColor0 = debugColor;\n      }\n    #endif\n    }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform vec4 emissive;\n    uniform float emissiveScale;\n    uniform float occlusion;\n    uniform float roughness;\n    uniform float metallic;\n    uniform float normalStrength;\n    uniform float alphaSource;\n    uniform float albedoScale;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture2D(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalStrength, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor.rgb;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = vec4(1.0,1.0,1.0,1.0);\n  float occlusionValue = 1.0;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture2D(occlusionMap, TEXTURE_UV);\n     float occlusionColorValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionColorValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n     occlusionValue = mix(1.0, occlusionColorValue, occlusion);\n  #endif\n  pbr.x = occlusionValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture2D(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  pbr.y = max(0.02, roughnessValue);\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture2D(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  pbr.z = metallicValue;\n  pbr.w = 0.5;\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      envSpec = mix(envmap, envSpec, fixedR.w);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = mix(envmap, EnvReflection(tex, R, roughness, mipCount), fixedR.w);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize);\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_IOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) ||\n            ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_RGBE_OUTPUT || CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    #if !CC_USE_RGBE_OUTPUT && !CC_USE_FLOAT_OUTPUT && !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutput0(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutput1(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":99,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":129}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_WEIGHT_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"METALLIC_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ROUGHNESS_MAP","type":"boolean"},{"name":"ROUGHNESS_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"USE_TRANSPARENCYCOLOR_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_OPACITY_MAP","type":"boolean"},{"name":"ALPHA_SOURCE_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"ALPHA_SOURCE_IS_OPACITY","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"USE_OCCLUSION_CHANNEL","type":"boolean"},{"name":"USE_ROUGHNESS_CHANNEL","type":"boolean"},{"name":"USE_METALLIC_CHANNEL","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_DIFFUSE","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_SPECULAR","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":1990874237,"name":"util/dcc/imported-metallic-roughness|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":[]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = albedo.a;\n      #if USE_ALBEDO_MAP\n        alpha = texture(albedoMap, TEXTURE_UV).a;\n      #endif\n      #if ALPHA_SOURCE_IS_OPACITY\n        #if USE_OPACITY_MAP\n          alpha = 1.0 - texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n        #else\n          alpha = 1.0 - alphaSource;\n        #endif\n      #else\n        #if USE_OPACITY_MAP\n          alpha = texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n        #else\n          alpha = alphaSource;\n        #endif\n      #endif\n      if (alpha < albedoScaleAndCutoff.w) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform float alphaSource;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = albedo.a;\n      #if USE_ALBEDO_MAP\n        alpha = texture2D(albedoMap, TEXTURE_UV).a;\n      #endif\n      #if ALPHA_SOURCE_IS_OPACITY\n        #if USE_OPACITY_MAP\n          alpha = 1.0 - texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n        #else\n          alpha = 1.0 - alphaSource;\n        #endif\n      #else\n        #if USE_OPACITY_MAP\n          alpha = texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n        #else\n          alpha = alphaSource;\n        #endif\n      #endif\n      if (alpha < albedoScaleAndCutoff.w) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvarying highp vec2 v_clip_depth;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":99,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":129}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_WEIGHT_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"METALLIC_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ROUGHNESS_MAP","type":"boolean"},{"name":"ROUGHNESS_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"USE_TRANSPARENCYCOLOR_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_OPACITY_MAP","type":"boolean"},{"name":"ALPHA_SOURCE_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_SOURCE_IS_OPACITY","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1]},"roughness":{"type":13,"value":[1]},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1]},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[0]},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1]},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey"},"albedoScaleAndCutoff":{"type":16,"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1]},"roughness":{"type":13,"value":[1]},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1]},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[0]},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1]},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey"},"albedoScaleAndCutoff":{"type":16,"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]],[[{"name":"warn","rect":{"x":0,"y":0,"width":295,"height":260},"offset":{"x":0,"y":0},"originalSize":{"width":295,"height":260},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-147.5,-130,0,147.5,-130,0,-147.5,130,0,147.5,130,0],"indexes":[0,1,2,2,1,3],"uv":[0,260,295,260,0,0,295,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-147.5,"y":-130,"z":0},"maxPos":{"x":147.5,"y":130,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[33]],[[[11,"boxOpen",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294967295],"mainTexture",6,0]],11]]],0,0,[0,0],[12,4],[37,38]],[[[11,"plane",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"metallic":0.5,"occlusion":0.5},"mainColor",8,[4,4282006074],"emissive",8,[4,4286809219],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[106,13]],[[[11,"CarLP_COLLECTION_M3.005",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4283321934],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[16,".bin",4029168906,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":59904,"length":2748,"count":1374,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":66396,"length":168,"count":84,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":82116,"length":852,"count":426,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":88152,"length":336,"count":168,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":90504,"length":96,"count":48,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":93864,"length":144,"count":72,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":59904,"count":1248,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":62652,"length":3744,"count":78,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":66564,"length":15552,"count":324,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":82968,"length":5184,"count":108,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":88488,"length":2016,"count":42,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":90600,"length":3264,"count":68,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.026076119393110275,-0.1018897220492363,-0.007756780367344618],"maxPosition",8,[1,0.06311903148889542,-0.01689705066382885,0.015553300268948078]]],-1],0,0,[],[],[]],[[[20],[22,"xiaoche02",[-2],[10,"d8NOYrfgpez5xNKGaynGpk",null,null,null,-1,0]],[94,"组002",1,[-3,-4,-5],[10,"4cFSDxjkRedorV+IANva3H",null,null,null,1,0],[1,0,0.012977998703718185,1.6810489111840354e-10],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]],[40,"Car_003",2,[[18,-6,[13,"37ICG6xelY/YNzqzdncxFn"],[0,1,2,3,4,5],[9],6]],[10,"c5oQ7wxuVUxq1DDv9luaL0",null,null,null,1,0],[1,-0.0445975735783577,0.05939338728785515,-0.0024263844825327396]],[40,"Whells1_003",2,[[18,-7,[13,"04jghcRyVQG6vRlVlCaTtm"],[7,8],[9],9]],[10,"aevBT3ZyZUwZ0OXk96gIr2",null,null,null,1,0],[1,-0.0445975735783577,0.05939338728785515,-0.0024263844825327396]],[40,"Whells2_003",2,[[18,-8,[13,"7a989X2zFXfILxsRRKJsY/"],[10,11],[9],12]],[10,"332++dGplfiKFPNi5VIOjT",null,null,null,1,0],[1,-0.0445975735783577,0.05939338728785515,-0.0024263844825327396]]],0,[0,0,1,0,-1,2,0,-1,3,0,-2,4,0,-3,5,0,2,3,0,2,4,0,2,5,0,10,1,8],[0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,5,-1,-2,5,-1,-2,5],[107,108,109,110,111,112,113,39,40,114,39,40,115]],[[[11,"CarLP_COLLECTION_M2.005",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288190588],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M6.005",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4284440501],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[16,".bin",1075878907,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":37056,"length":2328,"count":1164,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":74472,"length":2820,"count":1410,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":37056,"count":772,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":39384,"length":35088,"count":731,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.027443811297416687,-0.04189891740679741,-0.01068839430809021],"maxPosition",8,[1,0.0617513470351696,-0.029936324805021286,0.0012552274856716394]]],-1],0,0,[],[],[]],[[[11,"CarLP_COLLECTION_M9.005",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4282669721],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M1_4.001",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4284310672],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M4.005",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4289128421],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M7.005",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4283451454],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[16,".bin",3156061198,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":36480,"length":2304,"count":1152,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":74640,"length":2838,"count":1419,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":36480,"count":760,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":38784,"length":35856,"count":747,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.027443811297416687,-0.09230297803878784,-0.01068839430809021],"maxPosition",8,[1,0.0617513433098793,-0.08034038543701172,0.001255225040949881]]],-1],0,0,[],[],[]],[[[11,"CarLP_COLLECTION_M5.005",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4289192679],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"roughness":0.5678071975708008,"metallic":0},"mainColor",8,[4,4280101240],"emissive",8,[4,4284444855]],{},{}],11,0,0]]],0,0,[0],[4],[13]],[[[20],[123,"workshop1",[-3],[[181,-2,[13,"31hjs6+zpQa4iuEdjRZgSJ"],[8],9]],[10,"45T788omlTTIwj2OQV2VyN",null,null,null,-1,0]],[36,"房子01",1,[[18,-4,[13,"3bJdrVYOVZAoPRyVuRu9TN"],[0,1,2,3,4,5,6],[9],7]],[10,"01ZPp9Tr1cKpBzGVXRdnGt",null,null,null,1,0],[1,2.396962881088257,0,-2.363823175430298],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,2,1,0,-1,2,0,2,2,0,10,1,4],[0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,5,-1,22],[116,117,118,119,120,121,122,123,41,41]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"roughness":0.5678071975708008,"metallic":0},"mainColor",8,[4,4287335564]],{},{}],11,0,0]]],0,0,[0],[4],[13]],[[[47,[{"roughness":0,"metallic":0},{},{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}]]],0,0,[0],[4],[13]],[[[47,[{"occlusion":0.001,"roughness":0,"specularIntensity":0},{},{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}]]],0,0,[0],[4],[42]],[[[16,".bin",3239627144,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":160000,"length":10146,"count":5073,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":184098,"length":876,"count":438,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":186894,"length":120,"count":60,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":313606,"length":6156,"count":3078,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":385682,"length":3648,"count":1824,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":391378,"length":96,"count":48,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[6],"indexView":{"offset":391986,"length":24,"count":12,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":160000,"count":2500,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":170146,"length":13952,"count":218,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":184974,"length":1920,"count":30,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":187014,"length":126592,"count":1978,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":319762,"length":65920,"count":1030,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":389330,"length":2048,"count":32,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":391474,"length":512,"count":8,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-6.4644455909729,-3.066265821456909,0.03442572057247162],"maxPosition",8,[1,4.401304721832275,3.066265821456909,5.167037487030029]]],-1],0,0,[],[],[]],[[[11,"Factory_ThirdColor_001",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"albedoScale":1,"metallic":0,"roughness":0.5678071975708008,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4291555316],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[13]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"roughness":0.5678071975708008,"metallic":0},"mainColor",8,[4,4282861603],"emissive",8,[4,4288581736]],{},{}],11,0,0]]],0,0,[0],[4],[13]],[[[47,[{"roughness":0,"metallic":0},{},{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}]]],0,0,[0],[4],[13]],[[{"name":"btn2","rect":{"x":0,"y":0,"width":227,"height":222},"offset":{"x":0,"y":0},"originalSize":{"width":227,"height":222},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-113.5,-111,0,113.5,-111,0,-113.5,111,0,113.5,111,0],"indexes":[0,1,2,2,1,3],"uv":[0,222,227,222,0,0,227,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-113.5,"y":-111,"z":0},"maxPos":{"x":113.5,"y":111,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[124]],[[[182,"game"],[124,"cao",512,[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162,-163,-164,-165,-166,-167,-168,-169,-170,-171,-172,-173,-174,-175,-176,-177,-178,-179,-180,-181,-182,-183,-184,-185,-186,-187,-188,-189,-190,-191,-192,-193,-194,-195,-196,-197,-198,-199,-200,-201,-202,-203,-204,-205,-206,-207,-208,-209,-210,-211,-212,-213,-214,-215,-216,-217,-218,-219,-220,-221,-222,-223,-224,-225,-226,-227,-228,-229,-230,-231,-232,-233,-234,-235,-236,-237,-238,-239,-240,-241,-242,-243,-244,-245,-246,-247,-248,-249,-250,-251,-252,-253,-254,-255,-256,-257,-258,-259,-260,-261,-262,-263,-264,-265,-266,-267,-268,-269,-270,-271,-272,-273,-274,-275,-276,-277,-278,-279,-280,-281,-282,-283,-284,-285,-286,-287,-288,-289,-290,-291,-292,-293,-294,-295,-296,-297,-298,-299,-300,-301,-302,-303,-304,-305,-306,-307,-308,-309,-310,-311,-312,-313,-314,-315,-316,-317,-318,-319,-320,-321,-322,-323,-324,-325,-326,-327,-328,-329,-330,-331,-332,-333,-334,-335,-336,-337,-338,-339,-340,-341,-342,-343,-344,-345,-346,-347,-348,-349,-350,-351,-352,-353,-354,-355,-356,-357,-358,-359,-360,-361,-362,-363,-364,-365,-366,-367,-368,-369,-370,-371,-372]],[125,"tree2",[-374,-375,-376,-377,-378,-379,-380,-381,-382,-383,-384,-385,-386,-387,-388,-389,-390,-391,-392,-393,-394,-395,-396,-397,-398,-399,-400,-401,-402,-403,-404,-405,-406,-407,-408,-409,-410,-411,-412,-413,-414,-415,-416,-417,-418,-419,-420,-421,-422,-423,-424,-425,-426,-427,-428,-429,-430,-431,-432,-433,-434,-435,-436,-437,-438,-439,-440,-441,-442,-443,-444,-445,-446,-447,-448,-449,-450,-451,-452,-453,-454,-455,-456,-457,-458,-459,-460,-461,-462,-463,-464,-465,-466,-467,-468,-469,-470,-471,-472,-473,-474,-475,-476,-477,-478,-479,-480,-481,-482,-483,-484,-485,-486,-487,-488,-489,-490,-491,-492,-493,-494,-495,-496,-497,-498,-499,-500,-501,-502,-503,-504,-505,-506,-507,-508,-509,-510,-511,-512,-513,-514,-515,-516,-517,-518,-519,-520,-521,-522,-523,-524,-525,-526,-527,-528,-529,-530,-531,-532,-533,-534,-535,-536,-537,-538,-539,-540,-541,-542,-543,-544,-545,-546,-547,-548,-549,-550,-551,-552,-553,-554,-555,-556,-557,-558,-559,-560,-561,-562,-563,-564,-565,-566,-567,-568,-569,-570,-571,-572,-573,-574,-575,-576,-577,-578,-579,-580,-581,-582,-583,-584,-585,-586,-587,-588,-589,-590,-591,-592,-593,-594,-595,-596,-597,-598,-599,-600,-601,-602,-603,-604,-605,-606,-607,-608,-609,-610,-611,-612,-613,-614,-615,-616,-617,-618,-619,-620,-621,-622,-623,-624,-625,-626,-627,-628,-629,-630,-631,-632,-633,-634,-635,-636,-637,-638,-639,-640,-641,-642,-643,-644,-645,-646,-647,-648],[[110,-373]]],[126,"tree1",512,[-650,-651,-652,-653,-654,-655,-656,-657,-658,-659,-660,-661,-662,-663,-664,-665,-666,-667,-668,-669,-670,-671,-672,-673,-674,-675,-676,-677,-678,-679,-680,-681,-682,-683,-684,-685,-686,-687,-688,-689,-690,-691,-692,-693,-694,-695,-696,-697,-698,-699,-700,-701,-702,-703,-704,-705,-706,-707,-708,-709,-710,-711,-712,-713,-714,-715,-716,-717,-718,-719,-720,-721,-722,-723,-724,-725,-726,-727,-728,-729,-730,-731,-732,-733,-734,-735,-736,-737,-738,-739,-740,-741,-742,-743,-744,-745,-746,-747,-748,-749,-750,-751,-752,-753,-754,-755,-756,-757,-758,-759,-760,-761,-762,-763,-764,-765,-766,-767,-768,-769,-770,-771,-772,-773,-774,-775,-776,-777],[[110,-649]]],[95,"Box",[-778,-779,-780,-781,-782,-783,-784,-785,-786,-787,2,3,1,-788,-789,-790,-791,-792,-793,-794,-795,-796,-797,-798,-799,-800,-801],[1,-6.674,0,-66.85]],[31,"deng",4,[-802,-803,-804,-805,-806,-807,-808,-809,-810,-811,-812,-813,-814,-815,-816,-817,-818,-819,-820,-821,-822]],[95,"plan7",[-823,-824,-825,-826,-827,-828,-829,-830,-831,-832,-833,-834,-835,-836,-837,-838,-839,-840],[1,-142.582,0,-290.475]],[31,"Road",4,[-841,-842,-843,-844,-845,-846,-847,-848,-849,-850,-851,-852,-853,-854]],[1,["6ajd+2Bo9dXINArXCN0AJL"]],[127,"StopButton",512,33554432,[-860,-861,-862,-863,-864,-865,-866],[[12,-855,[5,233,233]],[183,-857,[4,4292269782],-856,1213,1214,1215,1216],[160,20,243.5,79.46800000000007,-858],[35,-859]],[1,0,-444.0319999999999,0]],[128,"ui",33554432,[-877,-878,-879,-880,-881],[[12,-867,[5,720,1280]],[33,45,100,100,-868],[187,-876,-875,-874,[-872,-873],[-869,-870,-871]]]],[129,"progress",33554432,[-887,-888,-889,-890,-891,-892],[[12,-882,[5,715,66]],[24,-883,22],[188,-886,-885,-884]],[1,17.026,0,0],[1,0.8,0.8,1]],[146,"Car",8388608,[-896,-897,-898],[[[189,true,-893,[1,0,0.5,-0.1],[1,1.4,1,4.5]],-894,[191,false,-895]],4,1,4],[1,3,3,3]],[31,"Luxian",4,[-899,-900,-901,-902,-903,-904]],[37,"touchNode",512,33554432,[-911,9,-912],[[12,-905,[5,720,1280]],[33,45,100,100,-906],[194,40,35,40,-910,-909,-908,-907]]],[31,"Structure",4,[-913,-914,-915,-916,-917,-918,6]],[130,"Canvas",512,33554432,"32aYpMdGZBX4Xpdebv6CxZ",[-923,14,10],[[12,-919,[5,720,1280]],[195,-921,-920],[161,45,5.684341886080802e-14,5.684341886080802e-14,1.1368683772161603e-13,1.1368683772161603e-13,-922]],[1,360.00000000000006,640.0000000000001,0]],[96,"failBox",false,33554432,10,[-927,-928],[[12,-924,[5,720,1280]],[33,45,100,100,-925],[184,-926,[[112,"1bd472YvrBDLoDTsHGhTuKf","againBtn",10]]]]],[67,"content",33554432,17,[-931,-932,-933,-934],[[12,-929,[5,720,1280]],[33,45,100,100,-930]]],[96,"winBox",false,33554432,10,[-938,-939,-940],[[12,-935,[5,720,1280]],[33,45,100,100,-936],[185,-937,[[112,"1bd472YvrBDLoDTsHGhTuKf","downBtn",10]],17]]],[37,"bg",512,33554432,[-945],[[12,-941,[5,110,111]],[78,45,7.5,7.5,7,7,100,100,-942],[80,3,-943],[34,0,-944,10]]],[37,"bg",512,33554432,[-950],[[12,-946,[5,110,111]],[78,45,7.5,7.5,7,7,100,100,-947],[80,3,-948],[34,0,-949,14]]],[37,"bg",512,33554432,[-955],[[12,-951,[5,110,111]],[78,45,7.5,7.5,7,7,100,100,-952],[80,3,-953],[34,0,-954,18]]],[131,"End",13,[-958],[[23,"Cube<ModelComponent>",false,-956,[1162],[9],1163],[27,-957,[1,5,1,1]]],[1,-142.756,0.2,-271.016]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[48,0,null,[3,"d2TjgTD/1aGbQ0jo2pMXya",null,null,-967,[81,"444KkUCLlH6LHX3j7lNW6f",null,[[83,[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[-966]]],[[84,[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[[111,-964],[27,-965,[1,0.5,1,11]]]]],[[2,"jiansudai",["_name"],-959],[0,["_lpos"],-960,[1,-108.576,0,-61.816]],[0,["_lrot"],-961,[3,0,0,0,1]],[0,["_euler"],-962,[1,0,0,0]],[0,["_lscale"],-963,[1,3,2,0.9]],[6,["_lpos"],[1,["abGJHp8AlZS7UyGki127PX"]],[1,0,0,0]]]],54]],[48,0,null,[3,"d2TjgTD/1aGbQ0jo2pMXya",null,null,-976,[81,"bdaC5Tn5hM57XOwCzx4r9N",null,[[83,[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[-975]]],[[84,[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[[111,-973],[27,-974,[1,0.5,1,11]]]]],[[2,"jiansudai",["_name"],-968],[0,["_lpos"],-969,[1,-142.623,0,-191.39]],[0,["_lrot"],-970,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],-971,[1,0,90,0]],[0,["_lscale"],-972,[1,3,2,0.9]],[6,["_lpos"],[1,["abGJHp8AlZS7UyGki127PX"]],[1,0,0,0]]]],62]],[67,"content",33554432,19,[-979,-980,-981],[[12,-977,[5,720,1280]],[33,45,100,100,-978]]],[68,"tips",512,33554432,14,[[12,-982,[5,200,90.4]],[175,"长按按钮\n为汽车减速",40,-983],[162,4,380,-984],[35,-985],[45,"guide.txt",-986]],[1,0,-214.8,0]],[198,"game",[-1854,-1855,-1856,16],[153,null,null,"4265d3c3-99a3-4f35-b0ae-5104c4c2e4d6",null,[],[-987,-988,-989,-990,-991,-992,-993,-994,-995,-996,-997,-998,-999,-1000,-1001,-1002,-1003,-1004,-1005,-1006,-1007,-1008,-1009,32,33,-1010,-1011,-1012,-1013,-1014,-1015,-1016,-1017,-1018,-1019,-1020,-1021,-1022,-1023,-1024,-1025,-1026,-1027,-1028,-1029,-1030,-1031,-1032,-1033,-1034,-1035,-1036,-1037,-1038,-1039,-1040,-1041,-1042,-1043,-1044,-1045,-1046,-1047,-1048,-1049,-1050,-1051,-1052,-1053,-1054,-1055,-1056,-1057,-1058,-1059,-1060,-1061,-1062,-1063,-1064,-1065,-1066,-1067,-1068,-1069,-1070,-1071,-1072,-1073,-1074,-1075,-1076,-1077,-1078,-1079,-1080,-1081,-1082,-1083,-1084,-1085,-1086,-1087,-1088,-1089,-1090,-1091,-1092,-1093,-1094,-1095,-1096,-1097,-1098,-1099,-1100,-1101,-1102,-1103,-1104,-1105,-1106,-1107,-1108,-1109,-1110,-1111,-1112,-1113,-1114,-1115,-1116,-1117,-1118,-1119,-1120,-1121,-1122,-1123,-1124,-1125,-1126,-1127,-1128,-1129,-1130,-1131,-1132,-1133,-1134,-1135,-1136,-1137,-1138,-1139,-1140,-1141,-1142,-1143,-1144,-1145,-1146,-1147,-1148,-1149,-1150,-1151,-1152,-1153,-1154,-1155,-1156,-1157,-1158,-1159,-1160,-1161,-1162,-1163,-1164,-1165,-1166,-1167,-1168,-1169,-1170,-1171,-1172,-1173,-1174,-1175,-1176,-1177,-1178,-1179,-1180,-1181,-1182,-1183,-1184,-1185,-1186,-1187,-1188,-1189,-1190,-1191,-1192,-1193,-1194,-1195,-1196,-1197,-1198,-1199,-1200,-1201,-1202,-1203,-1204,-1205,-1206,-1207,-1208,-1209,-1210,-1211,-1212,-1213,-1214,-1215,-1216,-1217,-1218,-1219,-1220,-1221,-1222,-1223,-1224,-1225,-1226,-1227,-1228,-1229,-1230,-1231,-1232,-1233,-1234,-1235,-1236,-1237,-1238,-1239,-1240,-1241,-1242,-1243,-1244,-1245,-1246,-1247,-1248,-1249,-1250,-1251,-1252,-1253,-1254,-1255,-1256,-1257,-1258,-1259,-1260,-1261,-1262,-1263,-1264,-1265,-1266,-1267,-1268,-1269,-1270,-1271,-1272,-1273,-1274,-1275,-1276,-1277,-1278,-1279,-1280,-1281,-1282,-1283,-1284,-1285,-1286,-1287,-1288,-1289,-1290,-1291,-1292,-1293,-1294,-1295,-1296,-1297,-1298,-1299,-1300,-1301,-1302,-1303,-1304,-1305,-1306,-1307,-1308,-1309,-1310,-1311,-1312,-1313,-1314,-1315,-1316,-1317,-1318,-1319,-1320,-1321,-1322,-1323,-1324,-1325,-1326,-1327,-1328,-1329,-1330,-1331,-1332,-1333,-1334,-1335,-1336,-1337,-1338,-1339,-1340,-1341,-1342,-1343,-1344,-1345,-1346,-1347,-1348,-1349,-1350,-1351,-1352,-1353,-1354,-1355,-1356,-1357,-1358,-1359,-1360,-1361,-1362,-1363,-1364,-1365,-1366,-1367,-1368,-1369,-1370,-1371,-1372,-1373,-1374,-1375,-1376,-1377,-1378,-1379,-1380,-1381,-1382,-1383,-1384,-1385,-1386,-1387,-1388,-1389,-1390,-1391,-1392,-1393,-1394,-1395,-1396,-1397,-1398,-1399,-1400,-1401,-1402,-1403,-1404,-1405,-1406,-1407,-1408,-1409,-1410,-1411,-1412,-1413,-1414,-1415,-1416,-1417,-1418,-1419,-1420,-1421,-1422,-1423,-1424,-1425,-1426,-1427,-1428,-1429,-1430,-1431,-1432,-1433,-1434,-1435,-1436,-1437,-1438,-1439,-1440,-1441,-1442,-1443,-1444,-1445,-1446,-1447,-1448,-1449,-1450,-1451,-1452,-1453,-1454,-1455,-1456,-1457,-1458,-1459,-1460,-1461,-1462,-1463,-1464,-1465,-1466,-1467,-1468,-1469,-1470,-1471,-1472,-1473,-1474,-1475,-1476,-1477,-1478,-1479,-1480,-1481,-1482,-1483,-1484,-1485,-1486,-1487,-1488,-1489,-1490,-1491,-1492,-1493,-1494,-1495,-1496,-1497,-1498,-1499,-1500,-1501,-1502,-1503,-1504,-1505,-1506,-1507,-1508,-1509,-1510,-1511,-1512,-1513,-1514,-1515,-1516,-1517,-1518,-1519,-1520,-1521,-1522,-1523,-1524,-1525,-1526,-1527,-1528,-1529,-1530,-1531,-1532,-1533,-1534,-1535,-1536,-1537,-1538,-1539,-1540,-1541,-1542,-1543,-1544,-1545,-1546,-1547,-1548,-1549,-1550,-1551,-1552,-1553,-1554,-1555,-1556,-1557,-1558,-1559,-1560,-1561,-1562,-1563,-1564,-1565,-1566,-1567,-1568,-1569,-1570,-1571,-1572,-1573,-1574,-1575,-1576,-1577,-1578,-1579,-1580,-1581,-1582,-1583,-1584,-1585,-1586,-1587,-1588,-1589,-1590,-1591,-1592,-1593,-1594,-1595,-1596,-1597,-1598,-1599,-1600,-1601,-1602,-1603,-1604,-1605,-1606,-1607,-1608,-1609,-1610,-1611,-1612,-1613,-1614,-1615,-1616,-1617,-1618,-1619,-1620,-1621,-1622,-1623,-1624,-1625,-1626,-1627,-1628,-1629,-1630,-1631,-1632,-1633,-1634,-1635,-1636,-1637,-1638,-1639,-1640,-1641,-1642,-1643,-1644,-1645,-1646,-1647,-1648,-1649,-1650,-1651,-1652,-1653,-1654,-1655,-1656,-1657,-1658,-1659,-1660,-1661,-1662,-1663,-1664,-1665,-1666,-1667,-1668,-1669,-1670,-1671,-1672,-1673,-1674,-1675,-1676,-1677,-1678,-1679,-1680,-1681,-1682,-1683,-1684,-1685,-1686,-1687,-1688,-1689,-1690,-1691,-1692,-1693,-1694,-1695,-1696,-1697,-1698,-1699,-1700,-1701,-1702,-1703,-1704,-1705,-1706,-1707,-1708,-1709,-1710,-1711,-1712,-1713,-1714,-1715,-1716,-1717,-1718,-1719,-1720,-1721,-1722,-1723,-1724,-1725,-1726,-1727,-1728,-1729,-1730,-1731,-1732,-1733,-1734,-1735,-1736,-1737,-1738,-1739,-1740,-1741,-1742,-1743,-1744,-1745,-1746,-1747,-1748,-1749,-1750,-1751,-1752,-1753,-1754,-1755,-1756,-1757,-1758,-1759,-1760,-1761,-1762,-1763,-1764,-1765,-1766,-1767,-1768,-1769,-1770,-1771,-1772,-1773,-1774,-1775,-1776,-1777,-1778,-1779,-1780,-1781,-1782,-1783,-1784,-1785,-1786,-1787,-1788,-1789,-1790,-1791,-1792,-1793,-1794,-1795,-1796,-1797,-1798,-1799,-1800,-1801,-1802,-1803,-1804,-1805,-1806,-1807,-1808,-1809,-1810,-1811,-1812,-1813,-1814,-1815,-1816,-1817,-1818,-1819,-1820,-1821,-1822,-1823,-1824,-1825,-1826,-1827,-1828,-1829,-1830,-1831,-1832,-1833,-1834,-1835,-1836,-1837,-1838,-1839,-1840,-1841,-1842,-1843,-1844,-1845,-1846,-1847,-1848,-1849,-1850,-1851,-1852,-1853]],[199,[200,0.5208,[2,1,1,1,0.520833125],[2,1,1,1,1],[2,1,1,1,0.5208],[2,1,1,1,1]],[201,0.000001,[4,4289967027]],[202,1218],[203],[204],[205,[206]]]],[132,"GameBox","1bWH3bHPFAPKXmwpWwITV7",36,[-1858,12,4],[[113,-1857]]],[133,"timeLab",33554432,[[12,-1859,[5,104.11,85.9]],[176,"20s",60,60,65,true,-1860,[4,4284148210]],[163,33,19.374000000000002,32.821999999999996,-1861],[207,-1862,[0,0,-2]]],[1,8.570999999999998,4.2280000000000015,0]],[37,"select",512,33554432,[20,-1865],[[12,-1863,[5,125,125]],[35,-1864]]],[37,"select",512,33554432,[22,-1868],[[12,-1866,[5,125,125]],[35,-1867]]],[31,"Shizi",4,[-1869,-1870,-1871,-1872]],[1,["a5UTxqfPFVeKGDWf0qisDT"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[1,["7d3EgS01FZQJSKcQt6rjmm"]],[48,0,null,[3,"d2TjgTD/1aGbQ0jo2pMXya",null,null,-1877,[81,"10yANUOLBLzZYyJ17SeiqS",null,[[83,[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[-1876]]],[[84,[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[[27,-1875,[1,0.5,1,11]]]]],[[2,"jiansudai1",["_name"],31],[0,["_lpos"],31,[1,6.638,0,0.041]],[0,["_lrot"],31,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],31,[1,0,90,0]],[0,["_lscale"],31,[1,3,2,0.9]],[6,["_lpos"],[1,["abGJHp8AlZS7UyGki127PX"]],[1,0,0.037,0]],[2,3,["_materials","length"],-1873],[14,["_materials","2"],-1874,53],[2,true,["_active"],31]]],45]],[21,"faguang",49,[-1878,-1879,-1880],[1,0.014,0,0.264]],[21,"faguang",32,[-1881,-1882,-1883],[1,0.014,0,0.264]],[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[21,"faguang",33,[-1884,-1885,-1886],[1,0.014,0,0.264]],[1,["d2TjgTD/1aGbQ0jo2pMXya"]],[1,["45T788omlTTIwj2OQV2VyN"]],[1,["45T788omlTTIwj2OQV2VyN"]],[1,["45T788omlTTIwj2OQV2VyN"]],[1,["45T788omlTTIwj2OQV2VyN"]],[1,["45T788omlTTIwj2OQV2VyN"]],[1,["45T788omlTTIwj2OQV2VyN"]],[1,["d5/ZT1sa5dxJJMAbjBKoSi"]],[1,["ee3VwsghVbmpo/rDOcTyf2"]],[1,["d5/ZT1sa5dxJJMAbjBKoSi"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["0dfQdkurNS9JUPbR94EdRO"]],[1,["39crQLrAJQPIwc4nRRIYEY"]],[1,["36uM83vtxVcJDIalQ1Trkb"]],[1,["39crQLrAJQPIwc4nRRIYEY"]],[1,["36uM83vtxVcJDIalQ1Trkb"]],[1,["36uM83vtxVcJDIalQ1Trkb"]],[149,"OtherCarPool",4,[[49,"startPos",-1888],[134,"endPos",-1889,[1,0,0,-109.611]],[49,"Box",-1890]],[[208,0.5,0,-1887,122]],[1,-54.092,0,-10.837]],[103,"OtherCarPool",4,[[-1892,-1893,[49,"Box",-1894]],1,1,4],[[114,0.5,0,2,-1891,127]],[1,-90.709,0,-128.664],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[103,"OtherCarPool",4,[[-1896,-1897,[49,"Box",-1898]],1,1,4],[[114,0.5,1.5,3,-1895,132]],[1,-90.709,0,-222.062],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["88VDQVisBbw5m9OxjU+gSN"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["d3BBkeGjhYuoyllyVyuiuL"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["190htkDPdRkobYqiVDMX6F"]],[1,["788ZDs7GpZlr15qKTxEgyo"]],[1,["10Fxz3ZC1UyoGQ64o70mPH"]],[97,"label",512,33554432,[[12,-1899,[5,280,80]],[45,"btn.again",-1900],[79,"再试一遍",38,38,2,false,true,-1901,[4,4292600295]],[115,-1902,[4,4279117206]]],[1,0,0.663,0]],[97,"label",512,33554432,[[12,-1903,[5,280,50]],[45,"btn.down",-1904],[79,"下载",38,38,2,false,true,-1905,[4,4293655039]],[115,-1906,[4,4284297491]]],[1,0,1.396,0]],[1,["18DHm6XMpAsr6zhFX96aQO"]],[37,"Mask",512,33554432,[-1910],[[12,-1907,[5,1920,1080]],[196,true,-1908],[209,-1909,[4,16777215]]]],[69,"btn1",512,33554432,9,[-1913,-1914],[[12,-1911,[5,222,233]],[24,-1912,1201]]],[50,"btn2",512,33554432,9,[-1917,-1918],[[12,-1915,[5,227,222]],[24,-1916,1210]],[1,0,-6.339,0]],[135,"red",512,false,33554432,9,[-1922],[[12,-1919,[5,720,1280]],[164,45,-5.684341886080802e-14,5.684341886080802e-14,100,100,-1920,14],[35,-1921]],[1,0,444.0319999999999,0]],[136,"speed",512,33554432,9,[-1925],[[12,-1923,[5,131,53]],[24,-1924,1217]],[1,-4.964999999999975,-121.69500000000005,0],[1,1.5,1.5,1]],[67,"warn",33554432,10,[-1928],[[12,-1926,[5,147,147]],[210,-1927]]],[70,"pic",33554432,536,[[12,-1929,[5,295,260]],[24,-1930,6],[186,0,-1931]],[1,0.5,0.5,0.5]],[51,"topBox",33554432,10,[11],[[12,-1932,[5,720,100]],[165,41,51.96400000000011,100,-1933]],[1,0,538.0359999999998,0]],[51,"time",33554432,11,[38],[[12,-1934,[5,160,160]],[24,-1935,8]],[1,-350.375,0,0]],[50,"lukou1",512,33554432,11,[39],[[12,-1936,[5,125,124]],[24,-1937,12]],[1,-97.163,0,0]],[38,"gou",512,33554432,39,[[12,-1938,[5,132,107]],[24,-1939,11],[35,-1940]]],[50,"lukou2",512,33554432,11,[-1943],[[12,-1941,[5,125,124]],[24,-1942,16]],[1,67.019,0,0]],[69,"select",512,33554432,542,[21,-1945],[[12,-1944,[5,125,125]]]],[38,"gou",512,33554432,543,[[12,-1946,[5,132,107]],[24,-1947,15],[35,-1948]]],[50,"lukou3",512,33554432,11,[40],[[12,-1949,[5,125,124]],[24,-1950,20]],[1,231.716,0,0]],[38,"gou",512,33554432,40,[[12,-1951,[5,132,107]],[24,-1952,19],[35,-1953]]],[1,["547xjzCiBSa7qi9b0ynZ5u"]],[1,["fe1TYXds1XQYoAXpmZ8bJD"]],[1,["547xjzCiBSa7qi9b0ynZ5u"]],[1,["fe1TYXds1XQYoAXpmZ8bJD"]],[1,["547xjzCiBSa7qi9b0ynZ5u"]],[1,["fe1TYXds1XQYoAXpmZ8bJD"]],[1,["547xjzCiBSa7qi9b0ynZ5u"]],[1,["fe1TYXds1XQYoAXpmZ8bJD"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[1,["b5yYMxVw1fXbr5OrH20quh"]],[31,"jiandudai",4,[49,32,33]],[1,["25t+eFONhfwLX4IVz16+in"]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[1,["c3Z2IusppTcZ0APAQQguLO"]],[39,"Road1",4,[[23,"Cube<ModelComponent>",false,-1954,[1130],[9],1131],[27,-1955,[1,1,1,10]]],[1,-64.984,0.5,-61.332]],[39,"Road2",4,[[23,"Cube<ModelComponent>",false,-1956,[1132],[9],1133],[27,-1957,[1,10,1,1]]],[1,-142.623,0.5,-143.739]],[39,"Road3",4,[[23,"Cube<ModelComponent>",false,-1958,[1134],[9],1135],[27,-1959,[1,10,1,1]]],[1,-142.623,0.5,-238.774]],[30,"Guide",8388608,13,[[23,"Cube<ModelComponent>",false,-1960,[1151],[9],1152],[46,-1961],[192,2,-1962]],[1,6.726,0.2,24.489],[1,0.2,0.2,0.2]],[98,"bg",33554432,17,[[12,-1963,[5,720,1280]],[42,0,-1964,[4,2952790016],1164],[33,45,100,100,-1965]]],[30,"tip",33554432,18,[[104,-1966,[5,1010,523],[0,0.5,1]],[24,-1967,1165],[166,1,-1968]],[1,0,640,0],[1,0.55,0.55,1]],[30,"fail",33554432,18,[[12,-1969,[5,644,341]],[34,2,-1970,1167],[56,-1971,[[19,"de",1168],[19,"en",1169],[19,"fr",1170],[19,"jp",1171],[19,"kr",1172],[57,1173],[19,"zh_tw",1174]]]],[1,0,-64.24,0],[1,0.55,0.55,1]],[51,"btn",33554432,18,[-1973,528],[[12,-1972,[5,596,193]]],[1,0,-295.965,0]],[98,"bg",33554432,19,[[12,-1974,[5,720,1280]],[42,0,-1975,[4,2952790016],1176],[33,45,100,100,-1976]]],[30,"win",33554432,34,[[12,-1977,[5,638,336]],[34,2,-1978,1179],[56,-1979,[[19,"de",1180],[19,"en",1181],[19,"fr",1182],[19,"jp",1183],[19,"kr",1184],[57,1185],[19,"zh_tw",1186]]]],[1,0,-60.629,0],[1,0.55,0.55,1]],[51,"btn",33554432,34,[-1981,529],[[12,-1980,[5,596,193]]],[1,0,-295.965,0]],[1,["0aKJJe5j1IUIjSgiG0iudR"]],[1,["e4ql7v3U1EJadts7uIFnSr"]],[69,"bg",512,33554432,14,[531],[[12,-1982,[5,1920,1080]],[34,0,-1983,1190]]],[99,"stop",512,false,33554432,532,[[12,-1984,[5,150,100]],[45,"btn.stop",-1985],[177,"减速",40,50,2,false,true,-1986,[4,4293655039]]],[1,0,23.925,0]],[30,"pic",33554432,532,[[12,-1987,[5,158,95]],[24,-1988,1193],[56,-1989,[[19,"de",1194],[19,"en",1195],[19,"fr",1196],[19,"jp",1197],[19,"kr",1198],[57,1199],[19,"zh_tw",1200]]]],[1,0,26,0],[1,0.85,0.85,1]],[99,"stop",512,false,33554432,533,[[12,-1990,[5,120,80]],[45,"btn.stop",-1991],[79,"减速",30,30,2,false,true,-1992,[4,4293655039]]],[1,0,23.655,0]],[30,"pic",33554432,533,[[12,-1993,[5,158,95]],[24,-1994,1202],[56,-1995,[[19,"de",1203],[19,"en",1204],[19,"fr",1205],[19,"jp",1206],[19,"kr",1207],[57,1208],[19,"zh_tw",1209]]]],[1,0,10,0],[1,0.65,0.65,1]],[68,"pic",512,33554432,534,[[12,-1996,[5,399,1280]],[34,0,-1997,1212],[167,13,-158.77100000000007,1080,-1998]],[1,-319.2710000000001,0,0]],[147,"Main Camera",12,[[-1999,[211,-2000]],1,4],[1,0,18.385388225369443,27.468959269659766],[3,-0.29893253520065705,0,0,0.9542742474773738],[1,-34.787,0,0]],[212,500,1822425087,961],[214,40,12,13,[942,943,944,23]],[148,"speedLab",512,33554432,535,[[[12,-2001,[5,100.06,37.8]],-2002],4,1],[1,0,1.561,0]],[100,"bar",33554432,11,[[104,-2003,[5,675,33],[0,0,0.5]],[171,1,0,1,-2004,[4,4278255493],7]],[1,-338.699,0,0]],[38,"SpriteSplash",512,33554432,20,[[44,-2005],[42,0,-2006,[4,1895825408],9]]],[38,"SpriteSplash",512,33554432,21,[[44,-2007],[42,0,-2008,[4,1895825408],13]]],[38,"SpriteSplash",512,33554432,22,[[44,-2009],[42,0,-2010,[4,1895825408],17]]],[137,"lihua",false,33554432,11,[[44,-2011],[215,1,442.5,2,1,40,25,17,22,20,-1330,85,-1184,390,150,7,-58,false,true,885,-2012,[0,350,30],[0,0,-340],[4,4294967295],[4,4294967295],[4,4294967295],21]],[1,-21.282500000000027,4.778750000000173,0],[1,1.25,1.25,1]],[52,"shizilukou-001",41,[-2013,-2014],[1,-54.127,-0.15,-61.826],[1,0.115,0.115,0.115]],[4,0,null,970,[3,"6fOOGLjVRaoLsvft6rhFYH",null,null,-2015,[5,"2fhnRCCAZOLpwsZAaB2vxg",null,[[2,"十字路口_Box007",["_name"],547],[0,["_lpos"],547,[1,0,0,0]],[0,["_lrot"],547,[3,0,0,0,1]],[0,["_euler"],547,[1,0,0,0]]]],23]],[4,0,null,970,[3,"d7IH3ppWxXaI0zjnWyO1Q8",null,null,-2016,[5,"eemFB6wVpB2qFPp4+HgOa8",null,[[2,"十字路口_Plane004",["_name"],548],[0,["_lpos"],548,[1,0,0,0]],[0,["_lrot"],548,[3,0,0,0,1]],[0,["_euler"],548,[1,0,0,0]],[6,["_lpos"],[1,["d7IH3ppWxXaI0zjnWyO1Q8"]],[1,0,0.5,0]]]],24]],[52,"shizilukou-002",41,[-2017,-2018],[1,-142.582,-0.15,-61.826],[1,0.115,0.115,0.115]],[4,0,null,973,[3,"6fOOGLjVRaoLsvft6rhFYH",null,null,-2019,[5,"c5Zx+oYEpHtZcyc3A6+pzh",null,[[2,"十字路口_Box007",["_name"],549],[0,["_lpos"],549,[1,0,0,0]],[0,["_lrot"],549,[3,0,0,0,1]],[0,["_euler"],549,[1,0,0,0]]]],25]],[4,0,null,973,[3,"d7IH3ppWxXaI0zjnWyO1Q8",null,null,-2020,[5,"9d8ger9n9PA4x5v/fEWWwi",null,[[2,"十字路口_Plane004",["_name"],550],[0,["_lpos"],550,[1,0,0,0]],[0,["_lrot"],550,[3,0,0,0,1]],[0,["_euler"],550,[1,0,0,0]],[6,["_lpos"],[1,["d7IH3ppWxXaI0zjnWyO1Q8"]],[1,0,0.5,0]]]],26]],[52,"shizilukou-003",41,[-2021,-2022],[1,-142.582,-0.15,-128.413],[1,0.115,0.115,0.115]],[4,0,null,976,[3,"6fOOGLjVRaoLsvft6rhFYH",null,null,-2023,[5,"c3ANowGpJJiIa+hTiEumGx",null,[[2,"十字路口_Box007",["_name"],551],[0,["_lpos"],551,[1,0,0,0]],[0,["_lrot"],551,[3,0,0,0,1]],[0,["_euler"],551,[1,0,0,0]]]],27]],[4,0,null,976,[3,"d7IH3ppWxXaI0zjnWyO1Q8",null,null,-2024,[5,"4fI4ZovAdP+6KVR/7E3RpM",null,[[2,"十字路口_Plane004",["_name"],552],[0,["_lpos"],552,[1,0,0,0]],[0,["_lrot"],552,[3,0,0,0,1]],[0,["_euler"],552,[1,0,0,0]],[6,["_lpos"],[1,["d7IH3ppWxXaI0zjnWyO1Q8"]],[1,0,0.5,0]]]],28]],[52,"shizilukou-004",41,[-2025,-2026],[1,-142.582,-0.15,-222.775],[1,0.115,0.115,0.115]],[4,0,null,979,[3,"6fOOGLjVRaoLsvft6rhFYH",null,null,-2027,[5,"f8mTVNKjRPabB1YFKA12F/",null,[[2,"十字路口_Box007",["_name"],553],[0,["_lpos"],553,[1,0,0,0]],[0,["_lrot"],553,[3,0,0,0,1]],[0,["_euler"],553,[1,0,0,0]]]],29]],[4,0,null,979,[3,"d7IH3ppWxXaI0zjnWyO1Q8",null,null,-2028,[5,"5fALrNvPhG26MRsq+GmpwA",null,[[2,"十字路口_Plane004",["_name"],554],[0,["_lpos"],554,[1,0,0,0]],[0,["_lrot"],554,[3,0,0,0,1]],[0,["_euler"],554,[1,0,0,0]],[6,["_lpos"],[1,["d7IH3ppWxXaI0zjnWyO1Q8"]],[1,0,0.5,0]]]],30]],[4,0,null,7,[3,"77ob6KtepTu7ENQ7YIoqka",null,null,-2031,[5,"dfkR+OF/pJkomK9h2EKxC6",null,[[2,"弯道",["_name"],42],[0,["_lpos"],42,[1,6.375,0.536,-49.283]],[0,["_lrot"],42,[3,0,0,0,1]],[0,["_euler"],42,[1,0,0,0]],[0,["_lscale"],42,[1,27,27,27]],[0,["_lscale"],-2029,[1,27.5,27.5,27.5]],[6,["_lpos"],[1,["3f36pflnBR3YOEefkdGv1h"]],[1,0,0,0]],[0,["_lpos"],-2030,[1,-11.213,0.622,-57.079]]]],31]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2032,[5,"4cTEWCfoxJILD5ERUO2AZZ",null,[[2,"road",["_name"],24],[0,["_lpos"],24,[1,6.73,0,53.018]],[0,["_lrot"],24,[3,0,0,0,1]],[0,["_euler"],24,[1,0,0,0]],[0,["_lscale"],24,[1,27.5,1,300]],[2,true,["_active"],24]]],32]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2033,[5,"f3g2uxkcVP/YSXJ6h6wCbE",null,[[2,"Merge_356763E2",["_name"],555],[0,["_lpos"],555,[1,0,0,0]],[0,["_lrot"],555,[3,0,0,0,1]],[0,["_euler"],555,[1,0,0,0]],[0,["_lscale"],25,[1,1,1,5]],[0,["_lpos"],25,[1,-98.532,0,-61.745]],[2,"road-004",["_name"],25],[0,["_lrot"],25,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],25,[1,0,89.99999999999999,0]],[2,true,["_active"],25]]],33]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2034,[5,"99g7cHT6JCQbOsgUtXZwIB",null,[[2,"Merge_356763E2",["_name"],556],[0,["_lpos"],556,[1,0,0,0]],[0,["_lrot"],556,[3,0,0,0,1]],[0,["_euler"],556,[1,0,0,0]],[0,["_lscale"],26,[1,1,1,30]],[0,["_lpos"],26,[1,-330.62,0,-61.745]],[2,"road-005",["_name"],26],[0,["_lrot"],26,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],26,[1,0,89.99999999999999,0]],[2,true,["_active"],26]]],34]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2035,[5,"d52/8CHqdIbqJSa3Dii/NO",null,[[2,"Merge_356763E2",["_name"],557],[0,["_lpos"],557,[1,0,0,0]],[0,["_lrot"],557,[3,0,0,0,1]],[0,["_euler"],557,[1,0,0,0]],[0,["_lscale"],43,[1,1,1,7]],[0,["_lpos"],43,[1,-54.092,0,-4.841]],[2,"road-006",["_name"],43],[0,["_lrot"],43,[3,0,0,0,1]],[0,["_euler"],43,[1,0,0,0]]]],35]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2036,[5,"88jUHG6ttKoIF67lT3fxGf",null,[[2,"Merge_356763E2",["_name"],558],[0,["_lpos"],558,[1,0,0,0]],[0,["_lrot"],558,[3,0,0,0,1]],[0,["_euler"],558,[1,0,0,0]],[0,["_lscale"],44,[1,1,1,7]],[0,["_lpos"],44,[1,-142.623,0,-4.841]],[2,"road-007",["_name"],44],[0,["_lrot"],44,[3,0,0,0,1]],[0,["_euler"],44,[1,0,0,0]]]],36]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2037,[5,"532l97dAFPSqqo8aVaIkcR",null,[[2,"Merge_356763E2",["_name"],559],[0,["_lpos"],559,[1,0,0,0]],[0,["_lrot"],559,[3,0,0,0,1]],[0,["_euler"],559,[1,0,0,0]],[0,["_lscale"],45,[1,1,1,7]],[0,["_lpos"],45,[1,-54.092,0,-117.793]],[2,"road-008",["_name"],45],[0,["_lrot"],45,[3,0,0,0,1]],[0,["_euler"],45,[1,0,0,0]]]],37]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2038,[5,"3bAy/9wbRISoKGyv+AKvyC",null,[[2,"Merge_356763E2",["_name"],560],[0,["_lpos"],560,[1,0,0,0]],[0,["_lrot"],560,[3,0,0,0,1]],[0,["_euler"],560,[1,0,0,0]],[0,["_lscale"],46,[1,1,1,3]],[0,["_lpos"],46,[1,-142.623,0,-95.423]],[2,"road-009",["_name"],46],[0,["_lrot"],46,[3,0,0,0,1]],[0,["_euler"],46,[1,0,0,0]]]],38]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2039,[5,"a56ymLF6dNSKt0sFebHc8r",null,[[2,"Merge_356763E2",["_name"],561],[0,["_lpos"],561,[1,0,0,0]],[0,["_lrot"],561,[3,0,0,0,1]],[0,["_euler"],561,[1,0,0,0]],[0,["_lscale"],27,[1,1,1,4]],[0,["_lpos"],27,[1,-102.622,0,-128.664]],[2,"road-010",["_name"],27],[0,["_lrot"],27,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],27,[1,0,89.99999999999999,0]],[2,true,["_active"],27]]],39]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2040,[5,"17m4OXydZGnpVmH9U0TsaU",null,[[2,"Merge_356763E2",["_name"],562],[0,["_lpos"],562,[1,0,0,0]],[0,["_lrot"],562,[3,0,0,0,1]],[0,["_euler"],562,[1,0,0,0]],[0,["_lscale"],28,[1,1,1,10]],[0,["_lpos"],28,[1,-219.388,0,-128.664]],[2,"road-011",["_name"],28],[0,["_lrot"],28,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],28,[1,0,89.99999999999999,0]],[2,true,["_active"],28]]],40]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2041,[5,"45QPcG40FIDK34FoaAtBhq",null,[[2,"Merge_356763E2",["_name"],563],[0,["_lpos"],563,[1,0,0,0]],[0,["_lrot"],563,[3,0,0,0,1]],[0,["_euler"],563,[1,0,0,0]],[0,["_lscale"],29,[1,1,1,10]],[0,["_lpos"],29,[1,-219.388,0,-222.919]],[2,"road-012",["_name"],29],[0,["_lrot"],29,[3,0,0.7071067811865475,0,0.7071067811865477]],[0,["_euler"],29,[1,0,89.99999999999999,0]],[2,true,["_active"],29]]],41]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2042,[5,"9cT0VNmRFEcbUYsphRP4PV",null,[[2,"Merge_356763E2",["_name"],564],[0,["_lpos"],564,[1,0,0,0]],[0,["_lrot"],564,[3,0,0,0,1]],[0,["_euler"],564,[1,0,0,0]],[0,["_lscale"],30,[1,1,1,4]],[0,["_lpos"],30,[1,-112.853,0,-222.919]],[2,"road-013",["_name"],30],[0,["_lrot"],30,[3,0,0.7071067811865475,0,0.7071067811865477]],[0,["_euler"],30,[1,0,89.99999999999999,0]],[2,true,["_active"],30],[6,["_lpos"],[1,["7eFneUAwtbjbQdKhS9AAGB"]],[1,0,0,0]]]],42]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2043,[5,"ff8Jzt5TxKipUOkDRGv0nq",null,[[2,"Merge_356763E2",["_name"],565],[0,["_lpos"],565,[1,0,0,0]],[0,["_lrot"],565,[3,0,0,0,1]],[0,["_euler"],565,[1,0,0,0]],[0,["_lscale"],47,[1,1,1,5.1]],[0,["_lpos"],47,[1,-142.623,0,-175.191]],[2,"road-014",["_name"],47],[0,["_lrot"],47,[3,0,0,0,1]],[0,["_euler"],47,[1,0,0,0]]]],43]],[4,0,null,7,[3,"7d3EgS01FZQJSKcQt6rjmm",null,null,-2044,[5,"69omuZdf9BmpPtHn+fOatu",null,[[2,"Merge_356763E2",["_name"],566],[0,["_lpos"],566,[1,0,0,0]],[0,["_lrot"],566,[3,0,0,0,1]],[0,["_euler"],566,[1,0,0,0]],[0,["_lscale"],48,[1,1,1,3]],[0,["_lpos"],48,[1,-142.623,0,-257.388]],[2,"road-015",["_name"],48],[0,["_lrot"],48,[3,0,0,0,1]],[0,["_euler"],48,[1,0,0,0]]]],44]],[71,"warn",50,[-2046],[[85,-2045]],[1,0,3.381,0],[3,-1.2054250692888608e-16,0.7071067811865475,-1.205425069288861e-16,0.7071067811865476],[1,0,90,-1.9534749440140288e-14]],[71,"warn",51,[-2048],[[85,-2047]],[1,0,3.381,0],[3,1.2054250692888608e-16,-0.7071067811865475,-1.205425069288861e-16,0.7071067811865476],[1,0,-90,-1.9534749440140288e-14]],[71,"warn",53,[-2050],[[85,-2049]],[1,0,3.381,0],[3,-1.2054250692888608e-16,0.7071067811865475,-1.205425069288861e-16,0.7071067811865476],[1,0,90,-1.9534749440140288e-14]],[4,0,null,4,[3,"c94BwCxEhVOp4wiRMeeyXy",null,null,-2054,[5,"c7yEnmon9PF7RwQVBNKuqY",null,[[2,"斑马线",["_name"],568],[0,["_lpos"],568,[1,0,0,0]],[0,["_lrot"],568,[3,0,0,0,1]],[0,["_euler"],568,[1,0,0,0]],[0,["_lscale"],-2051,[1,0.11,0.11,0.11]],[0,["_lpos"],-2052,[1,6.524,0,-5.624]],[2,true,["_active"],-2053]]],70]],[1,["c94BwCxEhVOp4wiRMeeyXy"]],[21,"plan1",15,[-2055,-2056],[1,36.618,0,0.578]],[4,0,null,1001,[3,"45T788omlTTIwj2OQV2VyN",null,null,-2057,[5,"6b8HJwIEZP84oJHNORM5SS",null,[[2,"workshop1",["_name"],55],[0,["_lpos"],55,[1,-16.614,0,-5.166]],[0,["_lrot"],55,[3,0,-0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],55,[1,0,-89.99999999999999,0]],[0,["_lscale"],55,[1,2,2,2]]]],73]],[21,"plan2",15,[-2058,-2059],[1,-87.19,0,-87.43]],[4,0,null,1003,[3,"45T788omlTTIwj2OQV2VyN",null,null,-2060,[5,"faFYDtoOFF7IxbGWIW1+Zs",null,[[2,"workshop1",["_name"],56],[0,["_lpos"],56,[1,-2.648,0,12.14]],[0,["_lrot"],56,[3,0,0,0,1]],[0,["_euler"],56,[1,0,0,0]],[0,["_lscale"],56,[1,2,2,2]]]],76]],[21,"plan3",15,[-2061,-2062],[1,-107.831,0,-32.705]],[4,0,null,1005,[3,"45T788omlTTIwj2OQV2VyN",null,null,-2063,[5,"1egk+hm7hLDpMb94xD2nqc",null,[[2,"workshop1",["_name"],57],[0,["_lpos"],57,[1,2.734,0,-14.756]],[0,["_lrot"],57,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],57,[1,0,180,0]],[0,["_lscale"],57,[1,2,2,2]]]],79]],[21,"plan4",15,[-2064,-2065],[1,-171.027,0,-94.686]],[4,0,null,1007,[3,"45T788omlTTIwj2OQV2VyN",null,null,-2066,[5,"beQTi/xN5EPJQPNKifIqlh",null,[[2,"workshop1",["_name"],58],[0,["_lpos"],58,[1,15.855,0,1.747]],[0,["_lrot"],58,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],58,[1,0,90,0]],[0,["_lscale"],58,[1,2,2,2]]]],82]],[21,"plan5",15,[-2067,-2068],[1,-171.027,0,-189.222]],[4,0,null,1009,[3,"45T788omlTTIwj2OQV2VyN",null,null,-2069,[5,"8f//7EwFlGPLGDgwEnO9QU",null,[[2,"workshop1",["_name"],59],[0,["_lpos"],59,[1,14.001,0,1.074]],[0,["_lrot"],59,[3,0,0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],59,[1,0,90,0]],[0,["_lscale"],59,[1,2,2,2]]]],85]],[21,"plan6",15,[-2070,-2071],[1,-112.807,0,-156.337]],[4,0,null,1011,[3,"45T788omlTTIwj2OQV2VyN",null,null,-2072,[5,"cdi+6Et2tA65fb/37pwnPj",null,[[2,"workshop1",["_name"],60],[0,["_lpos"],60,[1,-16.501,0,-1.824]],[0,["_lrot"],60,[3,0,-0.7071067811865475,0,0.7071067811865476]],[0,["_euler"],60,[1,0,-90,0]],[0,["_lscale"],60,[1,2,2,2]]]],88]],[4,0,null,6,[3,"d5/ZT1sa5dxJJMAbjBKoSi",null,null,-2073,[5,"6bl921EZpFb78DbCCG+ztl",null,[[2,"shuita",["_name"],61],[0,["_lpos"],61,[1,-9.697,0,2.702]],[0,["_lrot"],61,[3,0,0,0,1]],[0,["_euler"],61,[1,0,0,0]],[0,["_lscale"],61,[1,0.5,0.5,0.5]]]],91]],[4,0,null,6,[3,"ee3VwsghVbmpo/rDOcTyf2",null,null,-2074,[5,"362qBUUZNDH7FnZwghrM5y",null,[[2,"workshop4",["_name"],62],[0,["_lpos"],62,[1,0.307,0,-3.891]],[0,["_lrot"],62,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],62,[1,0,180,0]],[0,["_lscale"],62,[1,0.5,0.5,0.5]],[14,["_materials","25"],8,93],[14,["_materials","23"],8,94],[14,["_materials","22"],8,95],[14,["_materials","21"],8,96],[14,["_materials","20"],8,97],[14,["_materials","19"],8,98],[14,["_materials","18"],8,99],[14,["_materials","17"],8,100],[14,["_materials","16"],8,101],[14,["_materials","15"],8,102],[14,["_materials","14"],8,103],[14,["_materials","12"],8,104],[14,["_materials","13"],8,105],[14,["_materials","11"],8,106]]],92]],[4,0,null,6,[3,"d5/ZT1sa5dxJJMAbjBKoSi",null,null,-2075,[5,"9aaC0XR0NA2q8jJxe4+B/7",null,[[2,"shuita-001",["_name"],63],[0,["_lpos"],63,[1,-9.697,0,6.383]],[0,["_lrot"],63,[3,0,0,0,1]],[0,["_euler"],63,[1,0,0,0]],[0,["_lscale"],63,[1,0.5,0.5,0.5]]]],107]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2076,[5,"46FfO0pKpND5AgaMufP0/p",null,[[2,"youtong",["_name"],64],[0,["_lpos"],64,[1,-14.654,0.772,11.395]],[0,["_lrot"],64,[3,0,0,0,1]],[0,["_euler"],64,[1,0,0,0]],[0,["_lscale"],64,[1,0.5,0.5,0.5]]]],108]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2077,[5,"advzCxWIBO9qODj9FCINtO",null,[[2,"youtong-001",["_name"],65],[0,["_lpos"],65,[1,-14.054,0.772,10.601]],[0,["_lrot"],65,[3,0,0,0,1]],[0,["_euler"],65,[1,0,0,0]],[0,["_lscale"],65,[1,0.5,0.5,0.5]]]],109]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2078,[5,"b4FyrANedE8LtNsIZyiPQa",null,[[2,"youtong-002",["_name"],66],[0,["_lpos"],66,[1,-15.554,0.772,10.947]],[0,["_lrot"],66,[3,0,0,0,1]],[0,["_euler"],66,[1,0,0,0]],[0,["_lscale"],66,[1,0.5,0.5,0.5]]]],110]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2079,[5,"83XHyw88tPWoouKXLoSzgY",null,[[2,"youtong-003",["_name"],67],[0,["_lpos"],67,[1,7.585,0.772,10.919]],[0,["_lrot"],67,[3,0,0,0,1]],[0,["_euler"],67,[1,0,0,0]],[0,["_lscale"],67,[1,0.5,0.5,0.5]]]],111]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2080,[5,"7757FmG1JHx4ttIrOAxKT1",null,[[2,"youtong-004",["_name"],68],[0,["_lpos"],68,[1,6.8,0.772,11.784]],[0,["_lrot"],68,[3,0,0,0,1]],[0,["_euler"],68,[1,0,0,0]],[0,["_lscale"],68,[1,0.5,0.5,0.5]]]],112]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2081,[5,"b5LvhJdt5NyJa8aWDH6sbu",null,[[2,"youtong-005",["_name"],69],[0,["_lpos"],69,[1,6.469,0.772,10.669]],[0,["_lrot"],69,[3,0,0,0,1]],[0,["_euler"],69,[1,0,0,0]],[0,["_lscale"],69,[1,0.5,0.5,0.5]]]],113]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2082,[5,"9aaDoTzS9CHLlLkF7d70Vz",null,[[2,"youtong-006",["_name"],70],[0,["_lpos"],70,[1,7.83,0.772,6.824]],[0,["_lrot"],70,[3,0,0,0,1]],[0,["_euler"],70,[1,0,0,0]],[0,["_lscale"],70,[1,0.5,0.5,0.5]]]],114]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2083,[5,"0bweDdzfVIBbaUsO1EIB8B",null,[[2,"youtong-007",["_name"],71],[0,["_lpos"],71,[1,7.038,2.28,11.095]],[0,["_lrot"],71,[3,0,0,0,1]],[0,["_euler"],71,[1,0,0,0]],[0,["_lscale"],71,[1,0.5,0.5,0.5]]]],115]],[4,0,null,6,[3,"0dfQdkurNS9JUPbR94EdRO",null,null,-2084,[5,"6eXPGclAdKmIRwCd9Ai5yx",null,[[2,"youtong-008",["_name"],72],[0,["_lpos"],72,[1,-2.716,0.409,4.942]],[0,["_lrot"],72,[3,0.6532814824381882,0.2705980500730985,-0.27059805007309845,0.6532814824381883]],[0,["_euler"],72,[1,90,45,0]],[0,["_lscale"],72,[1,0.5,0.5,0.5]]]],116]],[4,0,null,6,[3,"39crQLrAJQPIwc4nRRIYEY",null,null,-2085,[5,"8eQOYxNpNOsItAMVNTWmwK",null,[[2,"guandao",["_name"],73],[0,["_lpos"],73,[1,-0.499,1.669,0.045]],[0,["_lrot"],73,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],73,[1,0,180,0]],[0,["_lscale"],73,[1,0.5,0.5,0.5]],[6,["_lpos"],[1,["ac9hqt031a1qSggcx3LNql"]],[1,0,0,0]]]],117]],[4,0,null,6,[3,"36uM83vtxVcJDIalQ1Trkb",null,null,-2089,[5,"50ZBkd9XlC3r31hFEKA0gX",null,[[2,"huowu",["_name"],74],[0,["_lpos"],74,[1,-30.938,0,3.704]],[0,["_lrot"],74,[3,0,0,0,1]],[0,["_euler"],74,[1,0,0,0]],[0,["_lpos"],-2086,[1,0,0,0]],[0,["_lscale"],74,[1,0.5,0.5,0.5]],[0,["_lrot"],-2087,[3,-0.6638955953851252,-0.24339810687067803,-0.24339810687067798,0.6638955953851253]],[0,["_euler"],-2088,[1,-90,-40.268,0]]]],118]],[1,["67UW1gZwlfnIIHS8Oc+slH"]],[4,0,null,6,[3,"39crQLrAJQPIwc4nRRIYEY",null,null,-2093,[5,"e0b138CbVBOaNiKC6xaiFa",null,[[2,"guandao-001",["_name"],75],[0,["_lpos"],75,[1,-0.499,1.669,-4.295]],[0,["_lrot"],75,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],75,[1,0,180,0]],[0,["_lscale"],75,[1,0.5,0.5,0.5]],[0,["_lpos"],-2090,[1,0,0,0]],[0,["_lrot"],-2091,[3,-0.7071068705935069,0,0,0.7071066917795769]],[0,["_euler"],-2092,[1,-90.00001448901888,0,0]]]],119]],[1,["ac9hqt031a1qSggcx3LNql"]],[4,0,null,6,[3,"36uM83vtxVcJDIalQ1Trkb",null,null,-2097,[5,"90VFqEeWFPx5Sn0hCw0IWP",null,[[2,"huowu-001",["_name"],76],[0,["_lpos"],76,[1,-27.054,0,18.562]],[0,["_lrot"],76,[3,0,0,0,1]],[0,["_euler"],76,[1,0,0,0]],[0,["_lpos"],-2094,[1,12.332,0,11.288]],[0,["_lscale"],76,[1,0.5,0.5,0.5]],[0,["_lrot"],-2095,[3,-0.6830127594658838,0.18301268646540111,0.18301271731903618,0.6830126443185501]],[0,["_euler"],-2096,[1,-90.00000965934633,30,0]]]],120]],[1,["67UW1gZwlfnIIHS8Oc+slH"]],[4,0,null,6,[3,"36uM83vtxVcJDIalQ1Trkb",null,null,-2101,[5,"3dgOtWoUlH5KSe3/KybpLJ",null,[[2,"huowu-002",["_name"],77],[0,["_lpos"],77,[1,-22.481,0,18.378]],[0,["_lrot"],77,[3,0,0,0,1]],[0,["_euler"],77,[1,0,0,0]],[0,["_lpos"],-2098,[1,13.582,0,12.894]],[0,["_lscale"],77,[1,0.5,0.5,0.5]],[0,["_lrot"],-2099,[3,-0.6830127594658838,0.18301268646540111,0.18301271731903618,0.6830126443185501]],[0,["_euler"],-2100,[1,-90.00000965934633,30,0]]]],121]],[1,["67UW1gZwlfnIIHS8Oc+slH"]],[21,"lampBox",5,[-2102,-2103],[1,6.443,0,-13.957]],[4,0,null,1034,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2106,[5,"10x2A7yYdJYbsP0Vm5h+mA",null,[[2,"lamp",["_name"],81],[0,["_lpos"],81,[1,6.844,0,0]],[0,["_lrot"],81,[3,0,0,0,1]],[0,["_euler"],81,[1,0,0,0]],[0,["_lscale"],81,[1,1,1,1]],[14,["_mesh"],-2104,134],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[14,["_materials","0"],-2105,135]]],133]],[4,0,null,1034,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2109,[5,"82cwbmkypLIomiXPl6NfK8",null,[[2,"lamp-001",["_name"],82],[0,["_lpos"],82,[1,-6.816,0,0]],[0,["_lrot"],82,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],82,[1,0,180,0]],[0,["_lscale"],82,[1,1,1,1]],[14,["_mesh"],-2107,137],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[14,["_materials","0"],-2108,138]]],136]],[28,"lampBox-001",5,[-2110,-2111],[1,2.595,0,-35.481],[3,0,0.25881904510252074,0,0.9659258262890683],[1,0,30,0]],[4,0,null,1037,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2112,[5,"27R7h3jEtPFpNz9/pyLkV/",null,[[2,"lamp",["_name"],83],[0,["_lpos"],83,[1,6.844,0,0]],[0,["_lrot"],83,[3,0,0,0,1]],[0,["_euler"],83,[1,0,0,0]],[0,["_lscale"],83,[1,1,1,1]],[14,["_mesh"],569,140],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[2,1,["_materials","length"],569],[14,["_materials","1"],569,141],[14,["_materials","0"],569,142]]],139]],[4,0,null,1037,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2115,[5,"bdI8/EXPNPCoeCr0bUc2S1",null,[[2,"lamp-001",["_name"],84],[0,["_lpos"],84,[1,-6.816,0,0]],[0,["_lrot"],84,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],84,[1,0,180,0]],[0,["_lscale"],84,[1,1,1,1]],[14,["_mesh"],-2113,144],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[14,["_materials","0"],-2114,145]]],143]],[28,"lampBox-002",5,[-2116,-2117],[1,-7.035,0,-49.9],[3,0,0.49999999999999994,0,0.8660254037844387],[1,0,60,0]],[4,0,null,1040,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2120,[5,"75pQ/xeMhNDrcf+CiZRcTI",null,[[2,"lamp",["_name"],85],[0,["_lpos"],85,[1,6.844,0,0]],[0,["_lrot"],85,[3,0,0,0,1]],[0,["_euler"],85,[1,0,0,0]],[0,["_lscale"],85,[1,1,1,1]],[14,["_mesh"],-2118,147],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[14,["_materials","0"],-2119,148]]],146]],[4,0,null,1040,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2123,[5,"78z8MsO/5PT7kKnje43KsF",null,[[2,"lamp-001",["_name"],86],[0,["_lpos"],86,[1,-6.816,0,0]],[0,["_lrot"],86,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],86,[1,0,180,0]],[0,["_lscale"],86,[1,1,1,1]],[14,["_mesh"],-2121,150],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[14,["_materials","0"],-2122,151]]],149]],[28,"lampBox-003",5,[-2124,-2125],[1,-25.341,0,-59.506],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1043,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2128,[5,"d03Pv+B2tAiIKIZCHcO5NP",null,[[2,"lamp",["_name"],87],[0,["_lpos"],87,[1,6.844,0,0]],[0,["_lrot"],87,[3,0,0,0,1]],[0,["_euler"],87,[1,0,0,0]],[0,["_lscale"],87,[1,1,1,1]],[14,["_mesh"],-2126,153],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[14,["_materials","0"],-2127,154]]],152]],[4,0,null,1043,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2129,[5,"ad367dmRJLOZrDQ5kBKxoz",null,[[2,"lamp-001",["_name"],88],[0,["_lpos"],88,[1,-6.816,0,0]],[0,["_lrot"],88,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],88,[1,0,180,0]],[0,["_lscale"],88,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],156],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],155]],[28,"lampBox-004",5,[-2130,-2131],[1,-47.119,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1046,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2132,[5,"446hkAN/ZIT7TvNK2FQiXo",null,[[2,"lamp",["_name"],89],[0,["_lpos"],89,[1,6.844,0,0]],[0,["_lrot"],89,[3,0,0,0,1]],[0,["_euler"],89,[1,0,0,0]],[0,["_lscale"],89,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],158],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],157]],[4,0,null,1046,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2133,[5,"acoU9MU0dHhY7sVrzXQ/Bp",null,[[2,"lamp-001",["_name"],90],[0,["_lpos"],90,[1,-6.816,0,0]],[0,["_lrot"],90,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],90,[1,0,180,0]],[0,["_lscale"],90,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],160],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],159]],[28,"lampBox-005",5,[-2134,-2135],[1,-62.154,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1049,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2136,[5,"26/9FlhK9EsZPeR1pM2k+w",null,[[2,"lamp",["_name"],91],[0,["_lpos"],91,[1,6.844,0,0]],[0,["_lrot"],91,[3,0,0,0,1]],[0,["_euler"],91,[1,0,0,0]],[0,["_lscale"],91,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],162],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],161]],[4,0,null,1049,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2137,[5,"53+HnWg2FAZqb16nno1dd+",null,[[2,"lamp-001",["_name"],92],[0,["_lpos"],92,[1,-6.816,0,0]],[0,["_lrot"],92,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],92,[1,0,180,0]],[0,["_lscale"],92,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],164],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],163]],[28,"lampBox-006",5,[-2138,-2139],[1,-81.719,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1052,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2140,[5,"9aW6907ipJi5rfNf7bY3XZ",null,[[2,"lamp",["_name"],93],[0,["_lpos"],93,[1,6.844,0,0]],[0,["_lrot"],93,[3,0,0,0,1]],[0,["_euler"],93,[1,0,0,0]],[0,["_lscale"],93,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],166],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],165]],[4,0,null,1052,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2141,[5,"d0i8jCCQFH/a10TBP3el+5",null,[[2,"lamp-001",["_name"],94],[0,["_lpos"],94,[1,-6.816,0,0]],[0,["_lrot"],94,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],94,[1,0,180,0]],[0,["_lscale"],94,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],168],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],167]],[28,"lampBox-007",5,[-2142,-2143],[1,-97.53,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1055,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2144,[5,"e4Ph99ii5DU6oY2i80ALbL",null,[[2,"lamp",["_name"],95],[0,["_lpos"],95,[1,6.844,0,0]],[0,["_lrot"],95,[3,0,0,0,1]],[0,["_euler"],95,[1,0,0,0]],[0,["_lscale"],95,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],170],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],169]],[4,0,null,1055,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2145,[5,"93RhgRgKdPG68OChqxDqF5",null,[[2,"lamp-001",["_name"],96],[0,["_lpos"],96,[1,-6.816,0,0]],[0,["_lrot"],96,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],96,[1,0,180,0]],[0,["_lscale"],96,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],172],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],171]],[28,"lampBox-008",5,[-2146,-2147],[1,-110.936,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1058,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2148,[5,"e7+fwuwbBFSYxsN3ldGMIy",null,[[2,"lamp",["_name"],97],[0,["_lpos"],97,[1,6.844,0,0]],[0,["_lrot"],97,[3,0,0,0,1]],[0,["_euler"],97,[1,0,0,0]],[0,["_lscale"],97,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],174],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],173]],[4,0,null,1058,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2149,[5,"73INjMQylJ+YvfwKR5MZcG",null,[[2,"lamp-001",["_name"],98],[0,["_lpos"],98,[1,-6.816,0,0]],[0,["_lrot"],98,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],98,[1,0,180,0]],[0,["_lscale"],98,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],176],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],175]],[28,"lampBox-009",5,[-2150,-2151],[1,-121.751,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1061,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2152,[5,"b7I2KGSUBC4ozKSpGC3S5e",null,[[2,"lamp",["_name"],99],[0,["_lpos"],99,[1,6.844,0,0]],[0,["_lrot"],99,[3,0,0,0,1]],[0,["_euler"],99,[1,0,0,0]],[0,["_lscale"],99,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],178],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],177]],[4,0,null,1061,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2153,[5,"82VWCQNgRO77kfuusrFN7C",null,[[2,"lamp-001",["_name"],100],[0,["_lpos"],100,[1,-6.816,0,0]],[0,["_lrot"],100,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],100,[1,0,180,0]],[0,["_lscale"],100,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],180],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],179]],[28,"lampBox-010",5,[-2154,-2155],[1,-135.231,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1064,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2156,[5,"b6sdWVBAlIGYyw0uny6W0a",null,[[2,"lamp",["_name"],101],[0,["_lpos"],101,[1,6.844,0,0]],[0,["_lrot"],101,[3,0,0,0,1]],[0,["_euler"],101,[1,0,0,0]],[0,["_lscale"],101,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],182],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],181]],[4,0,null,1064,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2157,[5,"1bAXmr2npIDZ2S3zjvChSr",null,[[2,"lamp-001",["_name"],102],[0,["_lpos"],102,[1,-6.816,0,0]],[0,["_lrot"],102,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],102,[1,0,180,0]],[0,["_lscale"],102,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],184],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],183]],[28,"lampBox-011",5,[-2158,-2159],[1,-150.865,0,-61.745],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[4,0,null,1067,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2160,[5,"de8R0/FSJGuJUBH2tI+Zsg",null,[[2,"lamp",["_name"],103],[0,["_lpos"],103,[1,6.844,0,0]],[0,["_lrot"],103,[3,0,0,0,1]],[0,["_euler"],103,[1,0,0,0]],[0,["_lscale"],103,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],186],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],185]],[4,0,null,1067,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2161,[5,"c3WFy4ZNtCa7i5IhM1KvkA",null,[[2,"lamp-001",["_name"],104],[0,["_lpos"],104,[1,-6.816,0,0]],[0,["_lrot"],104,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],104,[1,0,180,0]],[0,["_lscale"],104,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],188],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],187]],[21,"lampBox-012",5,[-2162,-2163],[1,-142.623,0,-79.452]],[4,0,null,1070,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2164,[5,"a941A+sCZI+IMCiGYRJ5cW",null,[[2,"lamp",["_name"],105],[0,["_lpos"],105,[1,6.844,0,0]],[0,["_lrot"],105,[3,0,0,0,1]],[0,["_euler"],105,[1,0,0,0]],[0,["_lscale"],105,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],190],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],189]],[4,0,null,1070,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2165,[5,"d3ppjXZ+ZLqbm73uwQDR6H",null,[[2,"lamp-001",["_name"],106],[0,["_lpos"],106,[1,-6.816,0,0]],[0,["_lrot"],106,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],106,[1,0,180,0]],[0,["_lscale"],106,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],192],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],191]],[21,"lampBox-013",5,[-2166,-2167],[1,-142.623,0,-99.063]],[4,0,null,1073,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2168,[5,"e7Sof3KWRCMbYMc+qaBl+j",null,[[2,"lamp",["_name"],107],[0,["_lpos"],107,[1,6.844,0,0]],[0,["_lrot"],107,[3,0,0,0,1]],[0,["_euler"],107,[1,0,0,0]],[0,["_lscale"],107,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],194],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],193]],[4,0,null,1073,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2169,[5,"b5kYs1ErtNRJN2d3EGtSt6",null,[[2,"lamp-001",["_name"],108],[0,["_lpos"],108,[1,-6.816,0,0]],[0,["_lrot"],108,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],108,[1,0,180,0]],[0,["_lscale"],108,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],196],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],195]],[21,"lampBox-014",5,[-2170,-2171],[1,-142.623,0,-120.675]],[4,0,null,1076,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2172,[5,"81qGeO/D9EZ5tOYfQjJLB2",null,[[2,"lamp",["_name"],109],[0,["_lpos"],109,[1,6.844,0,0]],[0,["_lrot"],109,[3,0,0,0,1]],[0,["_euler"],109,[1,0,0,0]],[0,["_lscale"],109,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],198],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],197]],[4,0,null,1076,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2173,[5,"b1mQ9aCgtDlZVCF3SWhsjI",null,[[2,"lamp-001",["_name"],110],[0,["_lpos"],110,[1,-6.816,0,0]],[0,["_lrot"],110,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],110,[1,0,180,0]],[0,["_lscale"],110,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],200],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],199]],[21,"lampBox-015",5,[-2174,-2175],[1,-142.623,0,-137.174]],[4,0,null,1079,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2176,[5,"72tosDgqVCtbZ0LzPsZGKV",null,[[2,"lamp",["_name"],111],[0,["_lpos"],111,[1,6.844,0,0]],[0,["_lrot"],111,[3,0,0,0,1]],[0,["_euler"],111,[1,0,0,0]],[0,["_lscale"],111,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],202],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],201]],[4,0,null,1079,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2177,[5,"eblHnakodLqK6yO5F2Lps0",null,[[2,"lamp-001",["_name"],112],[0,["_lpos"],112,[1,-6.816,0,0]],[0,["_lrot"],112,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],112,[1,0,180,0]],[0,["_lscale"],112,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],204],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],203]],[21,"lampBox-016",5,[-2178,-2179],[1,-142.623,0,-152.24]],[4,0,null,1082,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2180,[5,"84q2LtDAZLG5YYMCne3HQV",null,[[2,"lamp",["_name"],113],[0,["_lpos"],113,[1,6.844,0,0]],[0,["_lrot"],113,[3,0,0,0,1]],[0,["_euler"],113,[1,0,0,0]],[0,["_lscale"],113,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],206],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],205]],[4,0,null,1082,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2181,[5,"555uh+n1xMy5kWsF53R3qc",null,[[2,"lamp-001",["_name"],114],[0,["_lpos"],114,[1,-6.816,0,0]],[0,["_lrot"],114,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],114,[1,0,180,0]],[0,["_lscale"],114,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],208],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],207]],[21,"lampBox-017",5,[-2182,-2183],[1,-142.623,0,-169.555]],[4,0,null,1085,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2184,[5,"6fnSuQyB1HK42SYcHRXkqq",null,[[2,"lamp",["_name"],115],[0,["_lpos"],115,[1,6.844,0,0]],[0,["_lrot"],115,[3,0,0,0,1]],[0,["_euler"],115,[1,0,0,0]],[0,["_lscale"],115,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],210],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],209]],[4,0,null,1085,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2187,[5,"80i2/X0FhNnI4zzSb62Y+b",null,[[2,"lamp-001",["_name"],116],[0,["_lpos"],116,[1,-6.816,0,0]],[0,["_lrot"],116,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],116,[1,0,180,0]],[0,["_lscale"],116,[1,1,1,1]],[14,["_mesh"],-2185,212],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]],[14,["_materials","0"],-2186,213]]],211]],[21,"lampBox-018",5,[-2188,-2189],[1,-142.623,0,-192.771]],[4,0,null,1088,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2190,[5,"b2vfHDE3ZBXoDjM9Cz58XI",null,[[2,"lamp",["_name"],117],[0,["_lpos"],117,[1,6.844,0,0]],[0,["_lrot"],117,[3,0,0,0,1]],[0,["_euler"],117,[1,0,0,0]],[0,["_lscale"],117,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],215],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],214]],[4,0,null,1088,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2191,[5,"aakkskN79M/Lz+BMG2TWAE",null,[[2,"lamp-001",["_name"],118],[0,["_lpos"],118,[1,-6.816,0,0]],[0,["_lrot"],118,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],118,[1,0,180,0]],[0,["_lscale"],118,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],217],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],216]],[21,"lampBox-019",5,[-2192,-2193],[1,-142.623,0,-207.526]],[4,0,null,1091,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2194,[5,"deAqFuY3NP8KfMJ4Bkua7s",null,[[2,"lamp",["_name"],119],[0,["_lpos"],119,[1,6.844,0,0]],[0,["_lrot"],119,[3,0,0,0,1]],[0,["_euler"],119,[1,0,0,0]],[0,["_lscale"],119,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],219],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],218]],[4,0,null,1091,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2195,[5,"25DRGEGIBGOYy5TDNlb27Z",null,[[2,"lamp-001",["_name"],120],[0,["_lpos"],120,[1,-6.816,0,0]],[0,["_lrot"],120,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],120,[1,0,180,0]],[0,["_lscale"],120,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],221],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],220]],[21,"lampBox-020",5,[-2196,-2197],[1,-142.623,0,-225.354]],[4,0,null,1094,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2198,[5,"64/2VDFLFHqrIG6rDtF0Dc",null,[[2,"lamp",["_name"],121],[0,["_lpos"],121,[1,6.844,0,0]],[0,["_lrot"],121,[3,0,0,0,1]],[0,["_euler"],121,[1,0,0,0]],[0,["_lscale"],121,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],223],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],222]],[4,0,null,1094,[3,"88VDQVisBbw5m9OxjU+gSN",null,null,-2199,[5,"d6+w7b4axDp5a8b/CZUrBx",null,[[2,"lamp-001",["_name"],122],[0,["_lpos"],122,[1,-6.816,0,0]],[0,["_lrot"],122,[3,0,1,0,6.123233995736766e-17]],[0,["_euler"],122,[1,0,180,0]],[0,["_lscale"],122,[1,1,1,1]],[7,["_mesh"],[1,["abR9WWofVfW77+dYb0ZRQt"]],225],[6,["_lscale"],[1,["33fTAOch9WmJPJI1jQqnBQ"]],[1,1,1,1]]]],224]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2200,[5,"5e8+fhzSNG25aNdEo6T4+G",null,[[2,"tree2",["_name"],123],[0,["_lpos"],123,[1,21.586,0,24.796]],[0,["_lrot"],123,[3,0,0,0,1]],[0,["_euler"],123,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],123,[1,0.25,0.25,0.25]]]],226]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2201,[5,"1c2bW44kpGFJ88yNSV3lCm",null,[[2,"tree3",["_name"],124],[0,["_lpos"],124,[1,26.55,0,19.908]],[0,["_lrot"],124,[3,0,0,0,1]],[0,["_euler"],124,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],124,[1,0.5,0.5,0.5]]]],227]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2202,[5,"75Vr+DuPhCJLaTUVPyMh35",null,[[2,"tree4",["_name"],125],[0,["_lpos"],125,[1,20.83,0,32.189]],[0,["_lrot"],125,[3,0,0,0,1]],[0,["_euler"],125,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],125,[1,0.5,0.5,0.5]]]],228]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2203,[5,"8cWvwhzFtP4ogiZL6IWZe8",null,[[2,"tree5",["_name"],126],[0,["_lpos"],126,[1,-13.99,0,20.808]],[0,["_lrot"],126,[3,0,0,0,1]],[0,["_euler"],126,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],126,[1,0.2,0.2,0.2]]]],229]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2204,[5,"57D9nQPudLDp79KAdrwyP3",null,[[2,"tree6",["_name"],127],[0,["_lpos"],127,[1,-25.662,0,27.203]],[0,["_lrot"],127,[3,0,0,0,1]],[0,["_euler"],127,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],127,[1,0.5,0.5,0.5]]]],230]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2205,[5,"bbOCVK1rROGKPhP2nfYWW+",null,[[2,"tree7",["_name"],128],[0,["_lpos"],128,[1,-23.451,0,9.785]],[0,["_lrot"],128,[3,0,0,0,1]],[0,["_euler"],128,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],128,[1,0.5,0.5,0.5]]]],231]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2206,[5,"e7Uud/y51KpoAs9mYsoeYL",null,[[2,"tree8",["_name"],129],[0,["_lpos"],129,[1,-18.477,0,-9.85]],[0,["_lrot"],129,[3,0,0,0,1]],[0,["_euler"],129,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],129,[1,0.5,0.5,0.5]]]],232]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2207,[5,"96EE7TyxRO2ptu4dzXpFz3",null,[[2,"tree9",["_name"],130],[0,["_lpos"],130,[1,-23.294,0,38.831]],[0,["_lrot"],130,[3,0,0,0,1]],[0,["_euler"],130,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],130,[1,1,1,1]]]],233]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2208,[5,"323NZTpMlPnLAknHnCX/aF",null,[[2,"tree10",["_name"],131],[0,["_lpos"],131,[1,-19.534,0,-39.156]],[0,["_lrot"],131,[3,0,0,0,1]],[0,["_euler"],131,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],131,[1,1,1,1]]]],234]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2209,[5,"f8D/HAmK1HI7XWKQRjmNhR",null,[[2,"tree11",["_name"],132],[0,["_lpos"],132,[1,-33.694,0,-41.333]],[0,["_lrot"],132,[3,0,0,0,1]],[0,["_euler"],132,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],132,[1,0.5,0.5,0.5]]]],235]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2210,[5,"91Ao0YR/dJ1Jae72Omr8Ce",null,[[2,"tree12",["_name"],133],[0,["_lpos"],133,[1,-41.209,0,-35.331]],[0,["_lrot"],133,[3,0,0,0,1]],[0,["_euler"],133,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],133,[1,0.5,0.5,0.5]]]],236]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2211,[5,"146aZo4hRCBbtCQGAzKwMh",null,[[2,"tree13",["_name"],134],[0,["_lpos"],134,[1,-41.209,0,-9.62]],[0,["_lrot"],134,[3,0,0,0,1]],[0,["_euler"],134,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],134,[1,0.5,0.5,0.5]]]],237]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2212,[5,"11K+VRk4lDnqlWviGDtGgn",null,[[2,"tree14",["_name"],135],[0,["_lpos"],135,[1,18.703,0,-21.925]],[0,["_lrot"],135,[3,0,0,0,1]],[0,["_euler"],135,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],135,[1,0.5,0.5,0.5]]]],238]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2213,[5,"99ba2M2kxPFbKciSl9pcDK",null,[[2,"tree15",["_name"],136],[0,["_lpos"],136,[1,16.243,0,-40.712]],[0,["_lrot"],136,[3,0,0,0,1]],[0,["_euler"],136,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],136,[1,0.5,0.5,0.5]]]],239]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2214,[5,"3aX2tm5phAQp+aAwr//3AL",null,[[2,"tree16",["_name"],137],[0,["_lpos"],137,[1,2.365,0,-61.08]],[0,["_lrot"],137,[3,0,0,0,1]],[0,["_euler"],137,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],137,[1,0.5,0.5,0.5]]]],240]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2215,[5,"0eI96LdJBNcZbZWhxuMVoW",null,[[2,"tree17",["_name"],138],[0,["_lpos"],138,[1,43.636,0,-42.112]],[0,["_lrot"],138,[3,0,0,0,1]],[0,["_euler"],138,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],138,[1,0.5,0.5,0.5]]]],241]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2216,[5,"5eoxO0qvNPw5gZa8D0Q/Eq",null,[[2,"tree18",["_name"],139],[0,["_lpos"],139,[1,53.057,0,-24.208]],[0,["_lrot"],139,[3,0,0,0,1]],[0,["_euler"],139,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],139,[1,1,1,1]]]],242]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2217,[5,"2aHGCYUVVHq4kHNr9ZFT3q",null,[[2,"tree19",["_name"],140],[0,["_lpos"],140,[1,53.057,0,-56.751]],[0,["_lrot"],140,[3,0,0,0,1]],[0,["_euler"],140,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],140,[1,1,1,1]]]],243]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2218,[5,"154eGMdvhPpaQU1yJsAEFu",null,[[2,"tree20",["_name"],141],[0,["_lpos"],141,[1,42.909,0,-84.157]],[0,["_lrot"],141,[3,0,0,0,1]],[0,["_euler"],141,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],141,[1,1,1,1]]]],244]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2219,[5,"da6Mwet8pAHK1/9PAMAzWN",null,[[2,"tree21",["_name"],142],[0,["_lpos"],142,[1,42.909,0,-51.274]],[0,["_lrot"],142,[3,0,0,0,1]],[0,["_euler"],142,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],142,[1,1,1,1]]]],245]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2220,[5,"f8usenZwlAR4SLwrZ6+6dn",null,[[2,"tree22",["_name"],143],[0,["_lpos"],143,[1,-5.379,0,-71.545]],[0,["_lrot"],143,[3,0,0,0,1]],[0,["_euler"],143,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],143,[1,1,1,1]]]],246]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2221,[5,"c10QMBB3FEVZZevLldlRYi",null,[[2,"tree23",["_name"],144],[0,["_lpos"],144,[1,-15.172,0,-96.991]],[0,["_lrot"],144,[3,0,0,0,1]],[0,["_euler"],144,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],144,[1,1,1,1]]]],247]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2222,[5,"1aNVGdd4xMcIg05b00pbEa",null,[[2,"tree24",["_name"],145],[0,["_lpos"],145,[1,-34.347,0,-75.842]],[0,["_lrot"],145,[3,0,0,0,1]],[0,["_euler"],145,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],145,[1,1,1,1]]]],248]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2223,[5,"6e8ebmrHxGZZyTHWihf3Dh",null,[[2,"tree25",["_name"],146],[0,["_lpos"],146,[1,-27.51,0,-74.275]],[0,["_lrot"],146,[3,0,0,0,1]],[0,["_euler"],146,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],146,[1,0.4,0.4,0.4]]]],249]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2224,[5,"f1V/7Tp7tPkKMwgkdQryLt",null,[[2,"tree26",["_name"],147],[0,["_lpos"],147,[1,-37.92,0,-92.197]],[0,["_lrot"],147,[3,0,0,0,1]],[0,["_euler"],147,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],147,[1,0.4,0.4,0.4]]]],250]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2225,[5,"d7JDIzJ4pI6Kk2rGbQipb3",null,[[2,"tree27",["_name"],148],[0,["_lpos"],148,[1,-30.552,0,-87.89]],[0,["_lrot"],148,[3,0,0,0,1]],[0,["_euler"],148,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],148,[1,0.4,0.4,0.4]]]],251]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2226,[5,"f720Nah8VDgK11uavggiBg",null,[[2,"tree28",["_name"],149],[0,["_lpos"],149,[1,-26.824,0,-92.032]],[0,["_lrot"],149,[3,0,0,0,1]],[0,["_euler"],149,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],149,[1,0.4,0.4,0.4]]]],252]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2227,[5,"15mwjfgB5KWo8QqM+q1gKJ",null,[[2,"tree29",["_name"],150],[0,["_lpos"],150,[1,-36.584,0,-107.954]],[0,["_lrot"],150,[3,0,0,0,1]],[0,["_euler"],150,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],150,[1,0.4,0.4,0.4]]]],253]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2228,[5,"c3ZAqdStxLrYBnqdRLopvq",null,[[2,"tree30",["_name"],151],[0,["_lpos"],151,[1,-28.676,0,-111.646]],[0,["_lrot"],151,[3,0,0,0,1]],[0,["_euler"],151,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],151,[1,1,1,1]]]],254]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2229,[5,"ee/TojzElDN7fdkPzAI7Su",null,[[2,"tree31",["_name"],152],[0,["_lpos"],152,[1,-6.666,0,-111.646]],[0,["_lrot"],152,[3,0,0,0,1]],[0,["_euler"],152,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],152,[1,1,1,1]]]],255]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2230,[5,"0d1v1gLHNPwb9xB1WhXkLZ",null,[[2,"tree32",["_name"],153],[0,["_lpos"],153,[1,-21.453,0,-141.676]],[0,["_lrot"],153,[3,0,0,0,1]],[0,["_euler"],153,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],153,[1,1,1,1]]]],256]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2231,[5,"06AS4kmkNPV5s/CTGUz+Eb",null,[[2,"tree33",["_name"],154],[0,["_lpos"],154,[1,-20.336,0,-125.12]],[0,["_lrot"],154,[3,0,0,0,1]],[0,["_euler"],154,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],154,[1,1,1,1]]]],257]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2232,[5,"3arzmxDj9OtrPyOs+ATG6z",null,[[2,"tree34",["_name"],155],[0,["_lpos"],155,[1,-9.219,0,-146.709]],[0,["_lrot"],155,[3,0,0,0,1]],[0,["_euler"],155,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],155,[1,1,1,1]]]],258]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2233,[5,"a4yDajNbhPh4qVOP1S6snO",null,[[2,"tree35",["_name"],156],[0,["_lpos"],156,[1,-40.757,0,-141.676]],[0,["_lrot"],156,[3,0,0,0,1]],[0,["_euler"],156,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],156,[1,1,1,1]]]],259]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2234,[5,"c5FmbHrMlLkJusPxdosWAZ",null,[[2,"tree36",["_name"],157],[0,["_lpos"],157,[1,0.528,0,-132.161]],[0,["_lrot"],157,[3,0,0,0,1]],[0,["_euler"],157,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],157,[1,1,1,1]]]],260]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2235,[5,"1b+chlJtNK3ImiAgtregKH",null,[[2,"tree37",["_name"],158],[0,["_lpos"],158,[1,6.408,0,-94.315]],[0,["_lrot"],158,[3,0,0,0,1]],[0,["_euler"],158,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],158,[1,1,1,1]]]],261]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2236,[5,"00UWgDg0hLU6d5iGqswGVR",null,[[2,"tree38",["_name"],159],[0,["_lpos"],159,[1,-32.544,0,14.218]],[0,["_lrot"],159,[3,0,0,0,1]],[0,["_euler"],159,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],159,[1,1,1,1]]]],262]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2237,[5,"e8lD+MRf9F0rC4uXsU91eP",null,[[2,"tree39",["_name"],160],[0,["_lpos"],160,[1,-32.544,0,7.185]],[0,["_lrot"],160,[3,0,0,0,1]],[0,["_euler"],160,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],160,[1,1,1,1]]]],263]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2238,[5,"47l53DdBxFR7uEKTbh1nGR",null,[[2,"tree40",["_name"],161],[0,["_lpos"],161,[1,-18.997,0,2.086]],[0,["_lrot"],161,[3,0,0,0,1]],[0,["_euler"],161,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],161,[1,1,1,1]],[7,["_materials","1"],[1,["fdFJiZ+nZSzIMBM+kmWvSk"]],265]]],264]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2239,[5,"bfXR+mVGxCFYkdbGa2UweF",null,[[2,"tree41",["_name"],162],[0,["_lpos"],162,[1,-29.623,0,-9.936]],[0,["_lrot"],162,[3,0,0,0,1]],[0,["_euler"],162,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],162,[1,1,1,1]]]],266]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2240,[5,"9f1tF+J/xCi48D+esNq/+5",null,[[2,"tree42",["_name"],163],[0,["_lpos"],163,[1,-21.594,0,-23.354]],[0,["_lrot"],163,[3,0,0,0,1]],[0,["_euler"],163,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],163,[1,1,1,1]]]],267]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2241,[5,"28QVWk7TFDkJIzaUefeAbn",null,[[2,"tree43",["_name"],164],[0,["_lpos"],164,[1,-71.952,0,-35.872]],[0,["_lrot"],164,[3,0,0,0,1]],[0,["_euler"],164,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],164,[1,0.5,0.5,0.5]]]],268]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2242,[5,"d7PDxaebRBdYX2eaOLuCxU",null,[[2,"tree44",["_name"],165],[0,["_lpos"],165,[1,-84.146,0,-35.948]],[0,["_lrot"],165,[3,0,0,0,1]],[0,["_euler"],165,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],165,[1,0.5,0.5,0.5]]]],269]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2243,[5,"038IQWn0JLcaZF1KDmgwHM",null,[[2,"tree45",["_name"],166],[0,["_lpos"],166,[1,-78.059,0,-24.812]],[0,["_lrot"],166,[3,0,0,0,1]],[0,["_euler"],166,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],166,[1,0.5,0.5,0.5]]]],270]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2244,[5,"73VVw3kr5BW5qKPv01UdxI",null,[[2,"tree46",["_name"],167],[0,["_lpos"],167,[1,-76.283,0,-14.675]],[0,["_lrot"],167,[3,0,0,0,1]],[0,["_euler"],167,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],167,[1,0.5,0.5,0.5]]]],271]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2245,[5,"75xpS8eblI0Yh+FV4QlhHV",null,[[2,"tree47",["_name"],168],[0,["_lpos"],168,[1,-76.283,0,-14.675]],[0,["_lrot"],168,[3,0,0,0,1]],[0,["_euler"],168,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],168,[1,0.5,0.5,0.5]]]],272]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2246,[5,"c9DbAocVJBZYrduId3ndVA",null,[[2,"tree48",["_name"],169],[0,["_lpos"],169,[1,-70.256,0,-25.492]],[0,["_lrot"],169,[3,0,0,0,1]],[0,["_euler"],169,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],169,[1,0.5,0.5,0.5]]]],273]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2247,[5,"a4nO1AXFNCop9ESxvtXXVb",null,[[2,"tree49",["_name"],170],[0,["_lpos"],170,[1,-80.924,0,-42.266]],[0,["_lrot"],170,[3,0,0,0,1]],[0,["_euler"],170,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],170,[1,0.5,0.5,0.5]]]],274]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2248,[5,"f9EohOegZMXYMhNT/OReVC",null,[[2,"tree50",["_name"],171],[0,["_lpos"],171,[1,-68.851,0,-45.623]],[0,["_lrot"],171,[3,0,0,0,1]],[0,["_euler"],171,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],171,[1,0.5,0.5,0.5]]]],275]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2249,[5,"30wQ7SHA5Lwbp88NvdY3Zm",null,[[2,"tree51",["_name"],172],[0,["_lpos"],172,[1,-86.727,0,-25.372]],[0,["_lrot"],172,[3,0,0,0,1]],[0,["_euler"],172,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],172,[1,0.5,0.5,0.5]]]],276]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2250,[5,"68FwRzDxpHx5uY5ubsFBEN",null,[[2,"tree52",["_name"],173],[0,["_lpos"],173,[1,-74.878,0,-21.003]],[0,["_lrot"],173,[3,0,0,0,1]],[0,["_euler"],173,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],173,[1,0.5,0.5,0.5]]]],277]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2251,[5,"bevXGvImFOyY7Xfx9WGodm",null,[[2,"tree53",["_name"],174],[0,["_lpos"],174,[1,-68.636,0,-33.822]],[0,["_lrot"],174,[3,0,0,0,1]],[0,["_euler"],174,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],174,[1,0.5,0.5,0.5]]]],278]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2252,[5,"1civ4d5lNAJZ060ukCI2Ot",null,[[2,"tree54",["_name"],175],[0,["_lpos"],175,[1,-78.582,0,-36.022]],[0,["_lrot"],175,[3,0,0,0,1]],[0,["_euler"],175,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],175,[1,0.5,0.5,0.5]]]],279]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2253,[5,"5cLKLKGLtHvY9qmHusjeSH",null,[[2,"tree55",["_name"],176],[0,["_lpos"],176,[1,-88.758,0,-12.242]],[0,["_lrot"],176,[3,0,0,0,1]],[0,["_euler"],176,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],176,[1,0.5,0.5,0.5]]]],280]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2254,[5,"e1B/IlR4JP6Iemi8PsLToW",null,[[2,"tree56",["_name"],177],[0,["_lpos"],177,[1,-82.608,0,-12.242]],[0,["_lrot"],177,[3,0,0,0,1]],[0,["_euler"],177,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],177,[1,0.5,0.5,0.5]]]],281]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2255,[5,"aaBx7yQtBKLpvsBOErS7tn",null,[[2,"tree57",["_name"],178],[0,["_lpos"],178,[1,-83.604,0,-4.031]],[0,["_lrot"],178,[3,0,0,0,1]],[0,["_euler"],178,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],178,[1,0.5,0.5,0.5]]]],282]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2256,[5,"345Y2QfD1JR4DW+2DdvZtZ",null,[[2,"tree58",["_name"],179],[0,["_lpos"],179,[1,-75.003,0,-8.425]],[0,["_lrot"],179,[3,0,0,0,1]],[0,["_euler"],179,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],179,[1,0.5,0.5,0.5]]]],283]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2257,[5,"7b4lh1AvRJhqHahdrF5H3S",null,[[2,"tree59",["_name"],180],[0,["_lpos"],180,[1,-95.327,0,-11.389]],[0,["_lrot"],180,[3,0,0,0,1]],[0,["_euler"],180,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],180,[1,0.5,0.5,0.5]]]],284]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2258,[5,"58A9cuA2tDp4qGxYlvyLBf",null,[[2,"tree60",["_name"],181],[0,["_lpos"],181,[1,-123.458,0,-17.989]],[0,["_lrot"],181,[3,0,0,0,1]],[0,["_euler"],181,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],181,[1,0.5,0.5,0.5]]]],285]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2259,[5,"34v67SUCJK+6SsAIv+xT3l",null,[[2,"tree61",["_name"],182],[0,["_lpos"],182,[1,-131.233,0,-31.765]],[0,["_lrot"],182,[3,0,0,0,1]],[0,["_euler"],182,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],182,[1,0.5,0.5,0.5]]]],286]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2260,[5,"dbyfITYPFCR6CS4YAzDxlJ",null,[[2,"tree62",["_name"],183],[0,["_lpos"],183,[1,-130.837,0,-46.871]],[0,["_lrot"],183,[3,0,0,0,1]],[0,["_euler"],183,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],183,[1,0.5,0.5,0.5]]]],287]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2261,[5,"0857iLs9xCN5Dc8HDgIs8u",null,[[2,"tree63",["_name"],184],[0,["_lpos"],184,[1,-130.837,0,-46.871]],[0,["_lrot"],184,[3,0,0,0,1]],[0,["_euler"],184,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],184,[1,0.5,0.5,0.5]]]],288]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2262,[5,"a2DxKTnsVM3bhN3ScDRYBU",null,[[2,"tree64",["_name"],185],[0,["_lpos"],185,[1,-75.606,0,3.952]],[0,["_lrot"],185,[3,0,0,0,1]],[0,["_euler"],185,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],185,[1,0.5,0.5,0.5]]]],289]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2263,[5,"8crogiavBKVpMK5UZOuuK7",null,[[2,"tree65",["_name"],186],[0,["_lpos"],186,[1,-69.851,0,-5.954]],[0,["_lrot"],186,[3,0,0,0,1]],[0,["_euler"],186,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],186,[1,0.5,0.5,0.5]]]],290]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2264,[5,"ccFmVPXURCDbLyOb78uSFw",null,[[2,"tree66",["_name"],187],[0,["_lpos"],187,[1,-125.843,0,-5.954]],[0,["_lrot"],187,[3,0,0,0,1]],[0,["_euler"],187,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],187,[1,0.5,0.5,0.5]]]],291]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2265,[5,"f0SO4FXwhDg6vmyqgfYt3Q",null,[[2,"tree67",["_name"],188],[0,["_lpos"],188,[1,-165.151,0,-46.932]],[0,["_lrot"],188,[3,0,0,0,1]],[0,["_euler"],188,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],188,[1,0.5,0.5,0.5]]]],292]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2266,[5,"abIuGyzY9JgYBc+KjfCtMP",null,[[2,"tree68",["_name"],189],[0,["_lpos"],189,[1,-165.151,0,-32.347]],[0,["_lrot"],189,[3,0,0,0,1]],[0,["_euler"],189,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],189,[1,0.5,0.5,0.5]]]],293]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2267,[5,"a6yKhT/GdJeK8o1AY0a7rN",null,[[2,"tree69",["_name"],190],[0,["_lpos"],190,[1,-158.108,0,-47.291]],[0,["_lrot"],190,[3,0,0,0,1]],[0,["_euler"],190,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],190,[1,0.5,0.5,0.5]]]],294]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2268,[5,"e2eOJcPRBBLKvPZVY8T3Y0",null,[[2,"tree70",["_name"],191],[0,["_lpos"],191,[1,-157.617,0,-40.748]],[0,["_lrot"],191,[3,0,0,0,1]],[0,["_euler"],191,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],191,[1,0.5,0.5,0.5]]]],295]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2269,[5,"afHhflNpNBPqFJteHqH/65",null,[[2,"tree71",["_name"],192],[0,["_lpos"],192,[1,-171.874,0,-43.568]],[0,["_lrot"],192,[3,0,0,0,1]],[0,["_euler"],192,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],192,[1,0.5,0.5,0.5]]]],296]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2270,[5,"10Zz35RM5OyIQ/3SV6fQ0e",null,[[2,"tree72",["_name"],193],[0,["_lpos"],193,[1,-157.416,0,-29.269]],[0,["_lrot"],193,[3,0,0,0,1]],[0,["_euler"],193,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],193,[1,0.5,0.5,0.5]]]],297]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2271,[5,"05W9EzSD9AHreX9mVCml1a",null,[[2,"tree73",["_name"],194],[0,["_lpos"],194,[1,-165.807,0,-40.324]],[0,["_lrot"],194,[3,0,0,0,1]],[0,["_euler"],194,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],194,[1,0.5,0.5,0.5]]]],298]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2272,[5,"979YaywRpGooePtqrKZoVD",null,[[2,"tree74",["_name"],195],[0,["_lpos"],195,[1,-158.858,0,-78.679]],[0,["_lrot"],195,[3,0,0,0,1]],[0,["_euler"],195,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],195,[1,0.5,0.5,0.5]]]],299]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2273,[5,"ef6VMp9AJKyoXUL+IaGLJi",null,[[2,"tree75",["_name"],196],[0,["_lpos"],196,[1,-169.953,0,-79.236]],[0,["_lrot"],196,[3,0,0,0,1]],[0,["_euler"],196,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],196,[1,0.5,0.5,0.5]]]],300]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2274,[5,"19SDBEr4ZFIrnZ5yP7Qffw",null,[[2,"tree76",["_name"],197],[0,["_lpos"],197,[1,-163.925,0,-76.166]],[0,["_lrot"],197,[3,0,0,0,1]],[0,["_euler"],197,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],197,[1,0.5,0.5,0.5]]]],301]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2275,[5,"cdREbcp0RHE5Q4ZZL5UFRh",null,[[2,"tree77",["_name"],198],[0,["_lpos"],198,[1,-127.793,0,-80.705]],[0,["_lrot"],198,[3,0,0,0,1]],[0,["_euler"],198,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],198,[1,0.5,0.5,0.5]]]],302]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2276,[5,"ac6Eyiz6NBI7uqGSIfbOwe",null,[[2,"tree78",["_name"],199],[0,["_lpos"],199,[1,-126.744,0,-90.786]],[0,["_lrot"],199,[3,0,0,0,1]],[0,["_euler"],199,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],199,[1,0.5,0.5,0.5]]]],303]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2277,[5,"72NiVknlxF1Lw6DrJkpARM",null,[[2,"tree79",["_name"],200],[0,["_lpos"],200,[1,-122.233,0,-80.607]],[0,["_lrot"],200,[3,0,0,0,1]],[0,["_euler"],200,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],200,[1,0.5,0.5,0.5]]]],304]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2278,[5,"cavLhyPwxD9qTHR59Rfcfk",null,[[2,"tree80",["_name"],201],[0,["_lpos"],201,[1,-122.157,0,-90.137]],[0,["_lrot"],201,[3,0,0,0,1]],[0,["_euler"],201,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],201,[1,0.5,0.5,0.5]]]],305]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2279,[5,"0e6VS/QbFIWrP3i0oH23x/",null,[[2,"tree81",["_name"],202],[0,["_lpos"],202,[1,-119.311,0,-81.611]],[0,["_lrot"],202,[3,0,0,0,1]],[0,["_euler"],202,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],202,[1,0.5,0.5,0.5]]]],306]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2280,[5,"8cI+7YAF1IrqgvSj76Xz8s",null,[[2,"tree82",["_name"],203],[0,["_lpos"],203,[1,-125.612,0,-77.991]],[0,["_lrot"],203,[3,0,0,0,1]],[0,["_euler"],203,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],203,[1,0.5,0.5,0.5]]]],307]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2281,[5,"51kSdr7KVFUqb9fsqnxDbl",null,[[2,"tree83",["_name"],204],[0,["_lpos"],204,[1,-114.918,0,-79.397]],[0,["_lrot"],204,[3,0,0,0,1]],[0,["_euler"],204,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],204,[1,0.5,0.5,0.5]]]],308]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2282,[5,"admHigi9xOgazCtQcQC8A6",null,[[2,"tree84",["_name"],205],[0,["_lpos"],205,[1,-108.36,0,-76.594]],[0,["_lrot"],205,[3,0,0,0,1]],[0,["_euler"],205,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],205,[1,0.5,0.5,0.5]]]],309]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2283,[5,"98u6hAP/lC65X0VK4Qr9Dn",null,[[2,"tree85",["_name"],206],[0,["_lpos"],206,[1,-109.151,0,-86.148]],[0,["_lrot"],206,[3,0,0,0,1]],[0,["_euler"],206,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],206,[1,0.5,0.5,0.5]]]],310]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2284,[5,"8c8NhpnjlEvJEFt28XwWQk",null,[[2,"tree86",["_name"],207],[0,["_lpos"],207,[1,-118.949,0,-92.293]],[0,["_lrot"],207,[3,0,0,0,1]],[0,["_euler"],207,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],207,[1,0.5,0.5,0.5]]]],311]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2285,[5,"9df0Yi/GNDYKiMRvJpaM47",null,[[2,"tree87",["_name"],208],[0,["_lpos"],208,[1,-116.93,0,-103.503]],[0,["_lrot"],208,[3,0,0,0,1]],[0,["_euler"],208,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],208,[1,0.5,0.5,0.5]]]],312]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2286,[5,"27OoLxFYtPVqYcTg+tR1Kz",null,[[2,"tree88",["_name"],209],[0,["_lpos"],209,[1,-110.923,0,-114.763]],[0,["_lrot"],209,[3,0,0,0,1]],[0,["_euler"],209,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],209,[1,0.5,0.5,0.5]]]],313]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2287,[5,"84bURMZExMlIX1+XQAjje3",null,[[2,"tree89",["_name"],210],[0,["_lpos"],210,[1,-106.832,0,-102.427]],[0,["_lrot"],210,[3,0,0,0,1]],[0,["_euler"],210,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],210,[1,0.5,0.5,0.5]]]],314]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2288,[5,"27S2noadRNBYjej4wHkstZ",null,[[2,"tree90",["_name"],211],[0,["_lpos"],211,[1,-92.973,0,-114.428]],[0,["_lrot"],211,[3,0,0,0,1]],[0,["_euler"],211,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],211,[1,0.5,0.5,0.5]]]],315]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2289,[5,"d731PgK9VEJYi2+H4MW73i",null,[[2,"tree91",["_name"],212],[0,["_lpos"],212,[1,-70.495,0,-112.675]],[0,["_lrot"],212,[3,0,0,0,1]],[0,["_euler"],212,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],212,[1,0.5,0.5,0.5]]]],316]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2290,[5,"4dIfRhQQtHOqCW0JUn2bPN",null,[[2,"tree92",["_name"],213],[0,["_lpos"],213,[1,-66.933,0,-80.601]],[0,["_lrot"],213,[3,0,0,0,1]],[0,["_euler"],213,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],213,[1,0.5,0.5,0.5]]]],317]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2291,[5,"3afxCSw8xCqLiKITrY+7Wm",null,[[2,"tree93",["_name"],214],[0,["_lpos"],214,[1,-66.79,0,-90.637]],[0,["_lrot"],214,[3,0,0,0,1]],[0,["_euler"],214,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],214,[1,0.5,0.5,0.5]]]],318]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2292,[5,"c2t8nfdyFOwI8YXkB4bBjh",null,[[2,"tree94",["_name"],215],[0,["_lpos"],215,[1,-67.903,0,-98.519]],[0,["_lrot"],215,[3,0,0,0,1]],[0,["_euler"],215,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],215,[1,0.5,0.5,0.5]]]],319]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2293,[5,"bdMR+px+JFQa6z70bBlpla",null,[[2,"tree95",["_name"],216],[0,["_lpos"],216,[1,-68.919,0,-108.491]],[0,["_lrot"],216,[3,0,0,0,1]],[0,["_euler"],216,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],216,[1,0.5,0.5,0.5]]]],320]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2294,[5,"381iPunCREkYig0950spbb",null,[[2,"tree96",["_name"],217],[0,["_lpos"],217,[1,-159.774,0,-114.695]],[0,["_lrot"],217,[3,0,0,0,1]],[0,["_euler"],217,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],217,[1,0.5,0.5,0.5]]]],321]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2295,[5,"34h+RvAvZB3qW2ho5sl3vx",null,[[2,"tree97",["_name"],218],[0,["_lpos"],218,[1,-181.681,0,-115.965]],[0,["_lrot"],218,[3,0,0,0,1]],[0,["_euler"],218,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],218,[1,0.5,0.5,0.5]]]],322]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2296,[5,"f91oLmPJVHGIvOLTYJuNvB",null,[[2,"tree98",["_name"],219],[0,["_lpos"],219,[1,-168.856,0,-112.711]],[0,["_lrot"],219,[3,0,0,0,1]],[0,["_euler"],219,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],219,[1,0.5,0.5,0.5]]]],323]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2297,[5,"c7xiAQo+9MOZ8EDwDzlPaB",null,[[2,"tree99",["_name"],220],[0,["_lpos"],220,[1,-191.676,0,-101.726]],[0,["_lrot"],220,[3,0,0,0,1]],[0,["_euler"],220,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],220,[1,0.5,0.5,0.5]]]],324]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2298,[5,"0dZEUR8M1LBbq92SFSVQnQ",null,[[2,"tree100",["_name"],221],[0,["_lpos"],221,[1,-190.046,0,-111.619]],[0,["_lrot"],221,[3,0,0,0,1]],[0,["_euler"],221,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],221,[1,0.5,0.5,0.5]]]],325]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2299,[5,"25+Je8eq9JRKQERA+MaRom",null,[[2,"tree101",["_name"],222],[0,["_lpos"],222,[1,-190.342,0,-86.842]],[0,["_lrot"],222,[3,0,0,0,1]],[0,["_euler"],222,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],222,[1,0.5,0.5,0.5]]]],326]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2300,[5,"adTbkJSnBJSJ6/YCB4keLd",null,[[2,"tree102",["_name"],223],[0,["_lpos"],223,[1,-194.301,0,-80.934]],[0,["_lrot"],223,[3,0,0,0,1]],[0,["_euler"],223,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],223,[1,0.5,0.5,0.5]]]],327]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2301,[5,"66tNE0/iVB0Jnuiffk4SNy",null,[[2,"tree103",["_name"],224],[0,["_lpos"],224,[1,-94.689,0,-145.122]],[0,["_lrot"],224,[3,0,0,0,1]],[0,["_euler"],224,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],224,[1,0.5,0.5,0.5]]]],328]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2302,[5,"aeymN1wCZImpaAxbOxFIht",null,[[2,"tree104",["_name"],225],[0,["_lpos"],225,[1,-82.82,0,-143.006]],[0,["_lrot"],225,[3,0,0,0,1]],[0,["_euler"],225,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],225,[1,0.5,0.5,0.5]]]],329]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2303,[5,"8aZL+dEdFLVa7yLPEM5SI3",null,[[2,"tree105",["_name"],226],[0,["_lpos"],226,[1,-87.463,0,-152.623]],[0,["_lrot"],226,[3,0,0,0,1]],[0,["_euler"],226,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],226,[1,0.5,0.5,0.5]]]],330]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2304,[5,"d7850g/dxNbJeN+OVBkk6S",null,[[2,"tree106",["_name"],227],[0,["_lpos"],227,[1,-105.465,0,-145.476]],[0,["_lrot"],227,[3,0,0,0,1]],[0,["_euler"],227,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],227,[1,0.5,0.5,0.5]]]],331]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2305,[5,"2fkYMd6nJNuKfk49eoTRWE",null,[[2,"tree107",["_name"],228],[0,["_lpos"],228,[1,-122.593,0,-140.563]],[0,["_lrot"],228,[3,0,0,0,1]],[0,["_euler"],228,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],228,[1,0.5,0.5,0.5]]]],332]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2306,[5,"a4PlbQMcZEPqIocx5mgALc",null,[[2,"tree108",["_name"],229],[0,["_lpos"],229,[1,-111.501,0,-165.318]],[0,["_lrot"],229,[3,0,0,0,1]],[0,["_euler"],229,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],229,[1,0.5,0.5,0.5]]]],333]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2307,[5,"06oQHPxSNBWqZI8I+Ycgea",null,[[2,"tree109",["_name"],230],[0,["_lpos"],230,[1,-122.858,0,-182.543]],[0,["_lrot"],230,[3,0,0,0,1]],[0,["_euler"],230,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],230,[1,0.5,0.5,0.5]]]],334]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2308,[5,"b68bSSEtFMerTB3RfTJ7GO",null,[[2,"tree110",["_name"],231],[0,["_lpos"],231,[1,-111.582,0,-171.987]],[0,["_lrot"],231,[3,0,0,0,1]],[0,["_euler"],231,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],231,[1,0.5,0.5,0.5]]]],335]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2309,[5,"b0x1VBmGZOqL3trViLujt/",null,[[2,"tree111",["_name"],232],[0,["_lpos"],232,[1,-106.26,0,-160.261]],[0,["_lrot"],232,[3,0,0,0,1]],[0,["_euler"],232,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],232,[1,0.5,0.5,0.5]]]],336]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2310,[5,"abGgdERU1MUL0770VIe+ru",null,[[2,"tree112",["_name"],233],[0,["_lpos"],233,[1,-92.963,0,-165.52]],[0,["_lrot"],233,[3,0,0,0,1]],[0,["_euler"],233,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],233,[1,0.5,0.5,0.5]]]],337]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2311,[5,"5fJViuzkNORKe4JZeQ7fRv",null,[[2,"tree113",["_name"],234],[0,["_lpos"],234,[1,-83.237,0,-152.954]],[0,["_lrot"],234,[3,0,0,0,1]],[0,["_euler"],234,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],234,[1,0.5,0.5,0.5]]]],338]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2312,[5,"472C9AKANPNrDZc+44Rc9c",null,[[2,"tree114",["_name"],235],[0,["_lpos"],235,[1,-80.942,0,-166.8]],[0,["_lrot"],235,[3,0,0,0,1]],[0,["_euler"],235,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],235,[1,0.5,0.5,0.5]]]],339]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2313,[5,"b3eL2/CkhBi5HwaUJqt7yu",null,[[2,"tree115",["_name"],236],[0,["_lpos"],236,[1,-78.044,0,-153.489]],[0,["_lrot"],236,[3,0,0,0,1]],[0,["_euler"],236,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],236,[1,0.5,0.5,0.5]]]],340]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2314,[5,"79bsMwjHFMn7il6rLMKY+p",null,[[2,"tree116",["_name"],237],[0,["_lpos"],237,[1,-73.957,0,-138.763]],[0,["_lrot"],237,[3,0,0,0,1]],[0,["_euler"],237,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],237,[1,0.5,0.5,0.5]]]],341]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2315,[5,"39sWMss/9FWLqXo3qlhlB8",null,[[2,"tree117",["_name"],238],[0,["_lpos"],238,[1,-70.432,0,-147.877]],[0,["_lrot"],238,[3,0,0,0,1]],[0,["_euler"],238,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],238,[1,0.5,0.5,0.5]]]],342]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2316,[5,"86oBckvMtEDKu/Ww3uXPHI",null,[[2,"tree118",["_name"],239],[0,["_lpos"],239,[1,-73.581,0,-162.073]],[0,["_lrot"],239,[3,0,0,0,1]],[0,["_euler"],239,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],239,[1,0.5,0.5,0.5]]]],343]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2317,[5,"d0LZK4qRxDQoeNfSNGdDWn",null,[[2,"tree119",["_name"],240],[0,["_lpos"],240,[1,-99.43,0,-164.076]],[0,["_lrot"],240,[3,0,0,0,1]],[0,["_euler"],240,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],240,[1,0.5,0.5,0.5]]]],344]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2318,[5,"0erPOg5JVDyJ0D9RdgM7Yc",null,[[2,"tree120",["_name"],241],[0,["_lpos"],241,[1,-110.929,0,-181.746]],[0,["_lrot"],241,[3,0,0,0,1]],[0,["_euler"],241,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],241,[1,0.5,0.5,0.5]]]],345]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2319,[5,"a8PQZwraBAh5R3NQgTUO5W",null,[[2,"tree121",["_name"],242],[0,["_lpos"],242,[1,-99.668,0,-176.174]],[0,["_lrot"],242,[3,0,0,0,1]],[0,["_euler"],242,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],242,[1,0.5,0.5,0.5]]]],346]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2320,[5,"8bKu3nDPNIHYIAsd0RLQUL",null,[[2,"tree122",["_name"],243],[0,["_lpos"],243,[1,-126.432,0,-201.707]],[0,["_lrot"],243,[3,0,0,0,1]],[0,["_euler"],243,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],243,[1,0.5,0.5,0.5]]]],347]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2321,[5,"c0wy1dpI9PcqnRtAIXDC5z",null,[[2,"tree123",["_name"],244],[0,["_lpos"],244,[1,-129.249,0,-196.136]],[0,["_lrot"],244,[3,0,0,0,1]],[0,["_euler"],244,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],244,[1,0.5,0.5,0.5]]]],348]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2322,[5,"32TOlRd2VD+IdodZ2J4ccN",null,[[2,"tree124",["_name"],245],[0,["_lpos"],245,[1,-119.832,0,-206.056]],[0,["_lrot"],245,[3,0,0,0,1]],[0,["_euler"],245,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],245,[1,0.5,0.5,0.5]]]],349]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2323,[5,"baIGANEnJO6ab0NJCka6FC",null,[[2,"tree125",["_name"],246],[0,["_lpos"],246,[1,-119.832,0,-206.056]],[0,["_lrot"],246,[3,0,0,0,1]],[0,["_euler"],246,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],246,[1,0.5,0.5,0.5]]]],350]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2324,[5,"ea2YNia/FFoaev0tA1XhlE",null,[[2,"tree126",["_name"],247],[0,["_lpos"],247,[1,-110.605,0,-195.157]],[0,["_lrot"],247,[3,0,0,0,1]],[0,["_euler"],247,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],247,[1,0.5,0.5,0.5]]]],351]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2325,[5,"8atFPA0dVBPoRHr3O7gRQD",null,[[2,"tree127",["_name"],248],[0,["_lpos"],248,[1,-108.505,0,-208.027]],[0,["_lrot"],248,[3,0,0,0,1]],[0,["_euler"],248,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],248,[1,0.5,0.5,0.5]]]],352]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2326,[5,"01sGddji1HNJeO64T1YjJd",null,[[2,"tree128",["_name"],249],[0,["_lpos"],249,[1,-101.509,0,-193.915]],[0,["_lrot"],249,[3,0,0,0,1]],[0,["_euler"],249,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],249,[1,0.5,0.5,0.5]]]],353]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2327,[5,"cdzcbYxCxPObDm2waCXmPD",null,[[2,"tree129",["_name"],250],[0,["_lpos"],250,[1,-119.254,0,-194.217]],[0,["_lrot"],250,[3,0,0,0,1]],[0,["_euler"],250,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],250,[1,0.5,0.5,0.5]]]],354]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2328,[5,"d6MJM8cSlMKptWI5fkUCt9",null,[[2,"tree130",["_name"],251],[0,["_lpos"],251,[1,-166.085,0,-174.502]],[0,["_lrot"],251,[3,0,0,0,1]],[0,["_euler"],251,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],251,[1,0.5,0.5,0.5]]]],355]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2329,[5,"38zXTUBZtIooawt7Vxkb6S",null,[[2,"tree131",["_name"],252],[0,["_lpos"],252,[1,-159.977,0,-166.371]],[0,["_lrot"],252,[3,0,0,0,1]],[0,["_euler"],252,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],252,[1,0.5,0.5,0.5]]]],356]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2330,[5,"41ZVNw/fdGPbszO1FIgLES",null,[[2,"tree132",["_name"],253],[0,["_lpos"],253,[1,-167.727,0,-169.314]],[0,["_lrot"],253,[3,0,0,0,1]],[0,["_euler"],253,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],253,[1,0.5,0.5,0.5]]]],357]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2331,[5,"ebKW0nXolOs5ABCdiqtkjY",null,[[2,"tree133",["_name"],254],[0,["_lpos"],254,[1,-165.968,0,-163.352]],[0,["_lrot"],254,[3,0,0,0,1]],[0,["_euler"],254,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],254,[1,0.5,0.5,0.5]]]],358]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2332,[5,"4fhAUAbvFFMqnvqAzTOFez",null,[[2,"tree134",["_name"],255],[0,["_lpos"],255,[1,-159.824,0,-170.922]],[0,["_lrot"],255,[3,0,0,0,1]],[0,["_euler"],255,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],255,[1,0.5,0.5,0.5]]]],359]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2333,[5,"2bCpsGVkxD4qrt5xEJc0cv",null,[[2,"tree135",["_name"],256],[0,["_lpos"],256,[1,-156.542,0,-165.309]],[0,["_lrot"],256,[3,0,0,0,1]],[0,["_euler"],256,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],256,[1,0.5,0.5,0.5]]]],360]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2334,[5,"16CwDgB2JL2ZqaJqdnn5qo",null,[[2,"tree136",["_name"],257],[0,["_lpos"],257,[1,-157.679,0,-160.248]],[0,["_lrot"],257,[3,0,0,0,1]],[0,["_euler"],257,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],257,[1,0.5,0.5,0.5]]]],361]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2335,[5,"e3yLTNzbVAAJo1H7pkOjqi",null,[[2,"tree137",["_name"],258],[0,["_lpos"],258,[1,-165.847,0,-155.714]],[0,["_lrot"],258,[3,0,0,0,1]],[0,["_euler"],258,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],258,[1,0.5,0.5,0.5]]]],362]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2336,[5,"6fZgOXjL1AFK1rPh+YTXD1",null,[[2,"tree138",["_name"],259],[0,["_lpos"],259,[1,-165.847,0,-155.714]],[0,["_lrot"],259,[3,0,0,0,1]],[0,["_euler"],259,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],259,[1,0.5,0.5,0.5]]]],363]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2337,[5,"ddo4SVfjVMNYEUJ/TeOv0c",null,[[2,"tree139",["_name"],260],[0,["_lpos"],260,[1,-157.366,0,-155.643]],[0,["_lrot"],260,[3,0,0,0,1]],[0,["_euler"],260,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],260,[1,0.5,0.5,0.5]]]],364]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2338,[5,"280RdETCVPObg2ULAMK54r",null,[[2,"tree140",["_name"],261],[0,["_lpos"],261,[1,-158.948,0,-152.444]],[0,["_lrot"],261,[3,0,0,0,1]],[0,["_euler"],261,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],261,[1,0.5,0.5,0.5]]]],365]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2339,[5,"3ez9b/9RtLK4KeoevdrT/P",null,[[2,"tree141",["_name"],262],[0,["_lpos"],262,[1,-165.905,0,-145.841]],[0,["_lrot"],262,[3,0,0,0,1]],[0,["_euler"],262,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],262,[1,0.5,0.5,0.5]]]],366]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2340,[5,"e0BumA6pRJEYq+yKjAufaq",null,[[2,"tree142",["_name"],263],[0,["_lpos"],263,[1,-179.891,0,-143.195]],[0,["_lrot"],263,[3,0,0,0,1]],[0,["_euler"],263,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],263,[1,0.5,0.5,0.5]]]],367]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2341,[5,"54Jfr/y3tHkIqIwuadCnN0",null,[[2,"tree143",["_name"],264],[0,["_lpos"],264,[1,-168.826,0,-141.983]],[0,["_lrot"],264,[3,0,0,0,1]],[0,["_euler"],264,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],264,[1,0.5,0.5,0.5]]]],368]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2342,[5,"916J+/KAZAt4J17TSlhBny",null,[[2,"tree144",["_name"],265],[0,["_lpos"],265,[1,-159.79,0,-141.983]],[0,["_lrot"],265,[3,0,0,0,1]],[0,["_euler"],265,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],265,[1,0.5,0.5,0.5]]]],369]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2343,[5,"aczG1HdwhCQqmvkfbEoEii",null,[[2,"tree145",["_name"],266],[0,["_lpos"],266,[1,-157.13,0,-147.363]],[0,["_lrot"],266,[3,0,0,0,1]],[0,["_euler"],266,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],266,[1,0.5,0.5,0.5]]]],370]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2344,[5,"41F/MqX95OOJXmLSKW5TGO",null,[[2,"tree146",["_name"],267],[0,["_lpos"],267,[1,-183.638,0,-153.995]],[0,["_lrot"],267,[3,0,0,0,1]],[0,["_euler"],267,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],267,[1,0.5,0.5,0.5]]]],371]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2345,[5,"f74l/9uGNIDZ/nQ5gEywEE",null,[[2,"tree147",["_name"],268],[0,["_lpos"],268,[1,-183.638,0,-164.898]],[0,["_lrot"],268,[3,0,0,0,1]],[0,["_euler"],268,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],268,[1,0.5,0.5,0.5]]]],372]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2346,[5,"9f0XbMQMhHzIJyGedjlJSP",null,[[2,"tree148",["_name"],269],[0,["_lpos"],269,[1,-201.782,0,-159.926]],[0,["_lrot"],269,[3,0,0,0,1]],[0,["_euler"],269,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],269,[1,0.5,0.5,0.5]]]],373]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2347,[5,"6b0wOtzh9BwqGL6M1vX0x5",null,[[2,"tree149",["_name"],270],[0,["_lpos"],270,[1,-197.204,0,-149.647]],[0,["_lrot"],270,[3,0,0,0,1]],[0,["_euler"],270,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],270,[1,0.5,0.5,0.5]]]],374]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2348,[5,"e7fvC7XPVKqIQv5COYIoFW",null,[[2,"tree150",["_name"],271],[0,["_lpos"],271,[1,-176.683,0,-151.344]],[0,["_lrot"],271,[3,0,0,0,1]],[0,["_euler"],271,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],271,[1,0.5,0.5,0.5]]]],375]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2349,[5,"0baXHr5yFHr4YRpepJ9Wd/",null,[[2,"tree151",["_name"],272],[0,["_lpos"],272,[1,-169.216,0,-211.008]],[0,["_lrot"],272,[3,0,0,0,1]],[0,["_euler"],272,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],272,[1,0.5,0.5,0.5]]]],376]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2350,[5,"23iKZM2U1APZUfyj2Fr7V6",null,[[2,"tree152",["_name"],273],[0,["_lpos"],273,[1,-160.264,0,-210.959]],[0,["_lrot"],273,[3,0,0,0,1]],[0,["_euler"],273,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],273,[1,0.5,0.5,0.5]]]],377]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2351,[5,"8bxYPF0RlAP7leIckSjDDw",null,[[2,"tree153",["_name"],274],[0,["_lpos"],274,[1,-193.251,0,-206.539]],[0,["_lrot"],274,[3,0,0,0,1]],[0,["_euler"],274,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],274,[1,0.5,0.5,0.5]]]],378]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2352,[5,"07vZOxeS9EAYttnR97w1V6",null,[[2,"tree154",["_name"],275],[0,["_lpos"],275,[1,-189.157,0,-194.706]],[0,["_lrot"],275,[3,0,0,0,1]],[0,["_euler"],275,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],275,[1,0.5,0.5,0.5]]]],379]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2353,[5,"7cH2omhAxImY932gXkWU8c",null,[[2,"tree155",["_name"],276],[0,["_lpos"],276,[1,-189.157,0,-206.364]],[0,["_lrot"],276,[3,0,0,0,1]],[0,["_euler"],276,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],276,[1,0.5,0.5,0.5]]]],380]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2354,[5,"72HI3XwZhFtpWdeLZ6Aq0E",null,[[2,"tree156",["_name"],277],[0,["_lpos"],277,[1,-185.411,0,-203.044]],[0,["_lrot"],277,[3,0,0,0,1]],[0,["_euler"],277,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],277,[1,0.5,0.5,0.5]]]],381]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2355,[5,"c0CD/7nIFMIJNYrtFOQZEZ",null,[[2,"tree157",["_name"],278],[0,["_lpos"],278,[1,-190.677,0,-184.554]],[0,["_lrot"],278,[3,0,0,0,1]],[0,["_euler"],278,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],278,[1,0.5,0.5,0.5]]]],382]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2356,[5,"76ZZxtmvxD/5UGmNg/nYzx",null,[[2,"tree158",["_name"],279],[0,["_lpos"],279,[1,-193.862,0,-175.096]],[0,["_lrot"],279,[3,0,0,0,1]],[0,["_euler"],279,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],279,[1,0.5,0.5,0.5]]]],383]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2357,[5,"c3I+wZkyxAJr+NIM7iLv7M",null,[[2,"tree159",["_name"],280],[0,["_lpos"],280,[1,-184.184,0,-181.63]],[0,["_lrot"],280,[3,0,0,0,1]],[0,["_euler"],280,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],280,[1,0.5,0.5,0.5]]]],384]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2358,[5,"04o84h9ElNNosyTbLlfJnp",null,[[2,"tree160",["_name"],281],[0,["_lpos"],281,[1,-183.715,0,-238.743]],[0,["_lrot"],281,[3,0,0,0,1]],[0,["_euler"],281,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],281,[1,0.5,0.5,0.5]]]],385]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2359,[5,"daevIicbpKbaULL0y6c7TC",null,[[2,"tree161",["_name"],282],[0,["_lpos"],282,[1,-175.194,0,-242.412]],[0,["_lrot"],282,[3,0,0,0,1]],[0,["_euler"],282,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],282,[1,0.5,0.5,0.5]]]],386]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2360,[5,"c53ahc3mpCCb1UGaadrgOa",null,[[2,"tree162",["_name"],283],[0,["_lpos"],283,[1,-159.414,0,-237.789]],[0,["_lrot"],283,[3,0,0,0,1]],[0,["_euler"],283,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],283,[1,0.5,0.5,0.5]]]],387]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2361,[5,"0bjLiPT6BBDLNQgYGLIYCc",null,[[2,"tree163",["_name"],284],[0,["_lpos"],284,[1,-172.162,0,-238.369]],[0,["_lrot"],284,[3,0,0,0,1]],[0,["_euler"],284,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],284,[1,0.5,0.5,0.5]]]],388]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2362,[5,"b68q35yB5Klai6KwxAAIPU",null,[[2,"tree164",["_name"],285],[0,["_lpos"],285,[1,-165.135,0,-251.825]],[0,["_lrot"],285,[3,0,0,0,1]],[0,["_euler"],285,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],285,[1,0.5,0.5,0.5]]]],389]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2363,[5,"eeQ4UDEVxL+7ZuK2jWTOG0",null,[[2,"tree165",["_name"],286],[0,["_lpos"],286,[1,-165.135,0,-249.374]],[0,["_lrot"],286,[3,0,0,0,1]],[0,["_euler"],286,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],286,[1,0.5,0.5,0.5]]]],390]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2364,[5,"2bR0Rm0FZPC4x46BYrAmmL",null,[[2,"tree166",["_name"],287],[0,["_lpos"],287,[1,-159.8,0,-245.103]],[0,["_lrot"],287,[3,0,0,0,1]],[0,["_euler"],287,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],287,[1,0.5,0.5,0.5]]]],391]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2365,[5,"a8vwCNCdRH57e+0KmT4nV3",null,[[2,"tree167",["_name"],288],[0,["_lpos"],288,[1,-178.227,0,-251.084]],[0,["_lrot"],288,[3,0,0,0,1]],[0,["_euler"],288,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],288,[1,0.5,0.5,0.5]]]],392]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2366,[5,"93C04aWpZAWZdIpSvQoa0/",null,[[2,"tree168",["_name"],289],[0,["_lpos"],289,[1,-195.067,0,-255.789]],[0,["_lrot"],289,[3,0,0,0,1]],[0,["_euler"],289,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],289,[1,0.5,0.5,0.5]]]],393]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2367,[5,"2bNd4wmgNFcYqVqOOsngeJ",null,[[2,"tree169",["_name"],290],[0,["_lpos"],290,[1,-201.15,0,-250.868]],[0,["_lrot"],290,[3,0,0,0,1]],[0,["_euler"],290,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],290,[1,0.5,0.5,0.5]]]],394]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2368,[5,"f3Nr5sJ7VD6Zip5VKVEZjx",null,[[2,"tree170",["_name"],291],[0,["_lpos"],291,[1,-192.888,0,-252.435]],[0,["_lrot"],291,[3,0,0,0,1]],[0,["_euler"],291,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],291,[1,0.5,0.5,0.5]]]],395]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2369,[5,"57H2USDCNIq4EsEiSaR56S",null,[[2,"tree171",["_name"],292],[0,["_lpos"],292,[1,-196.963,0,-265.535]],[0,["_lrot"],292,[3,0,0,0,1]],[0,["_euler"],292,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],292,[1,0.5,0.5,0.5]]]],396]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2370,[5,"beFzBLtc9ECL2C09fJGvPR",null,[[2,"tree172",["_name"],293],[0,["_lpos"],293,[1,-188.993,0,-263.75]],[0,["_lrot"],293,[3,0,0,0,1]],[0,["_euler"],293,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],293,[1,0.5,0.5,0.5]]]],397]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2371,[5,"14S+NsPk1Kbaq4GwX7WNCq",null,[[2,"tree173",["_name"],294],[0,["_lpos"],294,[1,-180.181,0,-264.977]],[0,["_lrot"],294,[3,0,0,0,1]],[0,["_euler"],294,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],294,[1,0.5,0.5,0.5]]]],398]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2372,[5,"75Q77cHwhFg5gd6BgV6ypu",null,[[2,"tree174",["_name"],295],[0,["_lpos"],295,[1,-170.842,0,-261.133]],[0,["_lrot"],295,[3,0,0,0,1]],[0,["_euler"],295,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],295,[1,0.5,0.5,0.5]]]],399]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2373,[5,"7c/6Un9LZAYIZYcnvInqTQ",null,[[2,"tree175",["_name"],296],[0,["_lpos"],296,[1,-163.024,0,-256.596]],[0,["_lrot"],296,[3,0,0,0,1]],[0,["_euler"],296,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],296,[1,0.5,0.5,0.5]]]],400]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2374,[5,"efkW5gnA1G3LaRsUd60FSq",null,[[2,"tree176",["_name"],297],[0,["_lpos"],297,[1,-164.157,0,-262.949]],[0,["_lrot"],297,[3,0,0,0,1]],[0,["_euler"],297,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],297,[1,0.5,0.5,0.5]]]],401]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2375,[5,"acucrkL5xAKZNlQq9WNs/e",null,[[2,"tree177",["_name"],298],[0,["_lpos"],298,[1,-157.949,0,-253.079]],[0,["_lrot"],298,[3,0,0,0,1]],[0,["_euler"],298,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],298,[1,0.5,0.5,0.5]]]],402]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2376,[5,"4ah2Q7G2hLEbI8urifXIHg",null,[[2,"tree178",["_name"],299],[0,["_lpos"],299,[1,-130.253,0,-253.079]],[0,["_lrot"],299,[3,0,0,0,1]],[0,["_euler"],299,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],299,[1,0.5,0.5,0.5]]]],403]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2377,[5,"e03vW3t3tBYb/i7wje1Whb",null,[[2,"tree179",["_name"],300],[0,["_lpos"],300,[1,-126.016,0,-253.079]],[0,["_lrot"],300,[3,0,0,0,1]],[0,["_euler"],300,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],300,[1,0.5,0.5,0.5]]]],404]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2378,[5,"d1g5pln/9NVZo27oJuy5A0",null,[[2,"tree180",["_name"],301],[0,["_lpos"],301,[1,-124.361,0,-248.842]],[0,["_lrot"],301,[3,0,0,0,1]],[0,["_euler"],301,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],301,[1,0.5,0.5,0.5]]]],405]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2379,[5,"2f/renZ2dPzq9ucCBt7gPm",null,[[2,"tree181",["_name"],302],[0,["_lpos"],302,[1,-125.835,0,-242.855]],[0,["_lrot"],302,[3,0,0,0,1]],[0,["_euler"],302,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],302,[1,0.5,0.5,0.5]]]],406]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2380,[5,"05rVPLJE5KV500sm9PHb6f",null,[[2,"tree182",["_name"],303],[0,["_lpos"],303,[1,-125.835,0,-237.507]],[0,["_lrot"],303,[3,0,0,0,1]],[0,["_euler"],303,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],303,[1,0.5,0.5,0.5]]]],407]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2381,[5,"c265csGdlBJb+/P3keDNeX",null,[[2,"tree183",["_name"],304],[0,["_lpos"],304,[1,-117.688,0,-239.452]],[0,["_lrot"],304,[3,0,0,0,1]],[0,["_euler"],304,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],304,[1,0.5,0.5,0.5]]]],408]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2382,[5,"a26u7AvS9LirvIWIzfyggt",null,[[2,"tree184",["_name"],305],[0,["_lpos"],305,[1,-121.262,0,-237.596]],[0,["_lrot"],305,[3,0,0,0,1]],[0,["_euler"],305,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],305,[1,0.5,0.5,0.5]]]],409]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2383,[5,"cemFP7UB9NIZQInLMwNlKT",null,[[2,"tree185",["_name"],306],[0,["_lpos"],306,[1,-113.529,0,-238.091]],[0,["_lrot"],306,[3,0,0,0,1]],[0,["_euler"],306,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],306,[1,0.5,0.5,0.5]]]],410]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2384,[5,"82xzGgqmdLU6rM6rzQqNE0",null,[[2,"tree186",["_name"],307],[0,["_lpos"],307,[1,-106.854,0,-236.887]],[0,["_lrot"],307,[3,0,0,0,1]],[0,["_euler"],307,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],307,[1,0.5,0.5,0.5]]]],411]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2385,[5,"29/Ra3fNRAbISHCpMDzeSN",null,[[2,"tree187",["_name"],308],[0,["_lpos"],308,[1,-106.854,0,-236.887]],[0,["_lrot"],308,[3,0,0,0,1]],[0,["_euler"],308,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],308,[1,0.5,0.5,0.5]]]],412]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2386,[5,"197sckgFhC85kGjBWQngr2",null,[[2,"tree188",["_name"],309],[0,["_lpos"],309,[1,-98.012,0,-240.361]],[0,["_lrot"],309,[3,0,0,0,1]],[0,["_euler"],309,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],309,[1,0.5,0.5,0.5]]]],413]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2387,[5,"ecEl5o2h5EUrAwyvVROW2b",null,[[2,"tree189",["_name"],310],[0,["_lpos"],310,[1,-117.081,0,-245.361]],[0,["_lrot"],310,[3,0,0,0,1]],[0,["_euler"],310,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],310,[1,0.5,0.5,0.5]]]],414]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2388,[5,"50xXG6zexM/76vbEnqvbzI",null,[[2,"tree190",["_name"],311],[0,["_lpos"],311,[1,-119.729,0,-258.191]],[0,["_lrot"],311,[3,0,0,0,1]],[0,["_euler"],311,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],311,[1,0.5,0.5,0.5]]]],415]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2389,[5,"0dPkZIN4dAYajQt6UnejrU",null,[[2,"tree191",["_name"],312],[0,["_lpos"],312,[1,-127.202,0,-267.063]],[0,["_lrot"],312,[3,0,0,0,1]],[0,["_euler"],312,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],312,[1,0.5,0.5,0.5]]]],416]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2390,[5,"c7FJTvwSxOIrcC46rBEABa",null,[[2,"tree192",["_name"],313],[0,["_lpos"],313,[1,-122.046,0,-269.216]],[0,["_lrot"],313,[3,0,0,0,1]],[0,["_euler"],313,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],313,[1,0.5,0.5,0.5]]]],417]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2391,[5,"ae3fKna3hDB6SpTjOZg68K",null,[[2,"tree193",["_name"],314],[0,["_lpos"],314,[1,-114.993,0,-258.855]],[0,["_lrot"],314,[3,0,0,0,1]],[0,["_euler"],314,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],314,[1,0.5,0.5,0.5]]]],418]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2392,[5,"655OsJC3dOpp1R+OZ5fP1O",null,[[2,"tree194",["_name"],315],[0,["_lpos"],315,[1,-112.982,0,-251.761]],[0,["_lrot"],315,[3,0,0,0,1]],[0,["_euler"],315,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],315,[1,0.5,0.5,0.5]]]],419]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2393,[5,"1a03k2PhpBRo+D4zoFbzLd",null,[[2,"tree195",["_name"],316],[0,["_lpos"],316,[1,-105.626,0,-260.483]],[0,["_lrot"],316,[3,0,0,0,1]],[0,["_euler"],316,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],316,[1,0.5,0.5,0.5]]]],420]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2394,[5,"46CNBFt3pMg5UEASUIpGOt",null,[[2,"tree196",["_name"],317],[0,["_lpos"],317,[1,-109.626,0,-249.483]],[0,["_lrot"],317,[3,0,0,0,1]],[0,["_euler"],317,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],317,[1,0.5,0.5,0.5]]]],421]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2395,[5,"31bSSlYwFN4JMzgqFDfyhn",null,[[2,"tree197",["_name"],318],[0,["_lpos"],318,[1,-103.043,0,-254.061]],[0,["_lrot"],318,[3,0,0,0,1]],[0,["_euler"],318,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],318,[1,0.5,0.5,0.5]]]],422]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2396,[5,"bdOVfQRrRD/rw5psDYXFpo",null,[[2,"tree198",["_name"],319],[0,["_lpos"],319,[1,-101.109,0,-250.135]],[0,["_lrot"],319,[3,0,0,0,1]],[0,["_euler"],319,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],319,[1,0.5,0.5,0.5]]]],423]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2397,[5,"a8lviKz5tPM68m8dsfL4XL",null,[[2,"tree199",["_name"],320],[0,["_lpos"],320,[1,-101.109,0,-250.135]],[0,["_lrot"],320,[3,0,0,0,1]],[0,["_euler"],320,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],320,[1,0.5,0.5,0.5]]]],424]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2398,[5,"6225JmGMBLkrWDMCbzxPTP",null,[[2,"tree200",["_name"],321],[0,["_lpos"],321,[1,-90.255,0,-250.135]],[0,["_lrot"],321,[3,0,0,0,1]],[0,["_euler"],321,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],321,[1,0.5,0.5,0.5]]]],425]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2399,[5,"43Dl55KX1DX5kaycEPPyXX",null,[[2,"tree201",["_name"],322],[0,["_lpos"],322,[1,-90.255,0,-250.135]],[0,["_lrot"],322,[3,0,0,0,1]],[0,["_euler"],322,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],322,[1,0.5,0.5,0.5]]]],426]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2400,[5,"a96iKUvhJHr4M5rvtsmpHZ",null,[[2,"tree202",["_name"],323],[0,["_lpos"],323,[1,-92.189,0,-254.061]],[0,["_lrot"],323,[3,0,0,0,1]],[0,["_euler"],323,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],323,[1,0.5,0.5,0.5]]]],427]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2401,[5,"d24GWI2pdE/4lkDXaFaC+Z",null,[[2,"tree203",["_name"],324],[0,["_lpos"],324,[1,-98.772,0,-249.483]],[0,["_lrot"],324,[3,0,0,0,1]],[0,["_euler"],324,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],324,[1,0.5,0.5,0.5]]]],428]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2402,[5,"b3MUIDKphO7op2Xidx/Cig",null,[[2,"tree204",["_name"],325],[0,["_lpos"],325,[1,-94.772,0,-260.483]],[0,["_lrot"],325,[3,0,0,0,1]],[0,["_euler"],325,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],325,[1,0.5,0.5,0.5]]]],429]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2403,[5,"9eUa6Q4RBGG4dW4gkbIYW/",null,[[2,"tree205",["_name"],326],[0,["_lpos"],326,[1,-102.128,0,-251.761]],[0,["_lrot"],326,[3,0,0,0,1]],[0,["_euler"],326,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],326,[1,0.5,0.5,0.5]]]],430]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2404,[5,"ce2th3dDRO+bPQjmjpM+Zk",null,[[2,"tree206",["_name"],327],[0,["_lpos"],327,[1,-104.139,0,-258.855]],[0,["_lrot"],327,[3,0,0,0,1]],[0,["_euler"],327,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],327,[1,0.5,0.5,0.5]]]],431]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2405,[5,"0dqSFPAe1MMrFASEgX+YSe",null,[[2,"tree207",["_name"],328],[0,["_lpos"],328,[1,-112.339,0,-267.366]],[0,["_lrot"],328,[3,0,0,0,1]],[0,["_euler"],328,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],328,[1,0.5,0.5,0.5]]]],432]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2406,[5,"2b2xqMA5lAQqN4bRmiCTdH",null,[[2,"tree208",["_name"],329],[0,["_lpos"],329,[1,-106.176,0,-274.199]],[0,["_lrot"],329,[3,0,0,0,1]],[0,["_euler"],329,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],329,[1,0.5,0.5,0.5]]]],433]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2407,[5,"773OZn7ZZO3KF5KjzUjdH4",null,[[2,"tree209",["_name"],330],[0,["_lpos"],330,[1,-106.176,0,-274.199]],[0,["_lrot"],330,[3,0,0,0,1]],[0,["_euler"],330,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],330,[1,0.5,0.5,0.5]]]],434]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2408,[5,"10jFHNHB9JMrjEzRynaU1S",null,[[2,"tree210",["_name"],331],[0,["_lpos"],331,[1,-95.322,0,-274.199]],[0,["_lrot"],331,[3,0,0,0,1]],[0,["_euler"],331,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],331,[1,0.5,0.5,0.5]]]],435]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2409,[5,"e4/rV02DtO+pdHlO8ZRqjO",null,[[2,"tree211",["_name"],332],[0,["_lpos"],332,[1,-95.322,0,-274.199]],[0,["_lrot"],332,[3,0,0,0,1]],[0,["_euler"],332,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],332,[1,0.5,0.5,0.5]]]],436]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2410,[5,"8drXRffIJDSKRS1ECg483N",null,[[2,"tree212",["_name"],333],[0,["_lpos"],333,[1,-97.256,0,-278.125]],[0,["_lrot"],333,[3,0,0,0,1]],[0,["_euler"],333,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],333,[1,0.5,0.5,0.5]]]],437]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2411,[5,"6839FPwHFOi5nL338mI4la",null,[[2,"tree213",["_name"],334],[0,["_lpos"],334,[1,-110.541,0,-272.321]],[0,["_lrot"],334,[3,0,0,0,1]],[0,["_euler"],334,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],334,[1,0.5,0.5,0.5]]]],438]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2412,[5,"d0kfOsPjxLaY3THRn9BjNI",null,[[2,"tree214",["_name"],335],[0,["_lpos"],335,[1,-107.531,0,-287.48]],[0,["_lrot"],335,[3,0,0,0,1]],[0,["_euler"],335,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],335,[1,0.5,0.5,0.5]]]],439]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2413,[5,"fdV5N2YmFCaL3k7mMBgi9D",null,[[2,"tree215",["_name"],336],[0,["_lpos"],336,[1,-113.897,0,-274.599]],[0,["_lrot"],336,[3,0,0,0,1]],[0,["_euler"],336,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],336,[1,0.5,0.5,0.5]]]],440]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2414,[5,"6c4CzlXOpKEq5EiV060sj8",null,[[2,"tree216",["_name"],337],[0,["_lpos"],337,[1,-115.87,0,-287.371]],[0,["_lrot"],337,[3,0,0,0,1]],[0,["_euler"],337,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],337,[1,0.5,0.5,0.5]]]],441]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2415,[5,"c9kvfTfKlMhp8ZoRUl3qdD",null,[[2,"tree217",["_name"],338],[0,["_lpos"],338,[1,-100.325,0,-293.293]],[0,["_lrot"],338,[3,0,0,0,1]],[0,["_euler"],338,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],338,[1,0.5,0.5,0.5]]]],442]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2416,[5,"acuCy0dtZJj7o3uw4B6BKm",null,[[2,"tree218",["_name"],339],[0,["_lpos"],339,[1,-98.352,0,-280.521]],[0,["_lrot"],339,[3,0,0,0,1]],[0,["_euler"],339,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],339,[1,0.5,0.5,0.5]]]],443]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2417,[5,"62AFN+mqRBArvfs9alQpU0",null,[[2,"tree219",["_name"],340],[0,["_lpos"],340,[1,-91.986,0,-293.402]],[0,["_lrot"],340,[3,0,0,0,1]],[0,["_euler"],340,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],340,[1,0.5,0.5,0.5]]]],444]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2418,[5,"17DfKWQdFDuJ1cuTOnSvy6",null,[[2,"tree220",["_name"],341],[0,["_lpos"],341,[1,-94.996,0,-278.243]],[0,["_lrot"],341,[3,0,0,0,1]],[0,["_euler"],341,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],341,[1,0.5,0.5,0.5]]]],445]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2419,[5,"0930DPKk5PhZ8/BtGatpTh",null,[[2,"tree221",["_name"],342],[0,["_lpos"],342,[1,-81.711,0,-284.047]],[0,["_lrot"],342,[3,0,0,0,1]],[0,["_euler"],342,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],342,[1,0.5,0.5,0.5]]]],446]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2420,[5,"78Eg9KARhGk4nyBGadG6V1",null,[[2,"tree222",["_name"],343],[0,["_lpos"],343,[1,-79.777,0,-280.121]],[0,["_lrot"],343,[3,0,0,0,1]],[0,["_euler"],343,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],343,[1,0.5,0.5,0.5]]]],447]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2421,[5,"3fusT5zxRGsavXy9gAYcB9",null,[[2,"tree223",["_name"],344],[0,["_lpos"],344,[1,-69.115,0,-270.8]],[0,["_lrot"],344,[3,0,0,0,1]],[0,["_euler"],344,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],344,[1,0.5,0.5,0.5]]]],448]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2422,[5,"a0wUSbI5JEzYdcsh/W44kV",null,[[2,"tree224",["_name"],345],[0,["_lpos"],345,[1,-71.049,0,-274.726]],[0,["_lrot"],345,[3,0,0,0,1]],[0,["_euler"],345,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],345,[1,0.5,0.5,0.5]]]],449]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2423,[5,"a6J4FfcG9Eu4mI4UEG8ic2",null,[[2,"tree225",["_name"],346],[0,["_lpos"],346,[1,-84.334,0,-268.922]],[0,["_lrot"],346,[3,0,0,0,1]],[0,["_euler"],346,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],346,[1,0.5,0.5,0.5]]]],450]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2424,[5,"24wICteTtMSKAQfAzwczKL",null,[[2,"tree226",["_name"],347],[0,["_lpos"],347,[1,-81.324,0,-284.081]],[0,["_lrot"],347,[3,0,0,0,1]],[0,["_euler"],347,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],347,[1,0.5,0.5,0.5]]]],451]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2425,[5,"cf96L5WqVPc76odgLs11sF",null,[[2,"tree227",["_name"],348],[0,["_lpos"],348,[1,-87.69,0,-271.2]],[0,["_lrot"],348,[3,0,0,0,1]],[0,["_euler"],348,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],348,[1,0.5,0.5,0.5]]]],452]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2426,[5,"80I9RauDFHXY1CheW5FLqk",null,[[2,"tree228",["_name"],349],[0,["_lpos"],349,[1,-89.663,0,-283.972]],[0,["_lrot"],349,[3,0,0,0,1]],[0,["_euler"],349,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],349,[1,0.5,0.5,0.5]]]],453]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2427,[5,"1fzuEot3FLL5ZitruSrGi2",null,[[2,"tree229",["_name"],350],[0,["_lpos"],350,[1,-115.564,0,-307.73]],[0,["_lrot"],350,[3,0,0,0,1]],[0,["_euler"],350,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],350,[1,0.5,0.5,0.5]]]],454]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2428,[5,"79AhfwURxIRKbkSsIiFb6y",null,[[2,"tree230",["_name"],351],[0,["_lpos"],351,[1,-113.591,0,-294.958]],[0,["_lrot"],351,[3,0,0,0,1]],[0,["_euler"],351,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],351,[1,0.5,0.5,0.5]]]],455]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2429,[5,"c2LpyyIRNEe4ZrVDQrZAJx",null,[[2,"tree231",["_name"],352],[0,["_lpos"],352,[1,-107.225,0,-307.839]],[0,["_lrot"],352,[3,0,0,0,1]],[0,["_euler"],352,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],352,[1,0.5,0.5,0.5]]]],456]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2430,[5,"8d/2JTSzFKlYVgPwcdgZbS",null,[[2,"tree232",["_name"],353],[0,["_lpos"],353,[1,-110.235,0,-292.68]],[0,["_lrot"],353,[3,0,0,0,1]],[0,["_euler"],353,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],353,[1,0.5,0.5,0.5]]]],457]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2431,[5,"14wKJO0sBI07gIIDbosn3H",null,[[2,"tree233",["_name"],354],[0,["_lpos"],354,[1,-96.95,0,-298.484]],[0,["_lrot"],354,[3,0,0,0,1]],[0,["_euler"],354,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],354,[1,0.5,0.5,0.5]]]],458]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2432,[5,"a1QmYOfstA/7X3DZKktecc",null,[[2,"tree234",["_name"],355],[0,["_lpos"],355,[1,-95.016,0,-294.558]],[0,["_lrot"],355,[3,0,0,0,1]],[0,["_euler"],355,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],355,[1,0.5,0.5,0.5]]]],459]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2433,[5,"aaCc6x+SVPp4lkcwXDi7cY",null,[[2,"tree235",["_name"],356],[0,["_lpos"],356,[1,-66.682,0,-290.129]],[0,["_lrot"],356,[3,0,0,0,1]],[0,["_euler"],356,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],356,[1,0.5,0.5,0.5]]]],460]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2434,[5,"67dcPyJ0RM06m+0y457U0e",null,[[2,"tree236",["_name"],357],[0,["_lpos"],357,[1,-68.616,0,-294.055]],[0,["_lrot"],357,[3,0,0,0,1]],[0,["_euler"],357,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],357,[1,0.5,0.5,0.5]]]],461]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2435,[5,"c8lvpjPCpKaqj4hWrDxrUi",null,[[2,"tree237",["_name"],358],[0,["_lpos"],358,[1,-81.901,0,-288.251]],[0,["_lrot"],358,[3,0,0,0,1]],[0,["_euler"],358,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],358,[1,0.5,0.5,0.5]]]],462]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2436,[5,"89qBufkOJFvq2/9BT+Mlkd",null,[[2,"tree238",["_name"],359],[0,["_lpos"],359,[1,-78.891,0,-303.41]],[0,["_lrot"],359,[3,0,0,0,1]],[0,["_euler"],359,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],359,[1,0.5,0.5,0.5]]]],463]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2437,[5,"13aRO7M51N+ZNfOviA+7e/",null,[[2,"tree239",["_name"],360],[0,["_lpos"],360,[1,-85.257,0,-290.529]],[0,["_lrot"],360,[3,0,0,0,1]],[0,["_euler"],360,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],360,[1,0.5,0.5,0.5]]]],464]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2438,[5,"75NrkNc7NOq6yzqP6ZUb5F",null,[[2,"tree240",["_name"],361],[0,["_lpos"],361,[1,-87.23,0,-303.301]],[0,["_lrot"],361,[3,0,0,0,1]],[0,["_euler"],361,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],361,[1,0.5,0.5,0.5]]]],465]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2439,[5,"485zJajHtCD5WoKfGwi2Ik",null,[[2,"tree241",["_name"],362],[0,["_lpos"],362,[1,-195.112,0,-284.629]],[0,["_lrot"],362,[3,0,0,0,1]],[0,["_euler"],362,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],362,[1,0.5,0.5,0.5]]]],466]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2440,[5,"908T7QtaVCM7Cjjj9mBzBf",null,[[2,"tree242",["_name"],363],[0,["_lpos"],363,[1,-193.139,0,-271.857]],[0,["_lrot"],363,[3,0,0,0,1]],[0,["_euler"],363,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],363,[1,0.5,0.5,0.5]]]],467]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2441,[5,"31sTPmUGJB57ECvsQCEwqq",null,[[2,"tree243",["_name"],364],[0,["_lpos"],364,[1,-186.773,0,-284.738]],[0,["_lrot"],364,[3,0,0,0,1]],[0,["_euler"],364,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],364,[1,0.5,0.5,0.5]]]],468]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2442,[5,"d4HYhKFhBKqbDvBRFxuHxz",null,[[2,"tree244",["_name"],365],[0,["_lpos"],365,[1,-189.783,0,-269.579]],[0,["_lrot"],365,[3,0,0,0,1]],[0,["_euler"],365,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],365,[1,0.5,0.5,0.5]]]],469]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2443,[5,"e0AuwMd7dPnqWtf2j/XDQe",null,[[2,"tree245",["_name"],366],[0,["_lpos"],366,[1,-176.498,0,-275.383]],[0,["_lrot"],366,[3,0,0,0,1]],[0,["_euler"],366,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],366,[1,0.5,0.5,0.5]]]],470]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2444,[5,"a8KIqTedJJrLEFhi0Eeu6V",null,[[2,"tree246",["_name"],367],[0,["_lpos"],367,[1,-174.564,0,-271.457]],[0,["_lrot"],367,[3,0,0,0,1]],[0,["_euler"],367,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],367,[1,0.5,0.5,0.5]]]],471]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2445,[5,"d0S8q5CyxHKZ7qORLzLlPI",null,[[2,"tree247",["_name"],368],[0,["_lpos"],368,[1,-169.35,0,-246.322]],[0,["_lrot"],368,[3,0,0,0,1]],[0,["_euler"],368,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],368,[1,0.5,0.5,0.5]]]],472]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2446,[5,"56TCc68HFP3Ihk8gmAYozz",null,[[2,"tree248",["_name"],369],[0,["_lpos"],369,[1,-171.284,0,-250.248]],[0,["_lrot"],369,[3,0,0,0,1]],[0,["_euler"],369,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],369,[1,0.5,0.5,0.5]]]],473]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2447,[5,"e07qUHb4FAo6SO/g8s8Mu1",null,[[2,"tree249",["_name"],370],[0,["_lpos"],370,[1,-184.569,0,-244.444]],[0,["_lrot"],370,[3,0,0,0,1]],[0,["_euler"],370,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],370,[1,0.5,0.5,0.5]]]],474]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2448,[5,"6d7pRjxo1OuZC4zgKFG61t",null,[[2,"tree250",["_name"],371],[0,["_lpos"],371,[1,-181.559,0,-259.603]],[0,["_lrot"],371,[3,0,0,0,1]],[0,["_euler"],371,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],371,[1,0.5,0.5,0.5]]]],475]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2449,[5,"79iXu1nCJEha2i83uNu+iz",null,[[2,"tree251",["_name"],372],[0,["_lpos"],372,[1,-187.925,0,-246.722]],[0,["_lrot"],372,[3,0,0,0,1]],[0,["_euler"],372,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],372,[1,0.5,0.5,0.5]]]],476]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2450,[5,"86xM9yHoZNS5zhCUX/G2Ch",null,[[2,"tree252",["_name"],373],[0,["_lpos"],373,[1,-189.898,0,-259.494]],[0,["_lrot"],373,[3,0,0,0,1]],[0,["_euler"],373,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],373,[1,0.5,0.5,0.5]]]],477]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2451,[5,"92fqoLmvtG6Y8mxJxBNvwR",null,[[2,"tree253",["_name"],374],[0,["_lpos"],374,[1,-183.518,0,-283.367]],[0,["_lrot"],374,[3,0,0,0,1]],[0,["_euler"],374,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],374,[1,0.5,0.5,0.5]]]],478]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2452,[5,"62n3vtDJ1FHr3Ml52l7DNs",null,[[2,"tree254",["_name"],375],[0,["_lpos"],375,[1,-181.545,0,-270.595]],[0,["_lrot"],375,[3,0,0,0,1]],[0,["_euler"],375,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],375,[1,0.5,0.5,0.5]]]],479]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2453,[5,"c8idD1RchNHYSf0d3rb09I",null,[[2,"tree255",["_name"],376],[0,["_lpos"],376,[1,-175.179,0,-283.476]],[0,["_lrot"],376,[3,0,0,0,1]],[0,["_euler"],376,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],376,[1,0.5,0.5,0.5]]]],480]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2454,[5,"914O3qG49AGZqimDUF5elg",null,[[2,"tree256",["_name"],377],[0,["_lpos"],377,[1,-178.189,0,-268.317]],[0,["_lrot"],377,[3,0,0,0,1]],[0,["_euler"],377,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],377,[1,0.5,0.5,0.5]]]],481]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2455,[5,"b9mCQJ0EZMdZAqkEPrhyPJ",null,[[2,"tree257",["_name"],378],[0,["_lpos"],378,[1,-164.904,0,-274.121]],[0,["_lrot"],378,[3,0,0,0,1]],[0,["_euler"],378,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],378,[1,0.5,0.5,0.5]]]],482]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2456,[5,"c2vPSa/+dBUIaA9AtiFFWc",null,[[2,"tree258",["_name"],379],[0,["_lpos"],379,[1,-162.97,0,-270.195]],[0,["_lrot"],379,[3,0,0,0,1]],[0,["_euler"],379,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],379,[1,0.5,0.5,0.5]]]],483]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2457,[5,"13r602RbZIArpMp8RJevLs",null,[[2,"tree259",["_name"],380],[0,["_lpos"],380,[1,-188.158,0,-239.966]],[0,["_lrot"],380,[3,0,0,0,1]],[0,["_euler"],380,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],380,[1,0.5,0.5,0.5]]]],484]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2458,[5,"87hLIqtLRPHr54CIdx2JSt",null,[[2,"tree260",["_name"],381],[0,["_lpos"],381,[1,-190.092,0,-243.892]],[0,["_lrot"],381,[3,0,0,0,1]],[0,["_euler"],381,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],381,[1,0.5,0.5,0.5]]]],485]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2459,[5,"7cD0CEc09LEJ4Nq2bzFQOr",null,[[2,"tree261",["_name"],382],[0,["_lpos"],382,[1,-203.377,0,-238.088]],[0,["_lrot"],382,[3,0,0,0,1]],[0,["_euler"],382,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],382,[1,0.5,0.5,0.5]]]],486]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2460,[5,"aezcrmrypCTLbaXaFwYvGD",null,[[2,"tree262",["_name"],383],[0,["_lpos"],383,[1,-200.367,0,-253.247]],[0,["_lrot"],383,[3,0,0,0,1]],[0,["_euler"],383,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],383,[1,0.5,0.5,0.5]]]],487]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2461,[5,"2ebR2SY3ZNOZKVZ+aNgUmh",null,[[2,"tree263",["_name"],384],[0,["_lpos"],384,[1,-206.733,0,-240.366]],[0,["_lrot"],384,[3,0,0,0,1]],[0,["_euler"],384,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],384,[1,0.5,0.5,0.5]]]],488]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2462,[5,"9fd8MxtlFA4ZIiFMoqQBAR",null,[[2,"tree264",["_name"],385],[0,["_lpos"],385,[1,-208.706,0,-253.138]],[0,["_lrot"],385,[3,0,0,0,1]],[0,["_euler"],385,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],385,[1,0.5,0.5,0.5]]]],489]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2463,[5,"bd1DuUOllGurXE+VvrEBHj",null,[[2,"tree265",["_name"],386],[0,["_lpos"],386,[1,-218.372,0,-255.457]],[0,["_lrot"],386,[3,0,0,0,1]],[0,["_euler"],386,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],386,[1,0.5,0.5,0.5]]]],490]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2464,[5,"fdHPXoFQ1HiJm/XiZFO7nk",null,[[2,"tree266",["_name"],387],[0,["_lpos"],387,[1,-216.399,0,-242.685]],[0,["_lrot"],387,[3,0,0,0,1]],[0,["_euler"],387,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],387,[1,0.5,0.5,0.5]]]],491]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2465,[5,"bdV8O4ueVEYITGvSuPUNP8",null,[[2,"tree267",["_name"],388],[0,["_lpos"],388,[1,-210.033,0,-255.566]],[0,["_lrot"],388,[3,0,0,0,1]],[0,["_euler"],388,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],388,[1,0.5,0.5,0.5]]]],492]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2466,[5,"bcxSWrhEZCzKHG0ACV4pOX",null,[[2,"tree268",["_name"],389],[0,["_lpos"],389,[1,-213.043,0,-240.407]],[0,["_lrot"],389,[3,0,0,0,1]],[0,["_euler"],389,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],389,[1,0.5,0.5,0.5]]]],493]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2467,[5,"7dLv8JJK9NJ6IJHeUC81xT",null,[[2,"tree269",["_name"],390],[0,["_lpos"],390,[1,-199.758,0,-246.211]],[0,["_lrot"],390,[3,0,0,0,1]],[0,["_euler"],390,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],390,[1,0.5,0.5,0.5]]]],494]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2468,[5,"acJ3aCQlJDMrJkDt1ZhmG3",null,[[2,"tree270",["_name"],391],[0,["_lpos"],391,[1,-197.824,0,-242.285]],[0,["_lrot"],391,[3,0,0,0,1]],[0,["_euler"],391,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],391,[1,0.5,0.5,0.5]]]],495]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2469,[5,"e6kZwVT8FM/4RjTXthfALb",null,[[2,"tree271",["_name"],392],[0,["_lpos"],392,[1,-174.259,0,-295.542]],[0,["_lrot"],392,[3,0,0,0,1]],[0,["_euler"],392,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],392,[1,0.5,0.5,0.5]]]],496]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2470,[5,"5awRv+3j5Db7d5mD0xFFJV",null,[[2,"tree272",["_name"],393],[0,["_lpos"],393,[1,-176.193,0,-299.468]],[0,["_lrot"],393,[3,0,0,0,1]],[0,["_euler"],393,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],393,[1,0.5,0.5,0.5]]]],497]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2471,[5,"29bXnqAZtH04BGl9R+6Y53",null,[[2,"tree273",["_name"],394],[0,["_lpos"],394,[1,-189.478,0,-293.664]],[0,["_lrot"],394,[3,0,0,0,1]],[0,["_euler"],394,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],394,[1,0.5,0.5,0.5]]]],498]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2472,[5,"82jDmmr7BOwKKNOcSXGG5A",null,[[2,"tree274",["_name"],395],[0,["_lpos"],395,[1,-186.468,0,-308.823]],[0,["_lrot"],395,[3,0,0,0,1]],[0,["_euler"],395,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],395,[1,0.5,0.5,0.5]]]],499]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2473,[5,"1dQgb6yi5MfYmCA3D6dT/g",null,[[2,"tree275",["_name"],396],[0,["_lpos"],396,[1,-192.834,0,-295.942]],[0,["_lrot"],396,[3,0,0,0,1]],[0,["_euler"],396,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],396,[1,0.5,0.5,0.5]]]],500]],[4,0,null,2,[3,"d3BBkeGjhYuoyllyVyuiuL",null,null,-2474,[5,"2eCzstKoJO67vzB+E/2J8T",null,[[2,"tree276",["_name"],397],[0,["_lpos"],397,[1,-186.06,0,-301.117]],[0,["_lrot"],397,[3,0,0,0,1]],[0,["_euler"],397,[1,0,0,0]],[6,["_lpos"],[1,["88tJ49gbxc0qEBHrHAx2zJ"]],[1,0,0,0]],[0,["_lscale"],397,[1,0.5,0.5,0.5]]]],501]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2475,[5,"58BxwNsGBOB6VZ6rxMWUee",null,[[2,"tree1",["_name"],398],[0,["_lpos"],398,[1,-17.018,0,23.733]],[0,["_lrot"],398,[3,0,0,0,1]],[0,["_euler"],398,[1,0,0,0]],[0,["_lscale"],398,[1,0.5,0.5,0.5]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],503]]],502]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2476,[5,"f8cK3ghiRAqrVJN/lmOiQd",null,[[2,"tree2",["_name"],399],[0,["_lpos"],399,[1,-27.139,0,-1.119]],[0,["_lrot"],399,[3,0,0,0,1]],[0,["_euler"],399,[1,0,0,0]],[0,["_lscale"],399,[1,0.5,0.5,0.5]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],505]]],504]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2477,[5,"c1UJmQkZFJ5qMFYHLCML5s",null,[[2,"tree3",["_name"],400],[0,["_lpos"],400,[1,28.99,0,38.62]],[0,["_lrot"],400,[3,0,0,0,1]],[0,["_euler"],400,[1,0,0,0]],[0,["_lscale"],400,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],507]]],506]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2478,[5,"c8PnJWmw9JVa7jGZ41hD0H",null,[[2,"tree4",["_name"],401],[0,["_lpos"],401,[1,33.251,0,42.26]],[0,["_lrot"],401,[3,0,0,0,1]],[0,["_euler"],401,[1,0,0,0]],[0,["_lscale"],401,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],509]]],508]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2479,[5,"a4JMgFP7VKJ4hKmlcUM+wQ",null,[[2,"tree5",["_name"],402],[0,["_lpos"],402,[1,31.52,0,25.822]],[0,["_lrot"],402,[3,0,0,0,1]],[0,["_euler"],402,[1,0,0,0]],[0,["_lscale"],402,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],511]]],510]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2480,[5,"10KhOa4rZLXaoqi0WzDU8q",null,[[2,"tree6",["_name"],403],[0,["_lpos"],403,[1,30.603,0,19.27]],[0,["_lrot"],403,[3,0,0,0,1]],[0,["_euler"],403,[1,0,0,0]],[0,["_lscale"],403,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],513]]],512]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2481,[5,"f7kvK+6jRKabI40bqxGXJ6",null,[[2,"tree7",["_name"],404],[0,["_lpos"],404,[1,23.822,0,-24.886]],[0,["_lrot"],404,[3,0,0,0,1]],[0,["_euler"],404,[1,0,0,0]],[0,["_lscale"],404,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],515]]],514]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2482,[5,"04XteXxLlLYaKBLgzoWFXP",null,[[2,"tree8",["_name"],405],[0,["_lpos"],405,[1,23.822,0,-121.83]],[0,["_lrot"],405,[3,0,0,0,1]],[0,["_euler"],405,[1,0,0,0]],[0,["_lscale"],405,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],517]]],516]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2483,[5,"a0iKXQMJFM85OExds4Jali",null,[[2,"tree9",["_name"],406],[0,["_lpos"],406,[1,23.822,0,-105.389]],[0,["_lrot"],406,[3,0,0,0,1]],[0,["_euler"],406,[1,0,0,0]],[0,["_lscale"],406,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],519]]],518]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2484,[5,"91Zbzw62VMRprm1vpKtANL",null,[[2,"tree10",["_name"],407],[0,["_lpos"],407,[1,17.506,0,-166.926]],[0,["_lrot"],407,[3,0,0,0,1]],[0,["_euler"],407,[1,0,0,0]],[0,["_lscale"],407,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],521]]],520]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2485,[5,"22Fq63bPRBj6OhwcVglNkU",null,[[2,"tree11",["_name"],408],[0,["_lpos"],408,[1,-26.741,0,-80.866]],[0,["_lrot"],408,[3,0,0,0,1]],[0,["_euler"],408,[1,0,0,0]],[0,["_lscale"],408,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],523]]],522]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2486,[5,"c9F50wf5xIkI00S/wHR/Gt",null,[[2,"tree12",["_name"],409],[0,["_lpos"],409,[1,-34.731,0,-97.031]],[0,["_lrot"],409,[3,0,0,0,1]],[0,["_euler"],409,[1,0,0,0]],[0,["_lscale"],409,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],525]]],524]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2487,[5,"fdeoEdbL5M27TENpd+t4xk",null,[[2,"tree13",["_name"],410],[0,["_lpos"],410,[1,-20.946,0,-110.026]],[0,["_lrot"],410,[3,0,0,0,1]],[0,["_euler"],410,[1,0,0,0]],[0,["_lscale"],410,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],527]]],526]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2488,[5,"fcdw8bT4lJPpxoy/2ibCae",null,[[2,"tree14",["_name"],411],[0,["_lpos"],411,[1,-11.862,0,-85.2]],[0,["_lrot"],411,[3,0,0,0,1]],[0,["_euler"],411,[1,0,0,0]],[0,["_lscale"],411,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],529]]],528]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2489,[5,"96oupUQBlOq5wxYzUCEm0P",null,[[2,"tree15",["_name"],412],[0,["_lpos"],412,[1,-3.467,0,-102.05]],[0,["_lrot"],412,[3,0,0,0,1]],[0,["_euler"],412,[1,0,0,0]],[0,["_lscale"],412,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],531]]],530]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2490,[5,"1aS2dN7nZLTbn1yrx8zRSY",null,[[2,"tree16",["_name"],413],[0,["_lpos"],413,[1,-25.233,0,-122.176]],[0,["_lrot"],413,[3,0,0,0,1]],[0,["_euler"],413,[1,0,0,0]],[0,["_lscale"],413,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],533]]],532]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2491,[5,"3b0TGdiOZEF6eYsT77zZ3A",null,[[2,"tree17",["_name"],414],[0,["_lpos"],414,[1,-13.034,0,-130.167]],[0,["_lrot"],414,[3,0,0,0,1]],[0,["_euler"],414,[1,0,0,0]],[0,["_lscale"],414,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],535]]],534]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2492,[5,"43d0J6cOpFsLZiNzCvV/O9",null,[[2,"tree18",["_name"],415],[0,["_lpos"],415,[1,23.67,0,-20.076]],[0,["_lrot"],415,[3,0,0,0,1]],[0,["_euler"],415,[1,0,0,0]],[0,["_lscale"],415,[1,0.5,0.5,0.5]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],537]]],536]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2493,[5,"23wTatLzNKTabZe014Dwdu",null,[[2,"tree19",["_name"],416],[0,["_lpos"],416,[1,12.575,0,-85.29]],[0,["_lrot"],416,[3,0,0,0,1]],[0,["_euler"],416,[1,0,0,0]],[0,["_lscale"],416,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],539]]],538]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2494,[5,"35OxoFkRpIXIuo+BkqFLBn",null,[[2,"tree20",["_name"],417],[0,["_lpos"],417,[1,12.575,0,-69.96]],[0,["_lrot"],417,[3,0,0,0,1]],[0,["_euler"],417,[1,0,0,0]],[0,["_lscale"],417,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],541]]],540]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2495,[5,"fdZ+JEA85FT7AxhXvj+BDw",null,[[2,"tree21",["_name"],418],[0,["_lpos"],418,[1,12.575,0,-69.96]],[0,["_lrot"],418,[3,0,0,0,1]],[0,["_euler"],418,[1,0,0,0]],[0,["_lscale"],418,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],543]]],542]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2496,[5,"adU9DRQKlPf4KyCygHji4c",null,[[2,"tree22",["_name"],419],[0,["_lpos"],419,[1,12.575,0,-57.882]],[0,["_lrot"],419,[3,0,0,0,1]],[0,["_euler"],419,[1,0,0,0]],[0,["_lscale"],419,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],545]]],544]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2497,[5,"6aIC9y+EpEPIDhyEIaqSG7",null,[[2,"tree23",["_name"],420],[0,["_lpos"],420,[1,-2.607,0,-63.327]],[0,["_lrot"],420,[3,0,0,0,1]],[0,["_euler"],420,[1,0,0,0]],[0,["_lscale"],420,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],547]]],546]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2498,[5,"9bk1BVtQRKBpJNKtMFEBu2",null,[[2,"tree24",["_name"],421],[0,["_lpos"],421,[1,-12.599,0,-16.538]],[0,["_lrot"],421,[3,0,0,0,1]],[0,["_euler"],421,[1,0,0,0]],[0,["_lscale"],421,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],549]]],548]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2499,[5,"91x086NeFL9I6X4PWXx5xX",null,[[2,"tree25",["_name"],422],[0,["_lpos"],422,[1,-12.599,0,-16.538]],[0,["_lrot"],422,[3,0,0,0,1]],[0,["_euler"],422,[1,0,0,0]],[0,["_lscale"],422,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],551]]],550]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2500,[5,"cb3m5TWRdLIqpgE8AQM+e+",null,[[2,"tree26",["_name"],423],[0,["_lpos"],423,[1,-12.599,0,-4.46]],[0,["_lrot"],423,[3,0,0,0,1]],[0,["_euler"],423,[1,0,0,0]],[0,["_lscale"],423,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],553]]],552]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2501,[5,"64YvcI87lKnKf8Vlxc3gxb",null,[[2,"tree27",["_name"],424],[0,["_lpos"],424,[1,-27.781,0,-4.46]],[0,["_lrot"],424,[3,0,0,0,1]],[0,["_euler"],424,[1,0,0,0]],[0,["_lscale"],424,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],555]]],554]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2502,[5,"baIdIfWrROxar4Dj8HEOSE",null,[[2,"tree28",["_name"],425],[0,["_lpos"],425,[1,-84.94,0,-4.424]],[0,["_lrot"],425,[3,0,0,0,1]],[0,["_euler"],425,[1,0,0,0]],[0,["_lscale"],425,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],557]]],556]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2503,[5,"3byivvlHRNn7sWelAo/hNd",null,[[2,"tree29",["_name"],426],[0,["_lpos"],426,[1,-69.758,0,-4.424]],[0,["_lrot"],426,[3,0,0,0,1]],[0,["_euler"],426,[1,0,0,0]],[0,["_lscale"],426,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],559]]],558]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2504,[5,"b2gnUmrmtF855MazgngqoF",null,[[2,"tree30",["_name"],427],[0,["_lpos"],427,[1,-69.758,0,-16.502]],[0,["_lrot"],427,[3,0,0,0,1]],[0,["_euler"],427,[1,0,0,0]],[0,["_lscale"],427,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],561]]],560]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2505,[5,"d2lJJkrjxFVq0lZtFt8SjI",null,[[2,"tree31",["_name"],428],[0,["_lpos"],428,[1,-69.758,0,-16.502]],[0,["_lrot"],428,[3,0,0,0,1]],[0,["_euler"],428,[1,0,0,0]],[0,["_lscale"],428,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],563]]],562]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2506,[5,"44fbMfTOVENqNF+MY9KAql",null,[[2,"tree32",["_name"],429],[0,["_lpos"],429,[1,-186.594,0,-24.731]],[0,["_lrot"],429,[3,0,0,0,1]],[0,["_euler"],429,[1,0,0,0]],[0,["_lscale"],429,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],565]]],564]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2507,[5,"1a0dowTrFMl70jM6kk+tqD",null,[[2,"tree33",["_name"],430],[0,["_lpos"],430,[1,-172.379,0,-29.452]],[0,["_lrot"],430,[3,0,0,0,1]],[0,["_euler"],430,[1,0,0,0]],[0,["_lscale"],430,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],567]]],566]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2508,[5,"371cXArg1Ab68bhH5BRNlH",null,[[2,"tree34",["_name"],431],[0,["_lpos"],431,[1,-172.379,0,-17.374]],[0,["_lrot"],431,[3,0,0,0,1]],[0,["_euler"],431,[1,0,0,0]],[0,["_lscale"],431,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],569]]],568]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2509,[5,"7fN8fAaW9LBJmxXHuYy+sp",null,[[2,"tree35",["_name"],432],[0,["_lpos"],432,[1,-160.717,0,-20.421]],[0,["_lrot"],432,[3,0,0,0,1]],[0,["_euler"],432,[1,0,0,0]],[0,["_lscale"],432,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],571]]],570]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2510,[5,"daIrBuKTlEZoQ/lge6mxAj",null,[[2,"tree36",["_name"],433],[0,["_lpos"],433,[1,-114.024,0,-3.88]],[0,["_lrot"],433,[3,0,0,0,1]],[0,["_euler"],433,[1,0,0,0]],[0,["_lscale"],433,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],573]]],572]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2511,[5,"bd+EtPG3ZMrICpcSz9FOW8",null,[[2,"tree37",["_name"],434],[0,["_lpos"],434,[1,-102.23,0,-4.587]],[0,["_lrot"],434,[3,0,0,0,1]],[0,["_euler"],434,[1,0,0,0]],[0,["_lscale"],434,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],575]]],574]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2512,[5,"25gD2FgDBF9JzLY4NMVj2F",null,[[2,"tree38",["_name"],435],[0,["_lpos"],435,[1,-102.23,0,7.491]],[0,["_lrot"],435,[3,0,0,0,1]],[0,["_euler"],435,[1,0,0,0]],[0,["_lscale"],435,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],577]]],576]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2513,[5,"5e80UrE5ZHaK2Khp6DgVdW",null,[[2,"tree39",["_name"],436],[0,["_lpos"],436,[1,-90.568,0,4.444]],[0,["_lrot"],436,[3,0,0,0,1]],[0,["_euler"],436,[1,0,0,0]],[0,["_lscale"],436,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],579]]],578]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2514,[5,"6clxyMnjtOfbf7CjBGCa83",null,[[2,"tree40",["_name"],437],[0,["_lpos"],437,[1,-155.591,0,-16.393]],[0,["_lrot"],437,[3,0,0,0,1]],[0,["_euler"],437,[1,0,0,0]],[0,["_lscale"],437,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],581]]],580]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2515,[5,"dew5c8JxBFIY6DPLY7ASzd",null,[[2,"tree41",["_name"],438],[0,["_lpos"],438,[1,-166.489,0,-17.1]],[0,["_lrot"],438,[3,0,0,0,1]],[0,["_euler"],438,[1,0,0,0]],[0,["_lscale"],438,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],583]]],582]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2516,[5,"02B6X494lANo88QZyWZJ/t",null,[[2,"tree42",["_name"],439],[0,["_lpos"],439,[1,-166.489,0,-5.022]],[0,["_lrot"],439,[3,0,0,0,1]],[0,["_euler"],439,[1,0,0,0]],[0,["_lscale"],439,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],585]]],584]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2517,[5,"94Q32Mo/1PH48vYKkxBl6h",null,[[2,"tree43",["_name"],440],[0,["_lpos"],440,[1,-131.631,0,-19.079]],[0,["_lrot"],440,[3,0,0,0,1]],[0,["_euler"],440,[1,0,0,0]],[0,["_lscale"],440,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],587]]],586]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2518,[5,"7cwkn+xZ9LEK2YAhmitW14",null,[[2,"tree44",["_name"],441],[0,["_lpos"],441,[1,-116.762,0,-89.914]],[0,["_lrot"],441,[3,0,0,0,1]],[0,["_euler"],441,[1,0,0,0]],[0,["_lscale"],441,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],589]]],588]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2519,[5,"94fb+OVyxOK7SVV0xYdd54",null,[[2,"tree45",["_name"],442],[0,["_lpos"],442,[1,-128.424,0,-86.867]],[0,["_lrot"],442,[3,0,0,0,1]],[0,["_euler"],442,[1,0,0,0]],[0,["_lscale"],442,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],591]]],590]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2520,[5,"ecQuF5VstGzYmLwxZ4Rrv0",null,[[2,"tree46",["_name"],443],[0,["_lpos"],443,[1,-163.371,0,-76.105]],[0,["_lrot"],443,[3,0,0,0,1]],[0,["_euler"],443,[1,0,0,0]],[0,["_lscale"],443,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],593]]],592]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2521,[5,"e6S6tTNI9JhaafuHSI1+Ol",null,[[2,"tree47",["_name"],444],[0,["_lpos"],444,[1,-175.165,0,-75.398]],[0,["_lrot"],444,[3,0,0,0,1]],[0,["_euler"],444,[1,0,0,0]],[0,["_lscale"],444,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],595]]],594]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2522,[5,"98HwQjHzBEhY7HGMIL+btp",null,[[2,"tree48",["_name"],445],[0,["_lpos"],445,[1,-128.424,0,-100.882]],[0,["_lrot"],445,[3,0,0,0,1]],[0,["_euler"],445,[1,0,0,0]],[0,["_lscale"],445,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],597]]],596]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2523,[5,"a3rSyFifdP8oe/cytj7wxJ",null,[[2,"tree49",["_name"],446],[0,["_lpos"],446,[1,-122.744,0,-96.135]],[0,["_lrot"],446,[3,0,0,0,1]],[0,["_euler"],446,[1,0,0,0]],[0,["_lscale"],446,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],599]]],598]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2524,[5,"35MMQHG7tPBZ6JjxF8yyZS",null,[[2,"tree50",["_name"],447],[0,["_lpos"],447,[1,-117.238,0,-99.501]],[0,["_lrot"],447,[3,0,0,0,1]],[0,["_euler"],447,[1,0,0,0]],[0,["_lscale"],447,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],601]]],600]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2525,[5,"93mY/qnIFFhqNoBnyGLcVK",null,[[2,"tree51",["_name"],448],[0,["_lpos"],448,[1,-117.238,0,-109.087]],[0,["_lrot"],448,[3,0,0,0,1]],[0,["_euler"],448,[1,0,0,0]],[0,["_lscale"],448,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],603]]],602]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2526,[5,"d78YQxURVEpb5eVwX/1NKL",null,[[2,"tree52",["_name"],449],[0,["_lpos"],449,[1,-125.777,0,-109.087]],[0,["_lrot"],449,[3,0,0,0,1]],[0,["_euler"],449,[1,0,0,0]],[0,["_lscale"],449,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],605]]],604]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2527,[5,"6d8dYZlQpBC4JQZpR+SZ1S",null,[[2,"tree53",["_name"],450],[0,["_lpos"],450,[1,-122.619,0,-102.695]],[0,["_lrot"],450,[3,0,0,0,1]],[0,["_euler"],450,[1,0,0,0]],[0,["_lscale"],450,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],607]]],606]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2528,[5,"b6qfVP9MpN35qKg3MMwQ6j",null,[[2,"tree54",["_name"],451],[0,["_lpos"],451,[1,-84.71,0,-41.03]],[0,["_lrot"],451,[3,0,0,0,1]],[0,["_euler"],451,[1,0,0,0]],[0,["_lscale"],451,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],609]]],608]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2529,[5,"d4DFRC0uxFQbRZyuT4vT69",null,[[2,"tree55",["_name"],452],[0,["_lpos"],452,[1,-87.868,0,-47.422]],[0,["_lrot"],452,[3,0,0,0,1]],[0,["_euler"],452,[1,0,0,0]],[0,["_lscale"],452,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],611]]],610]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2530,[5,"b4NbxZwllG/6E75qahDXmq",null,[[2,"tree56",["_name"],453],[0,["_lpos"],453,[1,-79.329,0,-47.422]],[0,["_lrot"],453,[3,0,0,0,1]],[0,["_euler"],453,[1,0,0,0]],[0,["_lscale"],453,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],613]]],612]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2531,[5,"72r0JFLmJP5IXQlohaONwQ",null,[[2,"tree57",["_name"],454],[0,["_lpos"],454,[1,-79.329,0,-37.836]],[0,["_lrot"],454,[3,0,0,0,1]],[0,["_euler"],454,[1,0,0,0]],[0,["_lscale"],454,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],615]]],614]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2532,[5,"11iWG1QJRHK5jK5nYygXkI",null,[[2,"tree58",["_name"],455],[0,["_lpos"],455,[1,-84.835,0,-34.47]],[0,["_lrot"],455,[3,0,0,0,1]],[0,["_euler"],455,[1,0,0,0]],[0,["_lscale"],455,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],617]]],616]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2533,[5,"7coeb/EsxAUY3u5yKjCv9/",null,[[2,"tree59",["_name"],456],[0,["_lpos"],456,[1,-177.522,0,-35.534]],[0,["_lrot"],456,[3,0,0,0,1]],[0,["_euler"],456,[1,0,0,0]],[0,["_lscale"],456,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],619]]],618]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2534,[5,"e4Pg5IEbtMUrL8vtGtfj5K",null,[[2,"tree60",["_name"],457],[0,["_lpos"],457,[1,-172.016,0,-38.9]],[0,["_lrot"],457,[3,0,0,0,1]],[0,["_euler"],457,[1,0,0,0]],[0,["_lscale"],457,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],621]]],620]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2535,[5,"d6/0Ljw0pOw4sqqBrPWtK2",null,[[2,"tree61",["_name"],458],[0,["_lpos"],458,[1,-172.016,0,-48.486]],[0,["_lrot"],458,[3,0,0,0,1]],[0,["_euler"],458,[1,0,0,0]],[0,["_lscale"],458,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],623]]],622]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2536,[5,"37WEKOweNGB49OcikLe4KE",null,[[2,"tree62",["_name"],459],[0,["_lpos"],459,[1,-180.555,0,-48.486]],[0,["_lrot"],459,[3,0,0,0,1]],[0,["_euler"],459,[1,0,0,0]],[0,["_lscale"],459,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],625]]],624]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2537,[5,"9eHZJNV8FL5awO8QZmLQ3W",null,[[2,"tree63",["_name"],460],[0,["_lpos"],460,[1,-177.397,0,-42.094]],[0,["_lrot"],460,[3,0,0,0,1]],[0,["_euler"],460,[1,0,0,0]],[0,["_lscale"],460,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],627]]],626]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2538,[5,"28IA3xHo5Cyb3VFl9qoJbJ",null,[[2,"tree64",["_name"],461],[0,["_lpos"],461,[1,-185.62,0,-100.927]],[0,["_lrot"],461,[3,0,0,0,1]],[0,["_euler"],461,[1,0,0,0]],[0,["_lscale"],461,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],629]]],628]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2539,[5,"7aXLLhVStL76vl3tOEyNOe",null,[[2,"tree65",["_name"],462],[0,["_lpos"],462,[1,-188.778,0,-107.319]],[0,["_lrot"],462,[3,0,0,0,1]],[0,["_euler"],462,[1,0,0,0]],[0,["_lscale"],462,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],631]]],630]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2540,[5,"54N/tMa39PF4CtYmTvRmnW",null,[[2,"tree66",["_name"],463],[0,["_lpos"],463,[1,-180.239,0,-107.319]],[0,["_lrot"],463,[3,0,0,0,1]],[0,["_euler"],463,[1,0,0,0]],[0,["_lscale"],463,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],633]]],632]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2541,[5,"28SWTlHmBForF81ONMsvBZ",null,[[2,"tree67",["_name"],464],[0,["_lpos"],464,[1,-180.239,0,-97.733]],[0,["_lrot"],464,[3,0,0,0,1]],[0,["_euler"],464,[1,0,0,0]],[0,["_lscale"],464,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],635]]],634]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2542,[5,"0d/otiQfpBiZ1W5bMnkGRL",null,[[2,"tree68",["_name"],465],[0,["_lpos"],465,[1,-185.745,0,-94.367]],[0,["_lrot"],465,[3,0,0,0,1]],[0,["_euler"],465,[1,0,0,0]],[0,["_lscale"],465,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],637]]],636]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2543,[5,"feFI6N7atIyZ8xLKtM1spk",null,[[2,"tree69",["_name"],466],[0,["_lpos"],466,[1,-173.932,0,-144.175]],[0,["_lrot"],466,[3,0,0,0,1]],[0,["_euler"],466,[1,0,0,0]],[0,["_lscale"],466,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],639]]],638]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2544,[5,"66lzN4JYhK8aYw0+aIi7R6",null,[[2,"tree70",["_name"],467],[0,["_lpos"],467,[1,-168.426,0,-147.541]],[0,["_lrot"],467,[3,0,0,0,1]],[0,["_euler"],467,[1,0,0,0]],[0,["_lscale"],467,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],641]]],640]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2545,[5,"087f3d4ylM5IX0hsj32kzT",null,[[2,"tree71",["_name"],468],[0,["_lpos"],468,[1,-168.426,0,-157.127]],[0,["_lrot"],468,[3,0,0,0,1]],[0,["_euler"],468,[1,0,0,0]],[0,["_lscale"],468,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],643]]],642]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2546,[5,"9d7kHsmRxEaIS6xR8Hqsaw",null,[[2,"tree72",["_name"],469],[0,["_lpos"],469,[1,-176.965,0,-157.127]],[0,["_lrot"],469,[3,0,0,0,1]],[0,["_euler"],469,[1,0,0,0]],[0,["_lscale"],469,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],645]]],644]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2547,[5,"3bcSs/4epDHLGhhAbAWr8v",null,[[2,"tree73",["_name"],470],[0,["_lpos"],470,[1,-173.807,0,-150.735]],[0,["_lrot"],470,[3,0,0,0,1]],[0,["_euler"],470,[1,0,0,0]],[0,["_lscale"],470,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],647]]],646]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2548,[5,"c2BKcaCvhGgqPJ+bops78w",null,[[2,"tree74",["_name"],471],[0,["_lpos"],471,[1,-127.985,0,-177.596]],[0,["_lrot"],471,[3,0,0,0,1]],[0,["_euler"],471,[1,0,0,0]],[0,["_lscale"],471,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],649]]],648]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2549,[5,"25Vt2mNMRO26iAFBeVHZiB",null,[[2,"tree75",["_name"],472],[0,["_lpos"],472,[1,-131.143,0,-183.988]],[0,["_lrot"],472,[3,0,0,0,1]],[0,["_euler"],472,[1,0,0,0]],[0,["_lscale"],472,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],651]]],650]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2550,[5,"69Uf90f71GU5ykFkrcp03y",null,[[2,"tree76",["_name"],473],[0,["_lpos"],473,[1,-122.604,0,-183.988]],[0,["_lrot"],473,[3,0,0,0,1]],[0,["_euler"],473,[1,0,0,0]],[0,["_lscale"],473,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],653]]],652]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2551,[5,"48WrdHK5tCeLdAL8hEPFcr",null,[[2,"tree77",["_name"],474],[0,["_lpos"],474,[1,-122.604,0,-174.402]],[0,["_lrot"],474,[3,0,0,0,1]],[0,["_euler"],474,[1,0,0,0]],[0,["_lscale"],474,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],655]]],654]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2552,[5,"b0qdu8If1Ly4ejrtpCKFQs",null,[[2,"tree78",["_name"],475],[0,["_lpos"],475,[1,-128.11,0,-171.036]],[0,["_lrot"],475,[3,0,0,0,1]],[0,["_euler"],475,[1,0,0,0]],[0,["_lscale"],475,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],657]]],656]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2553,[5,"61bcyOUqtCda6uFSzPnG4C",null,[[2,"tree79",["_name"],476],[0,["_lpos"],476,[1,-115.257,0,-174.76]],[0,["_lrot"],476,[3,0,0,0,1]],[0,["_euler"],476,[1,0,0,0]],[0,["_lscale"],476,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],659]]],658]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2554,[5,"04VCmmQnJJjJZGtNCSVKC/",null,[[2,"tree80",["_name"],477],[0,["_lpos"],477,[1,-109.751,0,-178.126]],[0,["_lrot"],477,[3,0,0,0,1]],[0,["_euler"],477,[1,0,0,0]],[0,["_lscale"],477,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],661]]],660]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2555,[5,"a29a4VH2hEH4hH8hmHiy9A",null,[[2,"tree81",["_name"],478],[0,["_lpos"],478,[1,-109.751,0,-187.712]],[0,["_lrot"],478,[3,0,0,0,1]],[0,["_euler"],478,[1,0,0,0]],[0,["_lscale"],478,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],663]]],662]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2556,[5,"43kyjsBtlL4rip34HI/mo1",null,[[2,"tree82",["_name"],479],[0,["_lpos"],479,[1,-118.29,0,-187.712]],[0,["_lrot"],479,[3,0,0,0,1]],[0,["_euler"],479,[1,0,0,0]],[0,["_lscale"],479,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],665]]],664]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2557,[5,"6aqvwp40hLE5VUphlntG0c",null,[[2,"tree83",["_name"],480],[0,["_lpos"],480,[1,-115.132,0,-181.32]],[0,["_lrot"],480,[3,0,0,0,1]],[0,["_euler"],480,[1,0,0,0]],[0,["_lscale"],480,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],667]]],666]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2558,[5,"b5gZDlJe5L3b2QIs+f9c3/",null,[[2,"tree84",["_name"],481],[0,["_lpos"],481,[1,-108.6,0,-147.011]],[0,["_lrot"],481,[3,0,0,0,1]],[0,["_euler"],481,[1,0,0,0]],[0,["_lscale"],481,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],669]]],668]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2559,[5,"459x4mw4BDRIZlfQLMl+e/",null,[[2,"tree85",["_name"],482],[0,["_lpos"],482,[1,-111.758,0,-153.403]],[0,["_lrot"],482,[3,0,0,0,1]],[0,["_euler"],482,[1,0,0,0]],[0,["_lscale"],482,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],671]]],670]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2560,[5,"770/SHcDlLArml97UBGM3a",null,[[2,"tree86",["_name"],483],[0,["_lpos"],483,[1,-103.219,0,-153.403]],[0,["_lrot"],483,[3,0,0,0,1]],[0,["_euler"],483,[1,0,0,0]],[0,["_lscale"],483,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],673]]],672]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2561,[5,"ef52f4pspI0JrEGw3axzoF",null,[[2,"tree87",["_name"],484],[0,["_lpos"],484,[1,-103.219,0,-143.817]],[0,["_lrot"],484,[3,0,0,0,1]],[0,["_euler"],484,[1,0,0,0]],[0,["_lscale"],484,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],675]]],674]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2562,[5,"1aMRieqyRAGrMhU8aHspUt",null,[[2,"tree88",["_name"],485],[0,["_lpos"],485,[1,-108.725,0,-140.451]],[0,["_lrot"],485,[3,0,0,0,1]],[0,["_euler"],485,[1,0,0,0]],[0,["_lscale"],485,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],677]]],676]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2563,[5,"beVN+fMUFNL5t/6/U668qP",null,[[2,"tree89",["_name"],486],[0,["_lpos"],486,[1,-101.715,0,-168.538]],[0,["_lrot"],486,[3,0,0,0,1]],[0,["_euler"],486,[1,0,0,0]],[0,["_lscale"],486,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],679]]],678]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2564,[5,"d1bhElOzRBVKEzTnJGhuPt",null,[[2,"tree90",["_name"],487],[0,["_lpos"],487,[1,-96.209,0,-171.904]],[0,["_lrot"],487,[3,0,0,0,1]],[0,["_euler"],487,[1,0,0,0]],[0,["_lscale"],487,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],681]]],680]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2565,[5,"14bv+M6xxAnYE6tdPFWM0m",null,[[2,"tree91",["_name"],488],[0,["_lpos"],488,[1,-96.209,0,-181.49]],[0,["_lrot"],488,[3,0,0,0,1]],[0,["_euler"],488,[1,0,0,0]],[0,["_lscale"],488,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],683]]],682]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2566,[5,"04jSdYsxVGHYJom4A1IlXI",null,[[2,"tree92",["_name"],489],[0,["_lpos"],489,[1,-104.748,0,-181.49]],[0,["_lrot"],489,[3,0,0,0,1]],[0,["_euler"],489,[1,0,0,0]],[0,["_lscale"],489,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],685]]],684]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2567,[5,"a4qG8jvCtGfZYAHMoRvIJ0",null,[[2,"tree93",["_name"],490],[0,["_lpos"],490,[1,-101.59,0,-175.098]],[0,["_lrot"],490,[3,0,0,0,1]],[0,["_euler"],490,[1,0,0,0]],[0,["_lscale"],490,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],687]]],686]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2568,[5,"16Gw0VIytL9LsOrzh+Xb+j",null,[[2,"tree94",["_name"],491],[0,["_lpos"],491,[1,-123.144,0,-247.047]],[0,["_lrot"],491,[3,0,0,0,1]],[0,["_euler"],491,[1,0,0,0]],[0,["_lscale"],491,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],689]]],688]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2569,[5,"30uRS7Hz9PRb0GuIpelrSI",null,[[2,"tree95",["_name"],492],[0,["_lpos"],492,[1,-126.302,0,-253.439]],[0,["_lrot"],492,[3,0,0,0,1]],[0,["_euler"],492,[1,0,0,0]],[0,["_lscale"],492,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],691]]],690]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2570,[5,"8dJ9k3ijhDCr4BnFcx5Yua",null,[[2,"tree96",["_name"],493],[0,["_lpos"],493,[1,-117.763,0,-253.439]],[0,["_lrot"],493,[3,0,0,0,1]],[0,["_euler"],493,[1,0,0,0]],[0,["_lscale"],493,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],693]]],692]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2571,[5,"7fVmETYHFLhaW7+Vn2Cihk",null,[[2,"tree97",["_name"],494],[0,["_lpos"],494,[1,-117.763,0,-243.853]],[0,["_lrot"],494,[3,0,0,0,1]],[0,["_euler"],494,[1,0,0,0]],[0,["_lscale"],494,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],695]]],694]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2572,[5,"635WqlRqRJIovJg6wCxPD4",null,[[2,"tree98",["_name"],495],[0,["_lpos"],495,[1,-123.269,0,-240.487]],[0,["_lrot"],495,[3,0,0,0,1]],[0,["_euler"],495,[1,0,0,0]],[0,["_lscale"],495,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],697]]],696]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2573,[5,"f6zR0Q2rFJSIEoc/kWDwIe",null,[[2,"tree99",["_name"],496],[0,["_lpos"],496,[1,-108.255,0,-241.293]],[0,["_lrot"],496,[3,0,0,0,1]],[0,["_euler"],496,[1,0,0,0]],[0,["_lscale"],496,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],699]]],698]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2574,[5,"c2Y0dEzGJKQKear5VUkgVD",null,[[2,"tree100",["_name"],497],[0,["_lpos"],497,[1,-102.749,0,-244.659]],[0,["_lrot"],497,[3,0,0,0,1]],[0,["_euler"],497,[1,0,0,0]],[0,["_lscale"],497,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],701]]],700]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2575,[5,"9e4lyKI29Oo4nVOtvtpFys",null,[[2,"tree101",["_name"],498],[0,["_lpos"],498,[1,-102.749,0,-254.245]],[0,["_lrot"],498,[3,0,0,0,1]],[0,["_euler"],498,[1,0,0,0]],[0,["_lscale"],498,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],703]]],702]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2576,[5,"46RY077kJN0Lyg/mmL+F5b",null,[[2,"tree102",["_name"],499],[0,["_lpos"],499,[1,-111.288,0,-254.245]],[0,["_lrot"],499,[3,0,0,0,1]],[0,["_euler"],499,[1,0,0,0]],[0,["_lscale"],499,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],705]]],704]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2577,[5,"4bhwgfubNCiLRDIiACjNiO",null,[[2,"tree103",["_name"],500],[0,["_lpos"],500,[1,-108.13,0,-247.853]],[0,["_lrot"],500,[3,0,0,0,1]],[0,["_euler"],500,[1,0,0,0]],[0,["_lscale"],500,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],707]]],706]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2578,[5,"92NFTGfE5Jg7GCGHjgvIiI",null,[[2,"tree104",["_name"],501],[0,["_lpos"],501,[1,-161.242,0,-236.207]],[0,["_lrot"],501,[3,0,0,0,1]],[0,["_euler"],501,[1,0,0,0]],[0,["_lscale"],501,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],709]]],708]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2579,[5,"734SOFFDZMo5WFOxekN7qo",null,[[2,"tree105",["_name"],502],[0,["_lpos"],502,[1,-155.736,0,-239.573]],[0,["_lrot"],502,[3,0,0,0,1]],[0,["_euler"],502,[1,0,0,0]],[0,["_lscale"],502,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],711]]],710]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2580,[5,"89o4OYGclHL5Gabh0DaeXq",null,[[2,"tree106",["_name"],503],[0,["_lpos"],503,[1,-155.736,0,-249.159]],[0,["_lrot"],503,[3,0,0,0,1]],[0,["_euler"],503,[1,0,0,0]],[0,["_lscale"],503,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],713]]],712]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2581,[5,"2euceu+5NBQL3g7V90c05W",null,[[2,"tree107",["_name"],504],[0,["_lpos"],504,[1,-164.275,0,-249.159]],[0,["_lrot"],504,[3,0,0,0,1]],[0,["_euler"],504,[1,0,0,0]],[0,["_lscale"],504,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],715]]],714]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2582,[5,"e87f+axFNFlbQVoqn8Qwcd",null,[[2,"tree108",["_name"],505],[0,["_lpos"],505,[1,-161.117,0,-242.767]],[0,["_lrot"],505,[3,0,0,0,1]],[0,["_euler"],505,[1,0,0,0]],[0,["_lscale"],505,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],717]]],716]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2583,[5,"edRl/RuEtBDaywJaR6kSlg",null,[[2,"tree109",["_name"],506],[0,["_lpos"],506,[1,-182.862,0,-248.258]],[0,["_lrot"],506,[3,0,0,0,1]],[0,["_euler"],506,[1,0,0,0]],[0,["_lscale"],506,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],719]]],718]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2584,[5,"2cj/0v41lEUqVYyVz7IXW3",null,[[2,"tree110",["_name"],507],[0,["_lpos"],507,[1,-186.02,0,-254.65]],[0,["_lrot"],507,[3,0,0,0,1]],[0,["_euler"],507,[1,0,0,0]],[0,["_lscale"],507,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],721]]],720]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2585,[5,"38UzSt6RNBhZM4FKFLQtk+",null,[[2,"tree111",["_name"],508],[0,["_lpos"],508,[1,-177.481,0,-254.65]],[0,["_lrot"],508,[3,0,0,0,1]],[0,["_euler"],508,[1,0,0,0]],[0,["_lscale"],508,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],723]]],722]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2586,[5,"edgm15TE1L5IFfkoGRtcea",null,[[2,"tree112",["_name"],509],[0,["_lpos"],509,[1,-177.481,0,-245.064]],[0,["_lrot"],509,[3,0,0,0,1]],[0,["_euler"],509,[1,0,0,0]],[0,["_lscale"],509,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],725]]],724]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2587,[5,"dbHB56S9dBf4IzlVIukBrl",null,[[2,"tree113",["_name"],510],[0,["_lpos"],510,[1,-182.987,0,-241.698]],[0,["_lrot"],510,[3,0,0,0,1]],[0,["_euler"],510,[1,0,0,0]],[0,["_lscale"],510,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],727]]],726]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2588,[5,"3144XJPCJMSJQv6vkesKn8",null,[[2,"tree114",["_name"],511],[0,["_lpos"],511,[1,-189.416,0,-272.949]],[0,["_lrot"],511,[3,0,0,0,1]],[0,["_euler"],511,[1,0,0,0]],[0,["_lscale"],511,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],729]]],728]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2589,[5,"9d4U7ka4VCS4JAUVzzWb1q",null,[[2,"tree115",["_name"],512],[0,["_lpos"],512,[1,-183.91,0,-276.315]],[0,["_lrot"],512,[3,0,0,0,1]],[0,["_euler"],512,[1,0,0,0]],[0,["_lscale"],512,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],731]]],730]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2590,[5,"587rgL9FtOmpnQyU7ga9Xj",null,[[2,"tree116",["_name"],513],[0,["_lpos"],513,[1,-183.91,0,-285.901]],[0,["_lrot"],513,[3,0,0,0,1]],[0,["_euler"],513,[1,0,0,0]],[0,["_lscale"],513,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],733]]],732]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2591,[5,"f558e75D5KWrzc3RpCRVtf",null,[[2,"tree117",["_name"],514],[0,["_lpos"],514,[1,-192.449,0,-285.901]],[0,["_lrot"],514,[3,0,0,0,1]],[0,["_euler"],514,[1,0,0,0]],[0,["_lscale"],514,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],735]]],734]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2592,[5,"95NEbas7xOI7nufEYerphW",null,[[2,"tree118",["_name"],515],[0,["_lpos"],515,[1,-189.291,0,-279.509]],[0,["_lrot"],515,[3,0,0,0,1]],[0,["_euler"],515,[1,0,0,0]],[0,["_lscale"],515,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],737]]],736]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2593,[5,"43xOVcWelGMrjXV3IdKS+l",null,[[2,"tree119",["_name"],516],[0,["_lpos"],516,[1,-180.66,0,-306.615]],[0,["_lrot"],516,[3,0,0,0,1]],[0,["_euler"],516,[1,0,0,0]],[0,["_lscale"],516,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],739]]],738]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2594,[5,"c6r8yiKZ9DkrlzPWKqaUyj",null,[[2,"tree120",["_name"],517],[0,["_lpos"],517,[1,-183.818,0,-313.007]],[0,["_lrot"],517,[3,0,0,0,1]],[0,["_euler"],517,[1,0,0,0]],[0,["_lscale"],517,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],741]]],740]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2595,[5,"c1BQi3AQdN+abdvtjtnX3R",null,[[2,"tree121",["_name"],518],[0,["_lpos"],518,[1,-175.279,0,-313.007]],[0,["_lrot"],518,[3,0,0,0,1]],[0,["_euler"],518,[1,0,0,0]],[0,["_lscale"],518,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],743]]],742]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2596,[5,"8ew+IQmlVA34Mej8Op9lT2",null,[[2,"tree122",["_name"],519],[0,["_lpos"],519,[1,-175.279,0,-303.421]],[0,["_lrot"],519,[3,0,0,0,1]],[0,["_euler"],519,[1,0,0,0]],[0,["_lscale"],519,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],745]]],744]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2597,[5,"bdMButVSlOPqdS8Lybw+VA",null,[[2,"tree123",["_name"],520],[0,["_lpos"],520,[1,-180.785,0,-300.055]],[0,["_lrot"],520,[3,0,0,0,1]],[0,["_euler"],520,[1,0,0,0]],[0,["_lscale"],520,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],747]]],746]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2598,[5,"6bhUFG9gJGmLHMnBj6ftoH",null,[[2,"tree124",["_name"],521],[0,["_lpos"],521,[1,-131.594,0,-316.149]],[0,["_lrot"],521,[3,0,0,0,1]],[0,["_euler"],521,[1,0,0,0]],[0,["_lscale"],521,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],749]]],748]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2599,[5,"eeGcM3YMxOE4QtdwOwioAh",null,[[2,"tree125",["_name"],522],[0,["_lpos"],522,[1,-126.088,0,-319.515]],[0,["_lrot"],522,[3,0,0,0,1]],[0,["_euler"],522,[1,0,0,0]],[0,["_lscale"],522,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],751]]],750]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2600,[5,"09AKKAykpGrrI0cMsbzH1k",null,[[2,"tree126",["_name"],523],[0,["_lpos"],523,[1,-126.088,0,-329.101]],[0,["_lrot"],523,[3,0,0,0,1]],[0,["_euler"],523,[1,0,0,0]],[0,["_lscale"],523,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],753]]],752]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2601,[5,"5dIp1/n/RMAYLjA9o4h0rO",null,[[2,"tree127",["_name"],524],[0,["_lpos"],524,[1,-134.627,0,-329.101]],[0,["_lrot"],524,[3,0,0,0,1]],[0,["_euler"],524,[1,0,0,0]],[0,["_lscale"],524,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],755]]],754]],[4,512,null,3,[3,"190htkDPdRkobYqiVDMX6F",null,null,-2602,[5,"9eyBYHs3tNMqNeMVNkBuXw",null,[[2,"tree128",["_name"],525],[0,["_lpos"],525,[1,-131.469,0,-322.709]],[0,["_lrot"],525,[3,0,0,0,1]],[0,["_euler"],525,[1,0,0,0]],[0,["_lscale"],525,[1,1,1,1]],[7,["_mesh"],[1,["21fB9uDHVWrLfuJ0fmHi5C"]],757]]],756]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2603,[5,"ceHTR1qt1MXLINqxeV4gj5",null,[[2,"cao",["_name"],570],[0,["_lpos"],570,[1,21.065,0,-25.753]],[0,["_lrot"],570,[3,0,0,0,1]],[0,["_euler"],570,[1,0,0,0]]]],758]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2604,[5,"b9WDSxCTxN2oo4q6UN+kGN",null,[[2,"cao-001",["_name"],571],[0,["_lpos"],571,[1,18.291,0,-19.975]],[0,["_lrot"],571,[3,0,0,0,1]],[0,["_euler"],571,[1,0,0,0]]]],759]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2605,[5,"13ManYep5LiJJNSt8tOWxS",null,[[2,"cao-002",["_name"],572],[0,["_lpos"],572,[1,24.193,0,-23.525]],[0,["_lrot"],572,[3,0,0,0,1]],[0,["_euler"],572,[1,0,0,0]]]],760]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2606,[5,"439hNWkN1DjoEXjlH9souH",null,[[2,"cao-003",["_name"],573],[0,["_lpos"],573,[1,2.169,0,-59.059]],[0,["_lrot"],573,[3,0,0,0,1]],[0,["_euler"],573,[1,0,0,0]]]],761]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2607,[5,"31awwO1bVGyY3UNgU7XlaU",null,[[2,"cao-004",["_name"],574],[0,["_lpos"],574,[1,-3.938,0,-68.827]],[0,["_lrot"],574,[3,0,0,0,1]],[0,["_euler"],574,[1,0,0,0]]]],762]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2608,[5,"1dk342GxNLZLRHMqpHsKOc",null,[[2,"cao-005",["_name"],575],[0,["_lpos"],575,[1,6.655,0,-89.449]],[0,["_lrot"],575,[3,0,0,0,1]],[0,["_euler"],575,[1,0,0,0]]]],763]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2609,[5,"df8bq3YJpFpJQa8DmgcJoj",null,[[2,"cao-006",["_name"],576],[0,["_lpos"],576,[1,-12.869,0,-84.147]],[0,["_lrot"],576,[3,0,0,0,1]],[0,["_euler"],576,[1,0,0,0]]]],764]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2610,[5,"24nh705uRCcJYjYLS7GB5A",null,[[2,"cao-007",["_name"],577],[0,["_lpos"],577,[1,-26.45,0,-73.232]],[0,["_lrot"],577,[3,0,0,0,1]],[0,["_euler"],577,[1,0,0,0]]]],765]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2611,[5,"feVD4+0zxDzKjz62tiALIa",null,[[2,"cao-008",["_name"],578],[0,["_lpos"],578,[1,-29.827,0,-80.223]],[0,["_lrot"],578,[3,0,0,0,1]],[0,["_euler"],578,[1,0,0,0]]]],766]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2612,[5,"14ECDxHUBIjLhAw89R7iab",null,[[2,"cao-009",["_name"],579],[0,["_lpos"],579,[1,-10.603,0,-82.441]],[0,["_lrot"],579,[3,0,0,0,1]],[0,["_euler"],579,[1,0,0,0]]]],767]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2613,[5,"efk2to6ZlMdoIO604xp33d",null,[[2,"cao-010",["_name"],580],[0,["_lpos"],580,[1,-18.298,0,-70.072]],[0,["_lrot"],580,[3,0,0,0,1]],[0,["_euler"],580,[1,0,0,0]]]],768]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2614,[5,"45iuiSi/VA2IxWTzKr5X9k",null,[[2,"cao-011",["_name"],581],[0,["_lpos"],581,[1,-7.924,0,-68.03]],[0,["_lrot"],581,[3,0,0,0,1]],[0,["_euler"],581,[1,0,0,0]]]],769]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2615,[5,"d3iafFLO1OgIoxBAbT22v1",null,[[2,"cao-012",["_name"],582],[0,["_lpos"],582,[1,-19.193,0,-93.015]],[0,["_lrot"],582,[3,0,0,0,1]],[0,["_euler"],582,[1,0,0,0]]]],770]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2616,[5,"12EHKU9kNGW4zMI2Ah7hVu",null,[[2,"cao-013",["_name"],583],[0,["_lpos"],583,[1,-25.632,0,-107.293]],[0,["_lrot"],583,[3,0,0,0,1]],[0,["_euler"],583,[1,0,0,0]]]],771]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2617,[5,"d67CIS+xdCJZgCM4O6393b",null,[[2,"cao-014",["_name"],584],[0,["_lpos"],584,[1,-33.823,0,-96.683]],[0,["_lrot"],584,[3,0,0,0,1]],[0,["_euler"],584,[1,0,0,0]]]],772]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2618,[5,"7cDL3FiqlCQZ51NVDURd7W",null,[[2,"cao-015",["_name"],585],[0,["_lpos"],585,[1,-9.411,0,-110.504]],[0,["_lrot"],585,[3,0,0,0,1]],[0,["_euler"],585,[1,0,0,0]]]],773]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2619,[5,"5b9aGca7hLFZZoab2DTYGG",null,[[2,"cao-016",["_name"],586],[0,["_lpos"],586,[1,-2.979,0,-101.529]],[0,["_lrot"],586,[3,0,0,0,1]],[0,["_euler"],586,[1,0,0,0]]]],774]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2620,[5,"314Bey4CVPrq1zq4IFaW5O",null,[[2,"cao-017",["_name"],587],[0,["_lpos"],587,[1,-13.567,0,-127.882]],[0,["_lrot"],587,[3,0,0,0,1]],[0,["_euler"],587,[1,0,0,0]]]],775]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2621,[5,"78s1pxRplHdaDBn04K/UJt",null,[[2,"cao-018",["_name"],588],[0,["_lpos"],588,[1,-19.773,0,-36.704]],[0,["_lrot"],588,[3,0,0,0,1]],[0,["_euler"],588,[1,0,0,0]]]],776]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2622,[5,"bd6sB7HZhME4ZGy2zIehpd",null,[[2,"cao-019",["_name"],589],[0,["_lpos"],589,[1,-30.666,0,-39.976]],[0,["_lrot"],589,[3,0,0,0,1]],[0,["_euler"],589,[1,0,0,0]]]],777]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2623,[5,"84kJA52mRAfY4wZFZPhH44",null,[[2,"cao-020",["_name"],590],[0,["_lpos"],590,[1,-31.789,0,-48.637]],[0,["_lrot"],590,[3,0,0,0,1]],[0,["_euler"],590,[1,0,0,0]]]],778]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2624,[5,"d3GR0s/KRAQJNWPLPF8rSu",null,[[2,"cao-021",["_name"],591],[0,["_lpos"],591,[1,-39.081,0,-32.492]],[0,["_lrot"],591,[3,0,0,0,1]],[0,["_euler"],591,[1,0,0,0]]]],779]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2625,[5,"05bUjN9NFFT6Huf7DfYgr8",null,[[2,"cao-022",["_name"],592],[0,["_lpos"],592,[1,-40.708,0,-6.413]],[0,["_lrot"],592,[3,0,0,0,1]],[0,["_euler"],592,[1,0,0,0]]]],780]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2626,[5,"b08nBWRdxJyZbS4/vUBf+l",null,[[2,"cao-023",["_name"],593],[0,["_lpos"],593,[1,-17.163,0,-7.652]],[0,["_lrot"],593,[3,0,0,0,1]],[0,["_euler"],593,[1,0,0,0]]]],781]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2627,[5,"78L6BUGVlC6IoMvY7AgkGl",null,[[2,"cao-024",["_name"],594],[0,["_lpos"],594,[1,-26.458,0,0.9]],[0,["_lrot"],594,[3,0,0,0,1]],[0,["_euler"],594,[1,0,0,0]]]],782]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2628,[5,"30WjPFAYhB1boVnRdQqC+4",null,[[2,"cao-025",["_name"],595],[0,["_lpos"],595,[1,-22.483,0,31.068]],[0,["_lrot"],595,[3,0,0,0,1]],[0,["_euler"],595,[1,0,0,0]]]],783]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2629,[5,"f03A61+IJIQ7cEFM/tuh4G",null,[[2,"cao-026",["_name"],596],[0,["_lpos"],596,[1,-16.668,0,20.96]],[0,["_lrot"],596,[3,0,0,0,1]],[0,["_euler"],596,[1,0,0,0]]]],784]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2630,[5,"09k+GyMjRKmYZtbJVxfkao",null,[[2,"cao-027",["_name"],597],[0,["_lpos"],597,[1,-4.645,0,14.574]],[0,["_lrot"],597,[3,0,0,0,1]],[0,["_euler"],597,[1,0,0,0]]]],785]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2631,[5,"12NBI8GNpOGYMMyEQg/TKE",null,[[2,"cao-028",["_name"],598],[0,["_lpos"],598,[1,-14.745,0,-5.3]],[0,["_lrot"],598,[3,0,0,0,1]],[0,["_euler"],598,[1,0,0,0]]]],786]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2632,[5,"9d8mbYk6ZADI2J+ZucCS0D",null,[[2,"cao-029",["_name"],599],[0,["_lpos"],599,[1,-5.815,0,-13.791]],[0,["_lrot"],599,[3,0,0,0,1]],[0,["_euler"],599,[1,0,0,0]]]],787]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2633,[5,"f7jsf9zZZKNrr3F+i3GYqR",null,[[2,"cao-030",["_name"],600],[0,["_lpos"],600,[1,-23.338,0,13.598]],[0,["_lrot"],600,[3,0,0,0,1]],[0,["_euler"],600,[1,0,0,0]]]],788]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2634,[5,"7bTqf7k0VIcp/4OOqMLgGL",null,[[2,"cao-031",["_name"],601],[0,["_lpos"],601,[1,-38.294,0,-2.57]],[0,["_lrot"],601,[3,0,0,0,1]],[0,["_euler"],601,[1,0,0,0]]]],789]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2635,[5,"7fxLnRhrJIXIrG7BF3hjfa",null,[[2,"cao-032",["_name"],602],[0,["_lpos"],602,[1,-38.975,0,-11.602]],[0,["_lrot"],602,[3,0,0,0,1]],[0,["_euler"],602,[1,0,0,0]]]],790]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2636,[5,"24KNm/pCtIypBkeU0jMZXM",null,[[2,"cao-033",["_name"],603],[0,["_lpos"],603,[1,-36.711,0,-23.493]],[0,["_lrot"],603,[3,0,0,0,1]],[0,["_euler"],603,[1,0,0,0]]]],791]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2637,[5,"8evBODNKhHEZz5x4b22ws/",null,[[2,"cao-034",["_name"],604],[0,["_lpos"],604,[1,-26.96,0,-21.846]],[0,["_lrot"],604,[3,0,0,0,1]],[0,["_euler"],604,[1,0,0,0]]]],792]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2638,[5,"eezQ03q3lMaqg+jaRoIUrZ",null,[[2,"cao-035",["_name"],605],[0,["_lpos"],605,[1,-31.516,0,-14.518]],[0,["_lrot"],605,[3,0,0,0,1]],[0,["_euler"],605,[1,0,0,0]]]],793]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2639,[5,"3fE1/XpfVMrLnxgfG5Nlqk",null,[[2,"cao-036",["_name"],606],[0,["_lpos"],606,[1,-18.542,0,-21.721]],[0,["_lrot"],606,[3,0,0,0,1]],[0,["_euler"],606,[1,0,0,0]]]],794]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2640,[5,"f27nlO9VdIaIHsQWJ9aFXE",null,[[2,"cao-037",["_name"],607],[0,["_lpos"],607,[1,-26.71,0,-31.344]],[0,["_lrot"],607,[3,0,0,0,1]],[0,["_euler"],607,[1,0,0,0]]]],795]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2641,[5,"85ARcO/0ZCMqw9WrMDd2Kc",null,[[2,"cao-038",["_name"],608],[0,["_lpos"],608,[1,-15.092,0,-29.999]],[0,["_lrot"],608,[3,0,0,0,1]],[0,["_euler"],608,[1,0,0,0]]]],796]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2642,[5,"1dgKPvgx1EGKF18/pWECJX",null,[[2,"cao-039",["_name"],609],[0,["_lpos"],609,[1,-9.607,0,-4.118]],[0,["_lrot"],609,[3,0,0,0,1]],[0,["_euler"],609,[1,0,0,0]]]],797]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2643,[5,"1aHd/DewxGK7/tEiPhikIR",null,[[2,"cao-040",["_name"],610],[0,["_lpos"],610,[1,-9.607,0,-4.118]],[0,["_lrot"],610,[3,0,0,0,1]],[0,["_euler"],610,[1,0,0,0]]]],798]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2644,[5,"87qX6X0xZK2Z70RGbDK462",null,[[2,"cao-041",["_name"],611],[0,["_lpos"],611,[1,5.791,0,-67.568]],[0,["_lrot"],611,[3,0,0,0,1]],[0,["_euler"],611,[1,0,0,0]]]],799]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2645,[5,"faNGJMUhtKYYoSCk9bgO44",null,[[2,"cao-042",["_name"],612],[0,["_lpos"],612,[1,8.947,0,-67.996]],[0,["_lrot"],612,[3,0,0,0,1]],[0,["_euler"],612,[1,0,0,0]]]],800]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2646,[5,"e1c/WiRz5N6LrRnQg+OWHw",null,[[2,"cao-043",["_name"],613],[0,["_lpos"],613,[1,5.969,0,-62.081]],[0,["_lrot"],613,[3,0,0,0,1]],[0,["_euler"],613,[1,0,0,0]]]],801]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2647,[5,"7aHArHYCRAFaDFRMPiD2kP",null,[[2,"cao-044",["_name"],614],[0,["_lpos"],614,[1,8.095,0,-63.833]],[0,["_lrot"],614,[3,0,0,0,1]],[0,["_euler"],614,[1,0,0,0]]]],802]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2648,[5,"dadWkkNyJAPbBupy5UJUdb",null,[[2,"cao-045",["_name"],615],[0,["_lpos"],615,[1,3.142,0,-66.614]],[0,["_lrot"],615,[3,0,0,0,1]],[0,["_euler"],615,[1,0,0,0]]]],803]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2649,[5,"26M4FBvDdGFbYmrVVxy4Fe",null,[[2,"cao-046",["_name"],616],[0,["_lpos"],616,[1,-10.661,0,5.737]],[0,["_lrot"],616,[3,0,0,0,1]],[0,["_euler"],616,[1,0,0,0]]]],804]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2650,[5,"616OS4R8RABaO/wxAwBEIv",null,[[2,"cao-047",["_name"],617],[0,["_lpos"],617,[1,-7.505,0,5.309]],[0,["_lrot"],617,[3,0,0,0,1]],[0,["_euler"],617,[1,0,0,0]]]],805]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2651,[5,"74URPYx/9AzaX/PhuEq2RL",null,[[2,"cao-048",["_name"],618],[0,["_lpos"],618,[1,-10.483,0,11.224]],[0,["_lrot"],618,[3,0,0,0,1]],[0,["_euler"],618,[1,0,0,0]]]],806]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2652,[5,"7aS1DGZNhCzKNERfI0FpDH",null,[[2,"cao-049",["_name"],619],[0,["_lpos"],619,[1,-8.357,0,9.472]],[0,["_lrot"],619,[3,0,0,0,1]],[0,["_euler"],619,[1,0,0,0]]]],807]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2653,[5,"35JlbuW7FOeqRh3AIK6T0M",null,[[2,"cao-050",["_name"],620],[0,["_lpos"],620,[1,-13.31,0,6.691]],[0,["_lrot"],620,[3,0,0,0,1]],[0,["_euler"],620,[1,0,0,0]]]],808]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2654,[5,"9aK0cG16BLK4gqxTpQzIVP",null,[[2,"cao-051",["_name"],621],[0,["_lpos"],621,[1,-71.92,0,-48.463]],[0,["_lrot"],621,[3,0,0,0,1]],[0,["_euler"],621,[1,0,0,0]]]],809]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2655,[5,"06Gfdn5WtLervDLcQPQmRF",null,[[2,"cao-052",["_name"],622],[0,["_lpos"],622,[1,-66.967,0,-45.682]],[0,["_lrot"],622,[3,0,0,0,1]],[0,["_euler"],622,[1,0,0,0]]]],810]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2656,[5,"8cB1VdiRFJHLiX+TtYBl4y",null,[[2,"cao-053",["_name"],623],[0,["_lpos"],623,[1,-69.093,0,-43.93]],[0,["_lrot"],623,[3,0,0,0,1]],[0,["_euler"],623,[1,0,0,0]]]],811]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2657,[5,"b80I/5ebFDgbTsXjcCzpNw",null,[[2,"cao-054",["_name"],624],[0,["_lpos"],624,[1,-66.115,0,-49.845]],[0,["_lrot"],624,[3,0,0,0,1]],[0,["_euler"],624,[1,0,0,0]]]],812]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2658,[5,"60XQjahhpJqaY3XJwid2kx",null,[[2,"cao-055",["_name"],625],[0,["_lpos"],625,[1,-69.271,0,-49.417]],[0,["_lrot"],625,[3,0,0,0,1]],[0,["_euler"],625,[1,0,0,0]]]],813]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2659,[5,"5cK0Dd4LxO+IyZeNWTE2j0",null,[[2,"cao-056",["_name"],626],[0,["_lpos"],626,[1,-82.725,0,-49.648]],[0,["_lrot"],626,[3,0,0,0,1]],[0,["_euler"],626,[1,0,0,0]]]],814]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2660,[5,"36QIl8BOBDuYwLsrFq5A3J",null,[[2,"cao-057",["_name"],627],[0,["_lpos"],627,[1,-79.569,0,-50.076]],[0,["_lrot"],627,[3,0,0,0,1]],[0,["_euler"],627,[1,0,0,0]]]],815]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2661,[5,"c0rD5lSbVDVIrtNAx0pcbZ",null,[[2,"cao-058",["_name"],628],[0,["_lpos"],628,[1,-82.547,0,-44.161]],[0,["_lrot"],628,[3,0,0,0,1]],[0,["_euler"],628,[1,0,0,0]]]],816]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2662,[5,"6fDjo3CGZB6q/T6eAjAYV+",null,[[2,"cao-059",["_name"],629],[0,["_lpos"],629,[1,-80.421,0,-45.913]],[0,["_lrot"],629,[3,0,0,0,1]],[0,["_euler"],629,[1,0,0,0]]]],817]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2663,[5,"e0640BU85BIpjEQJRs9zGM",null,[[2,"cao-060",["_name"],630],[0,["_lpos"],630,[1,-85.374,0,-48.694]],[0,["_lrot"],630,[3,0,0,0,1]],[0,["_euler"],630,[1,0,0,0]]]],818]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2664,[5,"51wzUv/SpJM6lC4AEgi4Ts",null,[[2,"cao-061",["_name"],631],[0,["_lpos"],631,[1,-75.287,0,-38.03]],[0,["_lrot"],631,[3,0,0,0,1]],[0,["_euler"],631,[1,0,0,0]]]],819]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2665,[5,"d5bw/4BdROOpO2PPuDUxR7",null,[[2,"cao-062",["_name"],632],[0,["_lpos"],632,[1,-70.334,0,-35.249]],[0,["_lrot"],632,[3,0,0,0,1]],[0,["_euler"],632,[1,0,0,0]]]],820]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2666,[5,"2bb67cQHZDgL6gWCgao7b4",null,[[2,"cao-063",["_name"],633],[0,["_lpos"],633,[1,-72.46,0,-33.497]],[0,["_lrot"],633,[3,0,0,0,1]],[0,["_euler"],633,[1,0,0,0]]]],821]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2667,[5,"41mXZiY2RID7NDItKf0aCS",null,[[2,"cao-064",["_name"],634],[0,["_lpos"],634,[1,-69.482,0,-39.412]],[0,["_lrot"],634,[3,0,0,0,1]],[0,["_euler"],634,[1,0,0,0]]]],822]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2668,[5,"9cOo97/OFEnKbbGvRb7/4I",null,[[2,"cao-065",["_name"],635],[0,["_lpos"],635,[1,-72.638,0,-38.984]],[0,["_lrot"],635,[3,0,0,0,1]],[0,["_euler"],635,[1,0,0,0]]]],823]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2669,[5,"a09xtP13BAmZ2aEkTakRta",null,[[2,"cao-066",["_name"],636],[0,["_lpos"],636,[1,-84.283,0,-38.585]],[0,["_lrot"],636,[3,0,0,0,1]],[0,["_euler"],636,[1,0,0,0]]]],824]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2670,[5,"49+gOmYN9MD6y0f8RG0CeK",null,[[2,"cao-067",["_name"],637],[0,["_lpos"],637,[1,-81.127,0,-39.013]],[0,["_lrot"],637,[3,0,0,0,1]],[0,["_euler"],637,[1,0,0,0]]]],825]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2671,[5,"f9HzJob+RHErn001GjSBn8",null,[[2,"cao-068",["_name"],638],[0,["_lpos"],638,[1,-84.105,0,-33.098]],[0,["_lrot"],638,[3,0,0,0,1]],[0,["_euler"],638,[1,0,0,0]]]],826]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2672,[5,"31g+pUZRlG9IF/lcgkvXyZ",null,[[2,"cao-069",["_name"],639],[0,["_lpos"],639,[1,-81.979,0,-34.85]],[0,["_lrot"],639,[3,0,0,0,1]],[0,["_euler"],639,[1,0,0,0]]]],827]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2673,[5,"6dB7c09T1Guqn8QDciJgk8",null,[[2,"cao-070",["_name"],640],[0,["_lpos"],640,[1,-86.932,0,-37.631]],[0,["_lrot"],640,[3,0,0,0,1]],[0,["_euler"],640,[1,0,0,0]]]],828]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2674,[5,"b4DtU0LMJK6Z7AIWPLlR8T",null,[[2,"cao-071",["_name"],641],[0,["_lpos"],641,[1,-72.366,0,-25.202]],[0,["_lrot"],641,[3,0,0,0,1]],[0,["_euler"],641,[1,0,0,0]]]],829]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2675,[5,"ae8tjvYItJHJlkq/89BMGR",null,[[2,"cao-072",["_name"],642],[0,["_lpos"],642,[1,-67.413,0,-22.421]],[0,["_lrot"],642,[3,0,0,0,1]],[0,["_euler"],642,[1,0,0,0]]]],830]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2676,[5,"9cicdHTD5Ov7fCPY/WG+kU",null,[[2,"cao-073",["_name"],643],[0,["_lpos"],643,[1,-69.539,0,-20.669]],[0,["_lrot"],643,[3,0,0,0,1]],[0,["_euler"],643,[1,0,0,0]]]],831]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2677,[5,"4by70rWF9MtJCc623x/bfw",null,[[2,"cao-074",["_name"],644],[0,["_lpos"],644,[1,-66.561,0,-26.584]],[0,["_lrot"],644,[3,0,0,0,1]],[0,["_euler"],644,[1,0,0,0]]]],832]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2678,[5,"8aDDLUu8tAVpJS9ZSvzqqi",null,[[2,"cao-075",["_name"],645],[0,["_lpos"],645,[1,-69.717,0,-26.156]],[0,["_lrot"],645,[3,0,0,0,1]],[0,["_euler"],645,[1,0,0,0]]]],833]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2679,[5,"b0FV2s/wdEsoSk8JML0tPh",null,[[2,"cao-076",["_name"],646],[0,["_lpos"],646,[1,-83.624,0,-29.625]],[0,["_lrot"],646,[3,0,0,0,1]],[0,["_euler"],646,[1,0,0,0]]]],834]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2680,[5,"3cWQZfFHFILZBh0PTCZXKn",null,[[2,"cao-077",["_name"],647],[0,["_lpos"],647,[1,-80.468,0,-30.053]],[0,["_lrot"],647,[3,0,0,0,1]],[0,["_euler"],647,[1,0,0,0]]]],835]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2681,[5,"288/En6oJBXoPJW/CXRrxX",null,[[2,"cao-078",["_name"],648],[0,["_lpos"],648,[1,-83.446,0,-24.138]],[0,["_lrot"],648,[3,0,0,0,1]],[0,["_euler"],648,[1,0,0,0]]]],836]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2682,[5,"abhehLX6dEY6c71odrhIV2",null,[[2,"cao-079",["_name"],649],[0,["_lpos"],649,[1,-81.32,0,-25.89]],[0,["_lrot"],649,[3,0,0,0,1]],[0,["_euler"],649,[1,0,0,0]]]],837]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2683,[5,"2cDubngh9Ol5tmZc9qVCUA",null,[[2,"cao-080",["_name"],650],[0,["_lpos"],650,[1,-86.273,0,-28.671]],[0,["_lrot"],650,[3,0,0,0,1]],[0,["_euler"],650,[1,0,0,0]]]],838]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2684,[5,"cbIwKXQbNNOaX3bSQWxCeA",null,[[2,"cao-081",["_name"],651],[0,["_lpos"],651,[1,-112.975,0,-77.667]],[0,["_lrot"],651,[3,0,0,0,1]],[0,["_euler"],651,[1,0,0,0]]]],839]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2685,[5,"a4O5gnZkJNga8LxzIL3KX5",null,[[2,"cao-082",["_name"],652],[0,["_lpos"],652,[1,-108.022,0,-74.886]],[0,["_lrot"],652,[3,0,0,0,1]],[0,["_euler"],652,[1,0,0,0]]]],840]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2686,[5,"07ehwh/1FNTLXVhJ0F6zcb",null,[[2,"cao-083",["_name"],653],[0,["_lpos"],653,[1,-110.148,0,-73.134]],[0,["_lrot"],653,[3,0,0,0,1]],[0,["_euler"],653,[1,0,0,0]]]],841]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2687,[5,"e6atYuXIRAGbDFPClyoIrG",null,[[2,"cao-084",["_name"],654],[0,["_lpos"],654,[1,-107.17,0,-79.049]],[0,["_lrot"],654,[3,0,0,0,1]],[0,["_euler"],654,[1,0,0,0]]]],842]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2688,[5,"9cASE4UxRGwZpllvqDEIiO",null,[[2,"cao-085",["_name"],655],[0,["_lpos"],655,[1,-110.326,0,-78.621]],[0,["_lrot"],655,[3,0,0,0,1]],[0,["_euler"],655,[1,0,0,0]]]],843]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2689,[5,"83QPnB4M9IA671SyilqhE6",null,[[2,"cao-086",["_name"],656],[0,["_lpos"],656,[1,-40.498,0,-78.069]],[0,["_lrot"],656,[3,0,0,0,1]],[0,["_euler"],656,[1,0,0,0]]]],844]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2690,[5,"edo4c3G5VDh4u3JTCXLmpo",null,[[2,"cao-087",["_name"],657],[0,["_lpos"],657,[1,-35.545,0,-75.288]],[0,["_lrot"],657,[3,0,0,0,1]],[0,["_euler"],657,[1,0,0,0]]]],845]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2691,[5,"56jO+y/WlP4b4oIR6IXgSX",null,[[2,"cao-088",["_name"],658],[0,["_lpos"],658,[1,-37.671,0,-73.536]],[0,["_lrot"],658,[3,0,0,0,1]],[0,["_euler"],658,[1,0,0,0]]]],846]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2692,[5,"affwqMDN9DpY7rf85r1kbA",null,[[2,"cao-089",["_name"],659],[0,["_lpos"],659,[1,-34.693,0,-79.451]],[0,["_lrot"],659,[3,0,0,0,1]],[0,["_euler"],659,[1,0,0,0]]]],847]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2693,[5,"58IGdBoqZPvqGkyt/RTdbs",null,[[2,"cao-090",["_name"],660],[0,["_lpos"],660,[1,-37.849,0,-79.023]],[0,["_lrot"],660,[3,0,0,0,1]],[0,["_euler"],660,[1,0,0,0]]]],848]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2694,[5,"976Hy2H8NOLbtN1Dxy9QOP",null,[[2,"cao-091",["_name"],661],[0,["_lpos"],661,[1,-72.33,0,-116.193]],[0,["_lrot"],661,[3,0,0,0,1]],[0,["_euler"],661,[1,0,0,0]]]],849]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2695,[5,"a5F17/CBpCcqJXGcI3uTRW",null,[[2,"cao-092",["_name"],662],[0,["_lpos"],662,[1,-69.174,0,-116.621]],[0,["_lrot"],662,[3,0,0,0,1]],[0,["_euler"],662,[1,0,0,0]]]],850]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2696,[5,"08xK1YpddMDroFWWC6WLMR",null,[[2,"cao-093",["_name"],663],[0,["_lpos"],663,[1,-72.152,0,-110.706]],[0,["_lrot"],663,[3,0,0,0,1]],[0,["_euler"],663,[1,0,0,0]]]],851]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2697,[5,"88sNcuXbtAa5DQty4UGYqF",null,[[2,"cao-094",["_name"],664],[0,["_lpos"],664,[1,-70.026,0,-112.458]],[0,["_lrot"],664,[3,0,0,0,1]],[0,["_euler"],664,[1,0,0,0]]]],852]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2698,[5,"86QJnVzY1LLJbt4dImnuYN",null,[[2,"cao-095",["_name"],665],[0,["_lpos"],665,[1,-74.979,0,-115.239]],[0,["_lrot"],665,[3,0,0,0,1]],[0,["_euler"],665,[1,0,0,0]]]],853]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2699,[5,"2eqjTJWAtG+pOysnyYxybU",null,[[2,"cao-096",["_name"],666],[0,["_lpos"],666,[1,-110.766,0,-86.172]],[0,["_lrot"],666,[3,0,0,0,1]],[0,["_euler"],666,[1,0,0,0]]]],854]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2700,[5,"12W7pvKhhNKpRfT4gFiUIa",null,[[2,"cao-097",["_name"],667],[0,["_lpos"],667,[1,-105.813,0,-83.391]],[0,["_lrot"],667,[3,0,0,0,1]],[0,["_euler"],667,[1,0,0,0]]]],855]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2701,[5,"6faXllM65KaqnBTdgOQTd4",null,[[2,"cao-098",["_name"],668],[0,["_lpos"],668,[1,-107.939,0,-81.639]],[0,["_lrot"],668,[3,0,0,0,1]],[0,["_euler"],668,[1,0,0,0]]]],856]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2702,[5,"44NUcrBdVOxbPEcS9HgWhA",null,[[2,"cao-099",["_name"],669],[0,["_lpos"],669,[1,-104.961,0,-87.554]],[0,["_lrot"],669,[3,0,0,0,1]],[0,["_euler"],669,[1,0,0,0]]]],857]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2703,[5,"abml/Rl6NFg5NH/gza/wJZ",null,[[2,"cao-100",["_name"],670],[0,["_lpos"],670,[1,-108.117,0,-87.126]],[0,["_lrot"],670,[3,0,0,0,1]],[0,["_euler"],670,[1,0,0,0]]]],858]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2704,[5,"3f5vlGjmtA4LNkFFrICLzV",null,[[2,"cao-101",["_name"],671],[0,["_lpos"],671,[1,-118.951,0,-79.004]],[0,["_lrot"],671,[3,0,0,0,1]],[0,["_euler"],671,[1,0,0,0]]]],859]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2705,[5,"52RtBDk9hI44A64RL6OY1F",null,[[2,"cao-102",["_name"],672],[0,["_lpos"],672,[1,-115.795,0,-79.432]],[0,["_lrot"],672,[3,0,0,0,1]],[0,["_euler"],672,[1,0,0,0]]]],860]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2706,[5,"61AjdZG4dJ5anSPqFyG4UB",null,[[2,"cao-103",["_name"],673],[0,["_lpos"],673,[1,-118.773,0,-73.517]],[0,["_lrot"],673,[3,0,0,0,1]],[0,["_euler"],673,[1,0,0,0]]]],861]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2707,[5,"904x4HIrVNpIsAiaKBimkt",null,[[2,"cao-104",["_name"],674],[0,["_lpos"],674,[1,-116.647,0,-75.269]],[0,["_lrot"],674,[3,0,0,0,1]],[0,["_euler"],674,[1,0,0,0]]]],862]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2708,[5,"fe3NM9RXBOPZkECKwRL0gA",null,[[2,"cao-105",["_name"],675],[0,["_lpos"],675,[1,-121.6,0,-78.05]],[0,["_lrot"],675,[3,0,0,0,1]],[0,["_euler"],675,[1,0,0,0]]]],863]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2709,[5,"dfDDV55X9CBY4bWgWHA9MP",null,[[2,"cao-106",["_name"],676],[0,["_lpos"],676,[1,-128.496,0,-95.152]],[0,["_lrot"],676,[3,0,0,0,1]],[0,["_euler"],676,[1,0,0,0]]]],864]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2710,[5,"95vdMw9otLYZ1YTM6ngMQ9",null,[[2,"cao-107",["_name"],677],[0,["_lpos"],677,[1,-123.543,0,-92.371]],[0,["_lrot"],677,[3,0,0,0,1]],[0,["_euler"],677,[1,0,0,0]]]],865]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2711,[5,"d6T+1RtdRCV7kJqVONz2n3",null,[[2,"cao-108",["_name"],678],[0,["_lpos"],678,[1,-125.669,0,-90.619]],[0,["_lrot"],678,[3,0,0,0,1]],[0,["_euler"],678,[1,0,0,0]]]],866]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2712,[5,"16Mh6qDhFO9JMzqdQ+YEMz",null,[[2,"cao-109",["_name"],679],[0,["_lpos"],679,[1,-122.691,0,-96.534]],[0,["_lrot"],679,[3,0,0,0,1]],[0,["_euler"],679,[1,0,0,0]]]],867]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2713,[5,"879XBkWipFbrSqz4KzlzQC",null,[[2,"cao-110",["_name"],680],[0,["_lpos"],680,[1,-125.847,0,-96.106]],[0,["_lrot"],680,[3,0,0,0,1]],[0,["_euler"],680,[1,0,0,0]]]],868]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2714,[5,"3f4vvjYFVH4667dxw0eNuR",null,[[2,"cao-111",["_name"],681],[0,["_lpos"],681,[1,-122.501,0,-110.429]],[0,["_lrot"],681,[3,0,0,0,1]],[0,["_euler"],681,[1,0,0,0]]]],869]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2715,[5,"cbKNxkcuhD6qKcErGiBDVc",null,[[2,"cao-112",["_name"],682],[0,["_lpos"],682,[1,-119.345,0,-110.857]],[0,["_lrot"],682,[3,0,0,0,1]],[0,["_euler"],682,[1,0,0,0]]]],870]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2716,[5,"7e+wVuJqxPFr+06pmlFq6K",null,[[2,"cao-113",["_name"],683],[0,["_lpos"],683,[1,-122.323,0,-104.942]],[0,["_lrot"],683,[3,0,0,0,1]],[0,["_euler"],683,[1,0,0,0]]]],871]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2717,[5,"12DnE66a5Le4l0ZXJcmh6r",null,[[2,"cao-114",["_name"],684],[0,["_lpos"],684,[1,-120.197,0,-106.694]],[0,["_lrot"],684,[3,0,0,0,1]],[0,["_euler"],684,[1,0,0,0]]]],872]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2718,[5,"01Rer2Rj1BXoPqcHlvKV1R",null,[[2,"cao-115",["_name"],685],[0,["_lpos"],685,[1,-125.15,0,-109.475]],[0,["_lrot"],685,[3,0,0,0,1]],[0,["_euler"],685,[1,0,0,0]]]],873]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2719,[5,"0dkXD1UyxNEK/9HVmE09S9",null,[[2,"cao-116",["_name"],686],[0,["_lpos"],686,[1,-117.39,0,-99.798]],[0,["_lrot"],686,[3,0,0,0,1]],[0,["_euler"],686,[1,0,0,0]]]],874]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2720,[5,"0ak/s0gm5BeLtef9n05VAp",null,[[2,"cao-117",["_name"],687],[0,["_lpos"],687,[1,-112.437,0,-97.017]],[0,["_lrot"],687,[3,0,0,0,1]],[0,["_euler"],687,[1,0,0,0]]]],875]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2721,[5,"8cnjisKm9J7as3Qq33CEsX",null,[[2,"cao-118",["_name"],688],[0,["_lpos"],688,[1,-114.563,0,-95.265]],[0,["_lrot"],688,[3,0,0,0,1]],[0,["_euler"],688,[1,0,0,0]]]],876]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2722,[5,"ef4kH0VX5HubX2MR0mYLfe",null,[[2,"cao-119",["_name"],689],[0,["_lpos"],689,[1,-111.585,0,-101.18]],[0,["_lrot"],689,[3,0,0,0,1]],[0,["_euler"],689,[1,0,0,0]]]],877]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2723,[5,"0erhFe5DFN7agd/Ce4gjab",null,[[2,"cao-120",["_name"],690],[0,["_lpos"],690,[1,-114.741,0,-100.752]],[0,["_lrot"],690,[3,0,0,0,1]],[0,["_euler"],690,[1,0,0,0]]]],878]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2724,[5,"08bJGIrEZD65zCJ3JizGTN",null,[[2,"cao-121",["_name"],691],[0,["_lpos"],691,[1,-159.083,0,-79.291]],[0,["_lrot"],691,[3,0,0,0,1]],[0,["_euler"],691,[1,0,0,0]]]],879]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2725,[5,"cdzyxgrJ1DVZ2m+2ls4sMm",null,[[2,"cao-122",["_name"],692],[0,["_lpos"],692,[1,-155.927,0,-79.719]],[0,["_lrot"],692,[3,0,0,0,1]],[0,["_euler"],692,[1,0,0,0]]]],880]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2726,[5,"e8QwA55cRNfIbMmKYtt3k1",null,[[2,"cao-123",["_name"],693],[0,["_lpos"],693,[1,-158.905,0,-73.804]],[0,["_lrot"],693,[3,0,0,0,1]],[0,["_euler"],693,[1,0,0,0]]]],881]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2727,[5,"faefjhWQpNzpk6yM7rB9GH",null,[[2,"cao-124",["_name"],694],[0,["_lpos"],694,[1,-156.779,0,-75.556]],[0,["_lrot"],694,[3,0,0,0,1]],[0,["_euler"],694,[1,0,0,0]]]],882]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2728,[5,"62w9HIha5Oqbe3wYqosOAa",null,[[2,"cao-125",["_name"],695],[0,["_lpos"],695,[1,-161.732,0,-78.337]],[0,["_lrot"],695,[3,0,0,0,1]],[0,["_euler"],695,[1,0,0,0]]]],883]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2729,[5,"6cobwo8d5IyKXGOw9ylXcW",null,[[2,"cao-126",["_name"],696],[0,["_lpos"],696,[1,-177.02,0,-78.337]],[0,["_lrot"],696,[3,0,0,0,1]],[0,["_euler"],696,[1,0,0,0]]]],884]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2730,[5,"b7EFa6ZT9Be5ax/bGxOPBk",null,[[2,"cao-127",["_name"],697],[0,["_lpos"],697,[1,-172.067,0,-75.556]],[0,["_lrot"],697,[3,0,0,0,1]],[0,["_euler"],697,[1,0,0,0]]]],885]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2731,[5,"336uVRYAZKLot2eVQ7zDZh",null,[[2,"cao-128",["_name"],698],[0,["_lpos"],698,[1,-174.193,0,-73.804]],[0,["_lrot"],698,[3,0,0,0,1]],[0,["_euler"],698,[1,0,0,0]]]],886]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2732,[5,"b6mv/M59xEqqY/UIfUuPVh",null,[[2,"cao-129",["_name"],699],[0,["_lpos"],699,[1,-171.215,0,-79.719]],[0,["_lrot"],699,[3,0,0,0,1]],[0,["_euler"],699,[1,0,0,0]]]],887]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2733,[5,"b5Qjpy6mBIjKTd1g098ksg",null,[[2,"cao-130",["_name"],700],[0,["_lpos"],700,[1,-174.371,0,-79.291]],[0,["_lrot"],700,[3,0,0,0,1]],[0,["_euler"],700,[1,0,0,0]]]],888]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2734,[5,"944bzoVgJJupz4395yOW/b",null,[[2,"cao-131",["_name"],701],[0,["_lpos"],701,[1,-157.679,0,-115.137]],[0,["_lrot"],701,[3,0,0,0,1]],[0,["_euler"],701,[1,0,0,0]]]],889]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2735,[5,"adOfsrut1Gu4/c2LZ0K1Bh",null,[[2,"cao-132",["_name"],702],[0,["_lpos"],702,[1,-154.523,0,-115.565]],[0,["_lrot"],702,[3,0,0,0,1]],[0,["_euler"],702,[1,0,0,0]]]],890]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2736,[5,"2cCtKFxy5Ahprel1KVbNXv",null,[[2,"cao-133",["_name"],703],[0,["_lpos"],703,[1,-157.501,0,-109.65]],[0,["_lrot"],703,[3,0,0,0,1]],[0,["_euler"],703,[1,0,0,0]]]],891]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2737,[5,"e2mAj3u39AKIDygk0OQ6zZ",null,[[2,"cao-134",["_name"],704],[0,["_lpos"],704,[1,-155.375,0,-111.402]],[0,["_lrot"],704,[3,0,0,0,1]],[0,["_euler"],704,[1,0,0,0]]]],892]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2738,[5,"8fYP8KgvxCPrDXri3V7OWg",null,[[2,"cao-135",["_name"],705],[0,["_lpos"],705,[1,-160.328,0,-114.183]],[0,["_lrot"],705,[3,0,0,0,1]],[0,["_euler"],705,[1,0,0,0]]]],893]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2739,[5,"44eArronBMgpN+D+7rj0MK",null,[[2,"cao-136",["_name"],706],[0,["_lpos"],706,[1,-174.172,0,-114.01]],[0,["_lrot"],706,[3,0,0,0,1]],[0,["_euler"],706,[1,0,0,0]]]],894]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2740,[5,"95hGYZwsFPBqrVNXz7gCk3",null,[[2,"cao-137",["_name"],707],[0,["_lpos"],707,[1,-169.219,0,-111.229]],[0,["_lrot"],707,[3,0,0,0,1]],[0,["_euler"],707,[1,0,0,0]]]],895]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2741,[5,"f0ql1D/lNLA76gDBzZDDUT",null,[[2,"cao-138",["_name"],708],[0,["_lpos"],708,[1,-171.345,0,-109.477]],[0,["_lrot"],708,[3,0,0,0,1]],[0,["_euler"],708,[1,0,0,0]]]],896]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2742,[5,"6c2RYJIKRCqKZPdXXoVvnx",null,[[2,"cao-139",["_name"],709],[0,["_lpos"],709,[1,-168.367,0,-115.392]],[0,["_lrot"],709,[3,0,0,0,1]],[0,["_euler"],709,[1,0,0,0]]]],897]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2743,[5,"c3/dwOpv9DQIKfHaxhp/01",null,[[2,"cao-140",["_name"],710],[0,["_lpos"],710,[1,-171.523,0,-114.964]],[0,["_lrot"],710,[3,0,0,0,1]],[0,["_euler"],710,[1,0,0,0]]]],898]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2744,[5,"49uQdWuUxM4rLYIL4QVI5f",null,[[2,"cao-141",["_name"],711],[0,["_lpos"],711,[1,-158.272,0,-48.859]],[0,["_lrot"],711,[3,0,0,0,1]],[0,["_euler"],711,[1,0,0,0]]]],899]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2745,[5,"36HR695V5Nfo7/DvjhWGZl",null,[[2,"cao-142",["_name"],712],[0,["_lpos"],712,[1,-155.116,0,-49.287]],[0,["_lrot"],712,[3,0,0,0,1]],[0,["_euler"],712,[1,0,0,0]]]],900]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2746,[5,"41dx8UdC9NjIFR0gncfeTI",null,[[2,"cao-143",["_name"],713],[0,["_lpos"],713,[1,-158.094,0,-43.372]],[0,["_lrot"],713,[3,0,0,0,1]],[0,["_euler"],713,[1,0,0,0]]]],901]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2747,[5,"cblotz9adMi7lPbLflPJu0",null,[[2,"cao-144",["_name"],714],[0,["_lpos"],714,[1,-155.968,0,-45.124]],[0,["_lrot"],714,[3,0,0,0,1]],[0,["_euler"],714,[1,0,0,0]]]],902]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2748,[5,"51y2bvOOFFS45YyQw1KeQ9",null,[[2,"cao-145",["_name"],715],[0,["_lpos"],715,[1,-160.921,0,-47.905]],[0,["_lrot"],715,[3,0,0,0,1]],[0,["_euler"],715,[1,0,0,0]]]],903]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2749,[5,"21IDUZY2ZMjJ/MB7Jiu87x",null,[[2,"cao-146",["_name"],716],[0,["_lpos"],716,[1,-164.368,0,-37.147]],[0,["_lrot"],716,[3,0,0,0,1]],[0,["_euler"],716,[1,0,0,0]]]],904]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2750,[5,"7f6cJ95wFN6rOEgNOPWsDr",null,[[2,"cao-147",["_name"],717],[0,["_lpos"],717,[1,-159.415,0,-34.366]],[0,["_lrot"],717,[3,0,0,0,1]],[0,["_euler"],717,[1,0,0,0]]]],905]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2751,[5,"0es8lRlJVJG56JCKIa4XLg",null,[[2,"cao-148",["_name"],718],[0,["_lpos"],718,[1,-161.541,0,-32.614]],[0,["_lrot"],718,[3,0,0,0,1]],[0,["_euler"],718,[1,0,0,0]]]],906]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2752,[5,"03q4QgVp1DapZN5T5fGbcb",null,[[2,"cao-149",["_name"],719],[0,["_lpos"],719,[1,-158.563,0,-38.529]],[0,["_lrot"],719,[3,0,0,0,1]],[0,["_euler"],719,[1,0,0,0]]]],907]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2753,[5,"1d85feSBZHK7rYz0xIQzCJ",null,[[2,"cao-150",["_name"],720],[0,["_lpos"],720,[1,-161.719,0,-38.101]],[0,["_lrot"],720,[3,0,0,0,1]],[0,["_euler"],720,[1,0,0,0]]]],908]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2754,[5,"b99q3sXaBEcoUwpPnFLjcm",null,[[2,"cao-151",["_name"],721],[0,["_lpos"],721,[1,-170.64,0,-49.011]],[0,["_lrot"],721,[3,0,0,0,1]],[0,["_euler"],721,[1,0,0,0]]]],909]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2755,[5,"d4Ni8QFB1C0JKzSsuAK+cO",null,[[2,"cao-152",["_name"],722],[0,["_lpos"],722,[1,-167.484,0,-49.439]],[0,["_lrot"],722,[3,0,0,0,1]],[0,["_euler"],722,[1,0,0,0]]]],910]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2756,[5,"fbZPphjq9O7afyUYLieKql",null,[[2,"cao-153",["_name"],723],[0,["_lpos"],723,[1,-170.462,0,-43.524]],[0,["_lrot"],723,[3,0,0,0,1]],[0,["_euler"],723,[1,0,0,0]]]],911]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2757,[5,"46HSuxIWNLEZbgv3mWCd1l",null,[[2,"cao-154",["_name"],724],[0,["_lpos"],724,[1,-168.336,0,-45.276]],[0,["_lrot"],724,[3,0,0,0,1]],[0,["_euler"],724,[1,0,0,0]]]],912]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2758,[5,"47f3xlmk5Gbp/jvFLO+hWy",null,[[2,"cao-155",["_name"],725],[0,["_lpos"],725,[1,-173.289,0,-48.057]],[0,["_lrot"],725,[3,0,0,0,1]],[0,["_euler"],725,[1,0,0,0]]]],913]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2759,[5,"23K7Yt45tK75qyKoAE8AyD",null,[[2,"cao-156",["_name"],726],[0,["_lpos"],726,[1,-181.977,0,-33.443]],[0,["_lrot"],726,[3,0,0,0,1]],[0,["_euler"],726,[1,0,0,0]]]],914]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2760,[5,"f7/b5A6gJCQb+Agpq1qKGx",null,[[2,"cao-157",["_name"],727],[0,["_lpos"],727,[1,-177.024,0,-30.662]],[0,["_lrot"],727,[3,0,0,0,1]],[0,["_euler"],727,[1,0,0,0]]]],915]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2761,[5,"7b02sDnHtHE5RKcC6PUWQU",null,[[2,"cao-158",["_name"],728],[0,["_lpos"],728,[1,-179.15,0,-28.91]],[0,["_lrot"],728,[3,0,0,0,1]],[0,["_euler"],728,[1,0,0,0]]]],916]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2762,[5,"90gc1bH1xN+KRphUDpRNG3",null,[[2,"cao-159",["_name"],729],[0,["_lpos"],729,[1,-176.172,0,-34.825]],[0,["_lrot"],729,[3,0,0,0,1]],[0,["_euler"],729,[1,0,0,0]]]],917]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2763,[5,"b86o8P+sBEWodSu2J0EKT7",null,[[2,"cao-160",["_name"],730],[0,["_lpos"],730,[1,-179.328,0,-34.397]],[0,["_lrot"],730,[3,0,0,0,1]],[0,["_euler"],730,[1,0,0,0]]]],918]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2764,[5,"e3U5O5Be1GoJWHiXOnHEnP",null,[[2,"cao-161",["_name"],731],[0,["_lpos"],731,[1,-163.081,0,-25.41]],[0,["_lrot"],731,[3,0,0,0,1]],[0,["_euler"],731,[1,0,0,0]]]],919]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2765,[5,"abqTCBuJJAOa3CdUSQ3y85",null,[[2,"cao-162",["_name"],732],[0,["_lpos"],732,[1,-159.925,0,-25.838]],[0,["_lrot"],732,[3,0,0,0,1]],[0,["_euler"],732,[1,0,0,0]]]],920]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2766,[5,"26p8resshPNqAAhLQCVkBv",null,[[2,"cao-163",["_name"],733],[0,["_lpos"],733,[1,-162.903,0,-19.923]],[0,["_lrot"],733,[3,0,0,0,1]],[0,["_euler"],733,[1,0,0,0]]]],921]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2767,[5,"16GsgqM89DiZfjzQXpXotF",null,[[2,"cao-164",["_name"],734],[0,["_lpos"],734,[1,-160.777,0,-21.675]],[0,["_lrot"],734,[3,0,0,0,1]],[0,["_euler"],734,[1,0,0,0]]]],922]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2768,[5,"8c334fyeBH1ZBCH94vLQuQ",null,[[2,"cao-165",["_name"],735],[0,["_lpos"],735,[1,-165.73,0,-24.456]],[0,["_lrot"],735,[3,0,0,0,1]],[0,["_euler"],735,[1,0,0,0]]]],923]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2769,[5,"70ilMa94ZF36hrKkr0GAQ7",null,[[2,"cao-166",["_name"],736],[0,["_lpos"],736,[1,-181.348,0,-23.415]],[0,["_lrot"],736,[3,0,0,0,1]],[0,["_euler"],736,[1,0,0,0]]]],924]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2770,[5,"46iOYCxGdCipEoyN37qaon",null,[[2,"cao-167",["_name"],737],[0,["_lpos"],737,[1,-176.395,0,-20.634]],[0,["_lrot"],737,[3,0,0,0,1]],[0,["_euler"],737,[1,0,0,0]]]],925]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2771,[5,"c1QLcIDQhIz4RbrOid8/wD",null,[[2,"cao-168",["_name"],738],[0,["_lpos"],738,[1,-178.521,0,-18.882]],[0,["_lrot"],738,[3,0,0,0,1]],[0,["_euler"],738,[1,0,0,0]]]],926]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2772,[5,"e34VwDBd9EWIA4NC2PTVv/",null,[[2,"cao-169",["_name"],739],[0,["_lpos"],739,[1,-175.543,0,-24.797]],[0,["_lrot"],739,[3,0,0,0,1]],[0,["_euler"],739,[1,0,0,0]]]],927]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2773,[5,"a5Ud4fFkpOAYF8nHwyH6dt",null,[[2,"cao-170",["_name"],740],[0,["_lpos"],740,[1,-178.699,0,-24.369]],[0,["_lrot"],740,[3,0,0,0,1]],[0,["_euler"],740,[1,0,0,0]]]],928]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2774,[5,"b655nDlmlAb7nIEik6VNBC",null,[[2,"cao-171",["_name"],741],[0,["_lpos"],741,[1,-128.685,0,-48.554]],[0,["_lrot"],741,[3,0,0,0,1]],[0,["_euler"],741,[1,0,0,0]]]],929]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2775,[5,"74kdg+hpdLzpzLE/4XqyuX",null,[[2,"cao-172",["_name"],742],[0,["_lpos"],742,[1,-125.529,0,-48.982]],[0,["_lrot"],742,[3,0,0,0,1]],[0,["_euler"],742,[1,0,0,0]]]],930]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2776,[5,"92LmLaqSxIHrr59ryxl7iI",null,[[2,"cao-173",["_name"],743],[0,["_lpos"],743,[1,-128.507,0,-43.067]],[0,["_lrot"],743,[3,0,0,0,1]],[0,["_euler"],743,[1,0,0,0]]]],931]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2777,[5,"4cWHZSw0lCcIJIOzFolzxX",null,[[2,"cao-174",["_name"],744],[0,["_lpos"],744,[1,-126.381,0,-44.819]],[0,["_lrot"],744,[3,0,0,0,1]],[0,["_euler"],744,[1,0,0,0]]]],932]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2778,[5,"04dkJTul9CLKmWfYAlajFe",null,[[2,"cao-175",["_name"],745],[0,["_lpos"],745,[1,-131.334,0,-47.6]],[0,["_lrot"],745,[3,0,0,0,1]],[0,["_euler"],745,[1,0,0,0]]]],933]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2779,[5,"c0JPVk9T1Nt6p3n77x1CkJ",null,[[2,"cao-176",["_name"],746],[0,["_lpos"],746,[1,-132.807,0,-35.753]],[0,["_lrot"],746,[3,0,0,0,1]],[0,["_euler"],746,[1,0,0,0]]]],934]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2780,[5,"82+L+aaMFNZp/BiFvMtkvW",null,[[2,"cao-177",["_name"],747],[0,["_lpos"],747,[1,-127.854,0,-32.972]],[0,["_lrot"],747,[3,0,0,0,1]],[0,["_euler"],747,[1,0,0,0]]]],935]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2781,[5,"cc7kNVt61GooSeOUIjzOp7",null,[[2,"cao-178",["_name"],748],[0,["_lpos"],748,[1,-129.98,0,-31.22]],[0,["_lrot"],748,[3,0,0,0,1]],[0,["_euler"],748,[1,0,0,0]]]],936]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2782,[5,"07eVlBLUFE1rUYSZwT8GYC",null,[[2,"cao-179",["_name"],749],[0,["_lpos"],749,[1,-127.002,0,-37.135]],[0,["_lrot"],749,[3,0,0,0,1]],[0,["_euler"],749,[1,0,0,0]]]],937]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2783,[5,"6f9pIPM/pJxZk3ugwpTSYV",null,[[2,"cao-180",["_name"],750],[0,["_lpos"],750,[1,-130.158,0,-36.707]],[0,["_lrot"],750,[3,0,0,0,1]],[0,["_euler"],750,[1,0,0,0]]]],938]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2784,[5,"c1RzT+ooBFL71vGXH1u37o",null,[[2,"cao-181",["_name"],751],[0,["_lpos"],751,[1,-128.249,0,-23.35]],[0,["_lrot"],751,[3,0,0,0,1]],[0,["_euler"],751,[1,0,0,0]]]],939]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2785,[5,"b1UxKjG+tMKqgZdyE3AOVH",null,[[2,"cao-182",["_name"],752],[0,["_lpos"],752,[1,-125.093,0,-23.778]],[0,["_lrot"],752,[3,0,0,0,1]],[0,["_euler"],752,[1,0,0,0]]]],940]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2786,[5,"a34BG+kTZDTYw1VNs3aNz5",null,[[2,"cao-183",["_name"],753],[0,["_lpos"],753,[1,-128.071,0,-17.863]],[0,["_lrot"],753,[3,0,0,0,1]],[0,["_euler"],753,[1,0,0,0]]]],941]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2787,[5,"51jBnYabpILpNZBzdF+nHz",null,[[2,"cao-184",["_name"],754],[0,["_lpos"],754,[1,-125.945,0,-19.615]],[0,["_lrot"],754,[3,0,0,0,1]],[0,["_euler"],754,[1,0,0,0]]]],942]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2788,[5,"f7NNwRVb9AfbP0Peek5hR+",null,[[2,"cao-185",["_name"],755],[0,["_lpos"],755,[1,-130.898,0,-22.396]],[0,["_lrot"],755,[3,0,0,0,1]],[0,["_euler"],755,[1,0,0,0]]]],943]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2789,[5,"44EyAMxoVK9bN9Ic1G4RFi",null,[[2,"cao-186",["_name"],756],[0,["_lpos"],756,[1,-191.883,0,-83.704]],[0,["_lrot"],756,[3,0,0,0,1]],[0,["_euler"],756,[1,0,0,0]]]],944]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2790,[5,"1eEyJVTlFAEKh2SEeMbvJi",null,[[2,"cao-187",["_name"],757],[0,["_lpos"],757,[1,-186.93,0,-80.923]],[0,["_lrot"],757,[3,0,0,0,1]],[0,["_euler"],757,[1,0,0,0]]]],945]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2791,[5,"134ciMRGFNuJkp97OKJv3h",null,[[2,"cao-188",["_name"],758],[0,["_lpos"],758,[1,-189.056,0,-79.171]],[0,["_lrot"],758,[3,0,0,0,1]],[0,["_euler"],758,[1,0,0,0]]]],946]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2792,[5,"880b+xdJtFbpjU0mNb685O",null,[[2,"cao-189",["_name"],759],[0,["_lpos"],759,[1,-186.078,0,-85.086]],[0,["_lrot"],759,[3,0,0,0,1]],[0,["_euler"],759,[1,0,0,0]]]],947]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2793,[5,"27lDxwEJFH+ZKWgjvGWeOV",null,[[2,"cao-190",["_name"],760],[0,["_lpos"],760,[1,-189.234,0,-84.658]],[0,["_lrot"],760,[3,0,0,0,1]],[0,["_euler"],760,[1,0,0,0]]]],948]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2794,[5,"e7yNHAElZPUZ7E9109/5am",null,[[2,"cao-191",["_name"],761],[0,["_lpos"],761,[1,-68.049,0,-80.513]],[0,["_lrot"],761,[3,0,0,0,1]],[0,["_euler"],761,[1,0,0,0]]]],949]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2795,[5,"50d0YlLDxANr1cUFgDvpa+",null,[[2,"cao-192",["_name"],762],[0,["_lpos"],762,[1,-64.893,0,-80.941]],[0,["_lrot"],762,[3,0,0,0,1]],[0,["_euler"],762,[1,0,0,0]]]],950]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2796,[5,"f7pbZv5BdKK5Hnvue798yp",null,[[2,"cao-193",["_name"],763],[0,["_lpos"],763,[1,-67.871,0,-75.026]],[0,["_lrot"],763,[3,0,0,0,1]],[0,["_euler"],763,[1,0,0,0]]]],951]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2797,[5,"0cMa5W97lBj4+6Qpvk1931",null,[[2,"cao-194",["_name"],764],[0,["_lpos"],764,[1,-65.745,0,-76.778]],[0,["_lrot"],764,[3,0,0,0,1]],[0,["_euler"],764,[1,0,0,0]]]],952]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2798,[5,"eeyCU53FBD2KSD7LErtUEl",null,[[2,"cao-195",["_name"],765],[0,["_lpos"],765,[1,-69.166,0,-78.915]],[0,["_lrot"],765,[3,0,0,0,1]],[0,["_euler"],765,[1,0,0,0]]]],953]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2799,[5,"aff0un/HFCfKIlnwZwdoUD",null,[[2,"cao-196",["_name"],766],[0,["_lpos"],766,[1,-69.075,0,-89.309]],[0,["_lrot"],766,[3,0,0,0,1]],[0,["_euler"],766,[1,0,0,0]]]],954]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2800,[5,"56VkCbFpBIg7S/lFh6R4x2",null,[[2,"cao-197",["_name"],767],[0,["_lpos"],767,[1,-65.654,0,-87.172]],[0,["_lrot"],767,[3,0,0,0,1]],[0,["_euler"],767,[1,0,0,0]]]],955]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2801,[5,"e6jLaQlG5CR5/9dsRiMU72",null,[[2,"cao-198",["_name"],768],[0,["_lpos"],768,[1,-67.78,0,-85.42]],[0,["_lrot"],768,[3,0,0,0,1]],[0,["_euler"],768,[1,0,0,0]]]],956]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2802,[5,"81drJs/olHbLNqf7qX8MpX",null,[[2,"cao-199",["_name"],769],[0,["_lpos"],769,[1,-64.802,0,-91.335]],[0,["_lrot"],769,[3,0,0,0,1]],[0,["_euler"],769,[1,0,0,0]]]],957]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2803,[5,"93JwGlz9BByJIV/HLp/vaC",null,[[2,"cao-200",["_name"],770],[0,["_lpos"],770,[1,-67.958,0,-90.907]],[0,["_lrot"],770,[3,0,0,0,1]],[0,["_euler"],770,[1,0,0,0]]]],958]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2804,[5,"45P1YhcYFNBbPufM4Fjw3z",null,[[2,"cao-201",["_name"],771],[0,["_lpos"],771,[1,-106.556,0,-146.911]],[0,["_lrot"],771,[3,0,0,0,1]],[0,["_euler"],771,[1,0,0,0]]]],959]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2805,[5,"11WTxkydJFsJEOHzlw3YSH",null,[[2,"cao-202",["_name"],772],[0,["_lpos"],772,[1,-103.4,0,-147.339]],[0,["_lrot"],772,[3,0,0,0,1]],[0,["_euler"],772,[1,0,0,0]]]],960]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2806,[5,"a69XjHrWxI85xefGSECwDg",null,[[2,"cao-203",["_name"],773],[0,["_lpos"],773,[1,-106.378,0,-141.424]],[0,["_lrot"],773,[3,0,0,0,1]],[0,["_euler"],773,[1,0,0,0]]]],961]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2807,[5,"76mUKr+NZH47d+3Gsbd9gt",null,[[2,"cao-204",["_name"],774],[0,["_lpos"],774,[1,-104.252,0,-143.176]],[0,["_lrot"],774,[3,0,0,0,1]],[0,["_euler"],774,[1,0,0,0]]]],962]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2808,[5,"71/emYQIhANYHV2dlC9B0b",null,[[2,"cao-205",["_name"],775],[0,["_lpos"],775,[1,-107.673,0,-145.313]],[0,["_lrot"],775,[3,0,0,0,1]],[0,["_euler"],775,[1,0,0,0]]]],963]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2809,[5,"37U2xeMuFHZaZLhVkUnn8Y",null,[[2,"cao-206",["_name"],776],[0,["_lpos"],776,[1,-105.191,0,-156.473]],[0,["_lrot"],776,[3,0,0,0,1]],[0,["_euler"],776,[1,0,0,0]]]],964]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2810,[5,"dd+/YijuBHV7CATJTI5lgY",null,[[2,"cao-207",["_name"],777],[0,["_lpos"],777,[1,-101.77,0,-154.336]],[0,["_lrot"],777,[3,0,0,0,1]],[0,["_euler"],777,[1,0,0,0]]]],965]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2811,[5,"4br29QUiBDA7JA+nAvPVxG",null,[[2,"cao-208",["_name"],778],[0,["_lpos"],778,[1,-103.896,0,-152.584]],[0,["_lrot"],778,[3,0,0,0,1]],[0,["_euler"],778,[1,0,0,0]]]],966]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2812,[5,"b4ZXpBuVFAd4aNEjy2CWiA",null,[[2,"cao-209",["_name"],779],[0,["_lpos"],779,[1,-100.918,0,-158.499]],[0,["_lrot"],779,[3,0,0,0,1]],[0,["_euler"],779,[1,0,0,0]]]],967]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2813,[5,"94ClIKYIpNAo487oJOoaSB",null,[[2,"cao-210",["_name"],780],[0,["_lpos"],780,[1,-104.074,0,-158.071]],[0,["_lrot"],780,[3,0,0,0,1]],[0,["_euler"],780,[1,0,0,0]]]],968]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2814,[5,"bfqYdHmN5CW6x9c9mnH22C",null,[[2,"cao-211",["_name"],781],[0,["_lpos"],781,[1,-157.887,0,-145.502]],[0,["_lrot"],781,[3,0,0,0,1]],[0,["_euler"],781,[1,0,0,0]]]],969]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2815,[5,"acwyMEsshPzr/t/LRcUX2U",null,[[2,"cao-212",["_name"],782],[0,["_lpos"],782,[1,-154.731,0,-145.93]],[0,["_lrot"],782,[3,0,0,0,1]],[0,["_euler"],782,[1,0,0,0]]]],970]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2816,[5,"91hXz78bJGXLbRFE1iRb8O",null,[[2,"cao-213",["_name"],783],[0,["_lpos"],783,[1,-157.709,0,-140.015]],[0,["_lrot"],783,[3,0,0,0,1]],[0,["_euler"],783,[1,0,0,0]]]],971]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2817,[5,"fdnC59UNVPzJvTiX7FSvol",null,[[2,"cao-214",["_name"],784],[0,["_lpos"],784,[1,-155.583,0,-141.767]],[0,["_lrot"],784,[3,0,0,0,1]],[0,["_euler"],784,[1,0,0,0]]]],972]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2818,[5,"62OoMA1t5E/b3KGxhoxl4u",null,[[2,"cao-215",["_name"],785],[0,["_lpos"],785,[1,-159.004,0,-143.904]],[0,["_lrot"],785,[3,0,0,0,1]],[0,["_euler"],785,[1,0,0,0]]]],973]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2819,[5,"50Bc5O+uJD6LMGYvakGkR4",null,[[2,"cao-216",["_name"],786],[0,["_lpos"],786,[1,-167.651,0,-145.48]],[0,["_lrot"],786,[3,0,0,0,1]],[0,["_euler"],786,[1,0,0,0]]]],974]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2820,[5,"f7ZzuZDEdB8rpZqonVoyD6",null,[[2,"cao-217",["_name"],787],[0,["_lpos"],787,[1,-164.23,0,-143.343]],[0,["_lrot"],787,[3,0,0,0,1]],[0,["_euler"],787,[1,0,0,0]]]],975]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2821,[5,"adTSY0+ZpP0Jbyalcer8Vo",null,[[2,"cao-218",["_name"],788],[0,["_lpos"],788,[1,-166.356,0,-141.591]],[0,["_lrot"],788,[3,0,0,0,1]],[0,["_euler"],788,[1,0,0,0]]]],976]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2822,[5,"70kSL2hqdETZILZNK0Y7zX",null,[[2,"cao-219",["_name"],789],[0,["_lpos"],789,[1,-163.378,0,-147.506]],[0,["_lrot"],789,[3,0,0,0,1]],[0,["_euler"],789,[1,0,0,0]]]],977]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2823,[5,"12bO8NFmdNIK1i3jLvDZun",null,[[2,"cao-220",["_name"],790],[0,["_lpos"],790,[1,-166.534,0,-147.078]],[0,["_lrot"],790,[3,0,0,0,1]],[0,["_euler"],790,[1,0,0,0]]]],978]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2824,[5,"8eacyiBWhNFr/quHEFZ91N",null,[[2,"cao-221",["_name"],791],[0,["_lpos"],791,[1,-159.181,0,-158.639]],[0,["_lrot"],791,[3,0,0,0,1]],[0,["_euler"],791,[1,0,0,0]]]],979]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2825,[5,"fcnPjnclVJHL3r9Boq7olk",null,[[2,"cao-222",["_name"],792],[0,["_lpos"],792,[1,-156.025,0,-159.067]],[0,["_lrot"],792,[3,0,0,0,1]],[0,["_euler"],792,[1,0,0,0]]]],980]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2826,[5,"07L56pA/9OuoM+RBsEIsF0",null,[[2,"cao-223",["_name"],793],[0,["_lpos"],793,[1,-159.003,0,-153.152]],[0,["_lrot"],793,[3,0,0,0,1]],[0,["_euler"],793,[1,0,0,0]]]],981]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2827,[5,"09cA6B6+pLLaj+mD/3Aj1M",null,[[2,"cao-224",["_name"],794],[0,["_lpos"],794,[1,-156.877,0,-154.904]],[0,["_lrot"],794,[3,0,0,0,1]],[0,["_euler"],794,[1,0,0,0]]]],982]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2828,[5,"b0HFJxHaBBaYe5SO8PLq55",null,[[2,"cao-225",["_name"],795],[0,["_lpos"],795,[1,-160.298,0,-157.041]],[0,["_lrot"],795,[3,0,0,0,1]],[0,["_euler"],795,[1,0,0,0]]]],983]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2829,[5,"69zzBH3fFEYJdxa/v0G1vH",null,[[2,"cao-226",["_name"],796],[0,["_lpos"],796,[1,-169.06,0,-156.248]],[0,["_lrot"],796,[3,0,0,0,1]],[0,["_euler"],796,[1,0,0,0]]]],984]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2830,[5,"75X7QD77FKcr+nxDLhmiuR",null,[[2,"cao-227",["_name"],797],[0,["_lpos"],797,[1,-165.639,0,-154.111]],[0,["_lrot"],797,[3,0,0,0,1]],[0,["_euler"],797,[1,0,0,0]]]],985]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2831,[5,"10G+/D5JdFooUAYPRGlZEp",null,[[2,"cao-228",["_name"],798],[0,["_lpos"],798,[1,-167.765,0,-152.359]],[0,["_lrot"],798,[3,0,0,0,1]],[0,["_euler"],798,[1,0,0,0]]]],986]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2832,[5,"70vBjqt7NPu6rx5jGNY/xP",null,[[2,"cao-229",["_name"],799],[0,["_lpos"],799,[1,-164.787,0,-158.274]],[0,["_lrot"],799,[3,0,0,0,1]],[0,["_euler"],799,[1,0,0,0]]]],987]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2833,[5,"54V5lkyelP6LFKzyllElYE",null,[[2,"cao-230",["_name"],800],[0,["_lpos"],800,[1,-167.943,0,-157.846]],[0,["_lrot"],800,[3,0,0,0,1]],[0,["_euler"],800,[1,0,0,0]]]],988]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2834,[5,"beya818rZI1amhuZMUlNtj",null,[[2,"cao-231",["_name"],801],[0,["_lpos"],801,[1,-175.073,0,-146.214]],[0,["_lrot"],801,[3,0,0,0,1]],[0,["_euler"],801,[1,0,0,0]]]],989]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2835,[5,"28jZ8HLc5M2YLSJmr5Ycjz",null,[[2,"cao-232",["_name"],802],[0,["_lpos"],802,[1,-171.917,0,-146.642]],[0,["_lrot"],802,[3,0,0,0,1]],[0,["_euler"],802,[1,0,0,0]]]],990]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2836,[5,"1ab7wTk3FCq4qVvpZadmoX",null,[[2,"cao-233",["_name"],803],[0,["_lpos"],803,[1,-174.895,0,-140.727]],[0,["_lrot"],803,[3,0,0,0,1]],[0,["_euler"],803,[1,0,0,0]]]],991]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2837,[5,"7bTvg5IblH0Y0aoN2fdDTJ",null,[[2,"cao-234",["_name"],804],[0,["_lpos"],804,[1,-172.769,0,-142.479]],[0,["_lrot"],804,[3,0,0,0,1]],[0,["_euler"],804,[1,0,0,0]]]],992]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2838,[5,"4a04j4i+VAK5ix12Q4Acd6",null,[[2,"cao-235",["_name"],805],[0,["_lpos"],805,[1,-176.19,0,-144.616]],[0,["_lrot"],805,[3,0,0,0,1]],[0,["_euler"],805,[1,0,0,0]]]],993]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2839,[5,"6aEgxJGnxDkIaL/8ay8IPS",null,[[2,"cao-236",["_name"],806],[0,["_lpos"],806,[1,-161.106,0,-168.292]],[0,["_lrot"],806,[3,0,0,0,1]],[0,["_euler"],806,[1,0,0,0]]]],994]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2840,[5,"4fhtUzlJBHM4hK0w0tFY0p",null,[[2,"cao-237",["_name"],807],[0,["_lpos"],807,[1,-157.685,0,-166.155]],[0,["_lrot"],807,[3,0,0,0,1]],[0,["_euler"],807,[1,0,0,0]]]],995]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2841,[5,"c4tGoPjzREr6kOk0Avzxo9",null,[[2,"cao-238",["_name"],808],[0,["_lpos"],808,[1,-159.811,0,-164.403]],[0,["_lrot"],808,[3,0,0,0,1]],[0,["_euler"],808,[1,0,0,0]]]],996]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2842,[5,"25P3NBf6dNopZ+mC0J2QYf",null,[[2,"cao-239",["_name"],809],[0,["_lpos"],809,[1,-156.833,0,-170.318]],[0,["_lrot"],809,[3,0,0,0,1]],[0,["_euler"],809,[1,0,0,0]]]],997]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2843,[5,"ceWuFjzbpCbog7q4p3bv6I",null,[[2,"cao-240",["_name"],810],[0,["_lpos"],810,[1,-159.989,0,-169.89]],[0,["_lrot"],810,[3,0,0,0,1]],[0,["_euler"],810,[1,0,0,0]]]],998]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2844,[5,"2f7h0pzlFMgLca9IGNbn26",null,[[2,"cao-241",["_name"],811],[0,["_lpos"],811,[1,-129.276,0,-173.023]],[0,["_lrot"],811,[3,0,0,0,1]],[0,["_euler"],811,[1,0,0,0]]]],999]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2845,[5,"45Ekr5iyNIVJqfqrZJWFrU",null,[[2,"cao-242",["_name"],812],[0,["_lpos"],812,[1,-126.12,0,-173.451]],[0,["_lrot"],812,[3,0,0,0,1]],[0,["_euler"],812,[1,0,0,0]]]],1000]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2846,[5,"0ebCuvMrtNqoAQ0UI1yOAs",null,[[2,"cao-243",["_name"],813],[0,["_lpos"],813,[1,-129.098,0,-167.536]],[0,["_lrot"],813,[3,0,0,0,1]],[0,["_euler"],813,[1,0,0,0]]]],1001]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2847,[5,"c65/zwNEVF1YX2RCTTlucE",null,[[2,"cao-244",["_name"],814],[0,["_lpos"],814,[1,-126.972,0,-169.288]],[0,["_lrot"],814,[3,0,0,0,1]],[0,["_euler"],814,[1,0,0,0]]]],1002]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2848,[5,"18B42XSvRAz4TUvTaHizNJ",null,[[2,"cao-245",["_name"],815],[0,["_lpos"],815,[1,-130.393,0,-171.425]],[0,["_lrot"],815,[3,0,0,0,1]],[0,["_euler"],815,[1,0,0,0]]]],1003]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2849,[5,"f97RoanMFB0r0a3ubmL6w3",null,[[2,"cao-246",["_name"],816],[0,["_lpos"],816,[1,-130.859,0,-183.861]],[0,["_lrot"],816,[3,0,0,0,1]],[0,["_euler"],816,[1,0,0,0]]]],1004]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2850,[5,"3eyhTc2r9Il4JlDYYmONNm",null,[[2,"cao-247",["_name"],817],[0,["_lpos"],817,[1,-127.438,0,-181.724]],[0,["_lrot"],817,[3,0,0,0,1]],[0,["_euler"],817,[1,0,0,0]]]],1005]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2851,[5,"beosVFJuBHapqewoXXsxFm",null,[[2,"cao-248",["_name"],818],[0,["_lpos"],818,[1,-129.564,0,-179.972]],[0,["_lrot"],818,[3,0,0,0,1]],[0,["_euler"],818,[1,0,0,0]]]],1006]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2852,[5,"b54C6kM2RPG6P4AsP/Sfdt",null,[[2,"cao-249",["_name"],819],[0,["_lpos"],819,[1,-126.586,0,-185.887]],[0,["_lrot"],819,[3,0,0,0,1]],[0,["_euler"],819,[1,0,0,0]]]],1007]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2853,[5,"02tsgPMapD/6/3Ky4IcC9x",null,[[2,"cao-250",["_name"],820],[0,["_lpos"],820,[1,-129.742,0,-185.459]],[0,["_lrot"],820,[3,0,0,0,1]],[0,["_euler"],820,[1,0,0,0]]]],1008]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2854,[5,"8dLTz9BgVG3YzyJnMwsFjy",null,[[2,"cao-251",["_name"],821],[0,["_lpos"],821,[1,-119.222,0,-182.608]],[0,["_lrot"],821,[3,0,0,0,1]],[0,["_euler"],821,[1,0,0,0]]]],1009]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2855,[5,"9cM3cJFdFNlZy5GLt273MR",null,[[2,"cao-252",["_name"],822],[0,["_lpos"],822,[1,-116.066,0,-183.036]],[0,["_lrot"],822,[3,0,0,0,1]],[0,["_euler"],822,[1,0,0,0]]]],1010]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2856,[5,"2a09roSyxJc7BX4Zk6Oh7d",null,[[2,"cao-253",["_name"],823],[0,["_lpos"],823,[1,-119.044,0,-177.121]],[0,["_lrot"],823,[3,0,0,0,1]],[0,["_euler"],823,[1,0,0,0]]]],1011]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2857,[5,"9fHsQwAvdId6Bo8nO0hd+Q",null,[[2,"cao-254",["_name"],824],[0,["_lpos"],824,[1,-116.918,0,-178.873]],[0,["_lrot"],824,[3,0,0,0,1]],[0,["_euler"],824,[1,0,0,0]]]],1012]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2858,[5,"balsAv8A9NCbyyiGH2wqQE",null,[[2,"cao-255",["_name"],825],[0,["_lpos"],825,[1,-120.339,0,-181.01]],[0,["_lrot"],825,[3,0,0,0,1]],[0,["_euler"],825,[1,0,0,0]]]],1013]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2859,[5,"eePojVZ51AC5Swi242ts2B",null,[[2,"cao-256",["_name"],826],[0,["_lpos"],826,[1,-131.042,0,-208.261]],[0,["_lrot"],826,[3,0,0,0,1]],[0,["_euler"],826,[1,0,0,0]]]],1014]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2860,[5,"75p3C7dm5G6KyMmYUwgBvC",null,[[2,"cao-257",["_name"],827],[0,["_lpos"],827,[1,-127.621,0,-206.124]],[0,["_lrot"],827,[3,0,0,0,1]],[0,["_euler"],827,[1,0,0,0]]]],1015]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2861,[5,"d0oxu9HsFMx5L9WQxDSANt",null,[[2,"cao-258",["_name"],828],[0,["_lpos"],828,[1,-129.747,0,-204.372]],[0,["_lrot"],828,[3,0,0,0,1]],[0,["_euler"],828,[1,0,0,0]]]],1016]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2862,[5,"25PzI7jyRGapLpZEJaE9GL",null,[[2,"cao-259",["_name"],829],[0,["_lpos"],829,[1,-126.769,0,-210.287]],[0,["_lrot"],829,[3,0,0,0,1]],[0,["_euler"],829,[1,0,0,0]]]],1017]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2863,[5,"04zaidq91L/YzphyNMykiS",null,[[2,"cao-260",["_name"],830],[0,["_lpos"],830,[1,-129.925,0,-209.859]],[0,["_lrot"],830,[3,0,0,0,1]],[0,["_euler"],830,[1,0,0,0]]]],1018]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2864,[5,"e1fqTbVnNDsq4BE6RMum4g",null,[[2,"cao-261",["_name"],831],[0,["_lpos"],831,[1,-126.688,0,-199.525]],[0,["_lrot"],831,[3,0,0,0,1]],[0,["_euler"],831,[1,0,0,0]]]],1019]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2865,[5,"134r6WJGpK3YUnPgJcbScu",null,[[2,"cao-262",["_name"],832],[0,["_lpos"],832,[1,-123.532,0,-199.953]],[0,["_lrot"],832,[3,0,0,0,1]],[0,["_euler"],832,[1,0,0,0]]]],1020]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2866,[5,"96SIFVCiJC+bLa2mnxsV1W",null,[[2,"cao-263",["_name"],833],[0,["_lpos"],833,[1,-126.51,0,-194.038]],[0,["_lrot"],833,[3,0,0,0,1]],[0,["_euler"],833,[1,0,0,0]]]],1021]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2867,[5,"48E2QGHXZCY5UH0WjYnYLz",null,[[2,"cao-264",["_name"],834],[0,["_lpos"],834,[1,-124.384,0,-195.79]],[0,["_lrot"],834,[3,0,0,0,1]],[0,["_euler"],834,[1,0,0,0]]]],1022]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2868,[5,"d86SOvrb5MrZZtF9B/vE1O",null,[[2,"cao-265",["_name"],835],[0,["_lpos"],835,[1,-127.805,0,-197.927]],[0,["_lrot"],835,[3,0,0,0,1]],[0,["_euler"],835,[1,0,0,0]]]],1023]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2869,[5,"e0f1zZrXpAy4tgbPtX2ogU",null,[[2,"cao-266",["_name"],836],[0,["_lpos"],836,[1,-119.691,0,-204.82]],[0,["_lrot"],836,[3,0,0,0,1]],[0,["_euler"],836,[1,0,0,0]]]],1024]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2870,[5,"77VkgxR1FGDottFrp5Gegn",null,[[2,"cao-267",["_name"],837],[0,["_lpos"],837,[1,-116.27,0,-202.683]],[0,["_lrot"],837,[3,0,0,0,1]],[0,["_euler"],837,[1,0,0,0]]]],1025]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2871,[5,"27bXFG9U1DW5eGLkdpTXUG",null,[[2,"cao-268",["_name"],838],[0,["_lpos"],838,[1,-118.396,0,-200.931]],[0,["_lrot"],838,[3,0,0,0,1]],[0,["_euler"],838,[1,0,0,0]]]],1026]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2872,[5,"c5Gg6uAMhPKIRU1HJ9AH2N",null,[[2,"cao-269",["_name"],839],[0,["_lpos"],839,[1,-115.418,0,-206.846]],[0,["_lrot"],839,[3,0,0,0,1]],[0,["_euler"],839,[1,0,0,0]]]],1027]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2873,[5,"3dMIQ/YypOLIJEqYtRl3A9",null,[[2,"cao-270",["_name"],840],[0,["_lpos"],840,[1,-118.574,0,-206.418]],[0,["_lrot"],840,[3,0,0,0,1]],[0,["_euler"],840,[1,0,0,0]]]],1028]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2874,[5,"efPO0Wml5CG7/2keSC+GeF",null,[[2,"cao-271",["_name"],841],[0,["_lpos"],841,[1,-112.677,0,-177.635]],[0,["_lrot"],841,[3,0,0,0,1]],[0,["_euler"],841,[1,0,0,0]]]],1029]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2875,[5,"57pgKpNO9O0Ky/EDeqNslV",null,[[2,"cao-272",["_name"],842],[0,["_lpos"],842,[1,-109.521,0,-178.063]],[0,["_lrot"],842,[3,0,0,0,1]],[0,["_euler"],842,[1,0,0,0]]]],1030]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2876,[5,"eaPuxu0LFI0ZQFeSutp+9q",null,[[2,"cao-273",["_name"],843],[0,["_lpos"],843,[1,-112.499,0,-172.148]],[0,["_lrot"],843,[3,0,0,0,1]],[0,["_euler"],843,[1,0,0,0]]]],1031]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2877,[5,"8b856mlf5NHaiHbDIoFpJ0",null,[[2,"cao-274",["_name"],844],[0,["_lpos"],844,[1,-110.373,0,-173.9]],[0,["_lrot"],844,[3,0,0,0,1]],[0,["_euler"],844,[1,0,0,0]]]],1032]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2878,[5,"d38zFmkT5EtZDBud8FYjg1",null,[[2,"cao-275",["_name"],845],[0,["_lpos"],845,[1,-113.794,0,-176.037]],[0,["_lrot"],845,[3,0,0,0,1]],[0,["_euler"],845,[1,0,0,0]]]],1033]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2879,[5,"59D18Wx9tFJKA2KD/gV9Ny",null,[[2,"cao-276",["_name"],846],[0,["_lpos"],846,[1,-159.158,0,-238.775]],[0,["_lrot"],846,[3,0,0,0,1]],[0,["_euler"],846,[1,0,0,0]]]],1034]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2880,[5,"61pU2HvVdJdZK+mMcZbNVC",null,[[2,"cao-277",["_name"],847],[0,["_lpos"],847,[1,-155.737,0,-236.638]],[0,["_lrot"],847,[3,0,0,0,1]],[0,["_euler"],847,[1,0,0,0]]]],1035]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2881,[5,"e08yXksrZOl5SQbqSr5G5f",null,[[2,"cao-278",["_name"],848],[0,["_lpos"],848,[1,-157.863,0,-234.886]],[0,["_lrot"],848,[3,0,0,0,1]],[0,["_euler"],848,[1,0,0,0]]]],1036]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2882,[5,"6fO7xmhs1PipLFF+ly0arH",null,[[2,"cao-279",["_name"],849],[0,["_lpos"],849,[1,-154.885,0,-240.801]],[0,["_lrot"],849,[3,0,0,0,1]],[0,["_euler"],849,[1,0,0,0]]]],1037]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2883,[5,"7aW1HF8o1F3I1J91lyY+u8",null,[[2,"cao-280",["_name"],850],[0,["_lpos"],850,[1,-158.041,0,-240.373]],[0,["_lrot"],850,[3,0,0,0,1]],[0,["_euler"],850,[1,0,0,0]]]],1038]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2884,[5,"0cnpWIN11GFrsUfnpsxMpT",null,[[2,"cao-281",["_name"],851],[0,["_lpos"],851,[1,-129.772,0,-242.013]],[0,["_lrot"],851,[3,0,0,0,1]],[0,["_euler"],851,[1,0,0,0]]]],1039]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2885,[5,"7227+n2+dIEKftAaxtDUR/",null,[[2,"cao-282",["_name"],852],[0,["_lpos"],852,[1,-126.616,0,-242.441]],[0,["_lrot"],852,[3,0,0,0,1]],[0,["_euler"],852,[1,0,0,0]]]],1040]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2886,[5,"916OSAkOpBqq3Kf8uB574/",null,[[2,"cao-283",["_name"],853],[0,["_lpos"],853,[1,-129.594,0,-236.526]],[0,["_lrot"],853,[3,0,0,0,1]],[0,["_euler"],853,[1,0,0,0]]]],1041]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2887,[5,"ffS2GSkupKJooMJYQ5Iwrv",null,[[2,"cao-284",["_name"],854],[0,["_lpos"],854,[1,-127.468,0,-238.278]],[0,["_lrot"],854,[3,0,0,0,1]],[0,["_euler"],854,[1,0,0,0]]]],1042]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2888,[5,"efq5zBbrRMq6ECdxs5m5mZ",null,[[2,"cao-285",["_name"],855],[0,["_lpos"],855,[1,-130.889,0,-240.415]],[0,["_lrot"],855,[3,0,0,0,1]],[0,["_euler"],855,[1,0,0,0]]]],1043]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2889,[5,"c19fTrpnZEVYt7DkcsACCY",null,[[2,"cao-286",["_name"],856],[0,["_lpos"],856,[1,-119.919,0,-240.137]],[0,["_lrot"],856,[3,0,0,0,1]],[0,["_euler"],856,[1,0,0,0]]]],1044]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2890,[5,"1b8WA7lcVMNIqGxcvtAZy+",null,[[2,"cao-287",["_name"],857],[0,["_lpos"],857,[1,-116.498,0,-238]],[0,["_lrot"],857,[3,0,0,0,1]],[0,["_euler"],857,[1,0,0,0]]]],1045]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2891,[5,"89hiSV2chAfILVIPkJ4Wq0",null,[[2,"cao-288",["_name"],858],[0,["_lpos"],858,[1,-118.624,0,-236.248]],[0,["_lrot"],858,[3,0,0,0,1]],[0,["_euler"],858,[1,0,0,0]]]],1046]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2892,[5,"21sNjK4eZIm7Ldarvuzjdi",null,[[2,"cao-289",["_name"],859],[0,["_lpos"],859,[1,-115.646,0,-242.163]],[0,["_lrot"],859,[3,0,0,0,1]],[0,["_euler"],859,[1,0,0,0]]]],1047]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2893,[5,"3cOYXkBWtFPqCDyQLoDXLt",null,[[2,"cao-290",["_name"],860],[0,["_lpos"],860,[1,-118.802,0,-241.735]],[0,["_lrot"],860,[3,0,0,0,1]],[0,["_euler"],860,[1,0,0,0]]]],1048]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2894,[5,"11YXdA02JN+6PR8z4JkEqV",null,[[2,"cao-291",["_name"],861],[0,["_lpos"],861,[1,-118.802,0,-241.735]],[0,["_lrot"],861,[3,0,0,0,1]],[0,["_euler"],861,[1,0,0,0]]]],1049]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2895,[5,"c0GVcc999CZ7J+ynikyUSN",null,[[2,"cao-292",["_name"],862],[0,["_lpos"],862,[1,-115.646,0,-242.163]],[0,["_lrot"],862,[3,0,0,0,1]],[0,["_euler"],862,[1,0,0,0]]]],1050]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2896,[5,"d2On+pDAxPUIXEFsOM57IP",null,[[2,"cao-293",["_name"],863],[0,["_lpos"],863,[1,-118.624,0,-236.248]],[0,["_lrot"],863,[3,0,0,0,1]],[0,["_euler"],863,[1,0,0,0]]]],1051]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2897,[5,"38Wz5x7BtEgLPaOaTVpTZy",null,[[2,"cao-294",["_name"],864],[0,["_lpos"],864,[1,-116.498,0,-238]],[0,["_lrot"],864,[3,0,0,0,1]],[0,["_euler"],864,[1,0,0,0]]]],1052]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2898,[5,"2bBDHhQGJK+amCdTIRcyyd",null,[[2,"cao-295",["_name"],865],[0,["_lpos"],865,[1,-119.919,0,-240.137]],[0,["_lrot"],865,[3,0,0,0,1]],[0,["_euler"],865,[1,0,0,0]]]],1053]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2899,[5,"c2GPQRIvZGFbzdHDAM6i/A",null,[[2,"cao-296",["_name"],866],[0,["_lpos"],866,[1,-110.198,0,-240.148]],[0,["_lrot"],866,[3,0,0,0,1]],[0,["_euler"],866,[1,0,0,0]]]],1054]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2900,[5,"f20viEy3NLkJ3RcmIiHuWZ",null,[[2,"cao-297",["_name"],867],[0,["_lpos"],867,[1,-106.777,0,-238.011]],[0,["_lrot"],867,[3,0,0,0,1]],[0,["_euler"],867,[1,0,0,0]]]],1055]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2901,[5,"65/M8aNV9LZbJi1yryKgF1",null,[[2,"cao-298",["_name"],868],[0,["_lpos"],868,[1,-108.903,0,-236.259]],[0,["_lrot"],868,[3,0,0,0,1]],[0,["_euler"],868,[1,0,0,0]]]],1056]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2902,[5,"6cnvQX7y5NApEpfwvO3HCC",null,[[2,"cao-299",["_name"],869],[0,["_lpos"],869,[1,-105.925,0,-242.174]],[0,["_lrot"],869,[3,0,0,0,1]],[0,["_euler"],869,[1,0,0,0]]]],1057]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2903,[5,"80PEgE1XJMorJToxx/IPiJ",null,[[2,"cao-300",["_name"],870],[0,["_lpos"],870,[1,-109.081,0,-241.746]],[0,["_lrot"],870,[3,0,0,0,1]],[0,["_euler"],870,[1,0,0,0]]]],1058]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2904,[5,"dfMOXkvK9OnqFMTt4HJael",null,[[2,"cao-301",["_name"],871],[0,["_lpos"],871,[1,-128.547,0,-255.576]],[0,["_lrot"],871,[3,0,0,0,1]],[0,["_euler"],871,[1,0,0,0]]]],1059]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2905,[5,"a5o45L2mNNmLZ9wSVwCe1i",null,[[2,"cao-302",["_name"],872],[0,["_lpos"],872,[1,-125.391,0,-256.004]],[0,["_lrot"],872,[3,0,0,0,1]],[0,["_euler"],872,[1,0,0,0]]]],1060]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2906,[5,"c2WHl5GE1G9I6x2k5vsqc3",null,[[2,"cao-303",["_name"],873],[0,["_lpos"],873,[1,-128.369,0,-250.089]],[0,["_lrot"],873,[3,0,0,0,1]],[0,["_euler"],873,[1,0,0,0]]]],1061]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2907,[5,"40enQ8b3VJZa2scnXk449C",null,[[2,"cao-304",["_name"],874],[0,["_lpos"],874,[1,-126.243,0,-251.841]],[0,["_lrot"],874,[3,0,0,0,1]],[0,["_euler"],874,[1,0,0,0]]]],1062]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2908,[5,"87bJopgcxHR4O96FIT8gom",null,[[2,"cao-305",["_name"],875],[0,["_lpos"],875,[1,-129.664,0,-253.978]],[0,["_lrot"],875,[3,0,0,0,1]],[0,["_euler"],875,[1,0,0,0]]]],1063]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2909,[5,"b98Py4P/lJgphV94CchfLW",null,[[2,"cao-306",["_name"],876],[0,["_lpos"],876,[1,-130.652,0,-267.233]],[0,["_lrot"],876,[3,0,0,0,1]],[0,["_euler"],876,[1,0,0,0]]]],1064]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2910,[5,"028hQwE7RLLr42sIARAc/v",null,[[2,"cao-307",["_name"],877],[0,["_lpos"],877,[1,-127.231,0,-265.096]],[0,["_lrot"],877,[3,0,0,0,1]],[0,["_euler"],877,[1,0,0,0]]]],1065]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2911,[5,"0aVKVnO89A7IIM3ocKT6w6",null,[[2,"cao-308",["_name"],878],[0,["_lpos"],878,[1,-129.357,0,-263.344]],[0,["_lrot"],878,[3,0,0,0,1]],[0,["_euler"],878,[1,0,0,0]]]],1066]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2912,[5,"ecQG5hU5BD6ZegSGQR+4UG",null,[[2,"cao-309",["_name"],879],[0,["_lpos"],879,[1,-126.379,0,-269.259]],[0,["_lrot"],879,[3,0,0,0,1]],[0,["_euler"],879,[1,0,0,0]]]],1067]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2913,[5,"309Yot6iZO+IGHjufW8xeM",null,[[2,"cao-310",["_name"],880],[0,["_lpos"],880,[1,-129.535,0,-268.831]],[0,["_lrot"],880,[3,0,0,0,1]],[0,["_euler"],880,[1,0,0,0]]]],1068]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2914,[5,"a5yhig8LBOUboQWjyzfcBd",null,[[2,"cao-311",["_name"],881],[0,["_lpos"],881,[1,-117.272,0,-267.209]],[0,["_lrot"],881,[3,0,0,0,1]],[0,["_euler"],881,[1,0,0,0]]]],1069]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2915,[5,"82Kw64/DRA7orNSN0RSbS0",null,[[2,"cao-312",["_name"],882],[0,["_lpos"],882,[1,-114.116,0,-267.637]],[0,["_lrot"],882,[3,0,0,0,1]],[0,["_euler"],882,[1,0,0,0]]]],1070]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2916,[5,"66cuouRE1Ee5R6rfe/4xPq",null,[[2,"cao-313",["_name"],883],[0,["_lpos"],883,[1,-117.094,0,-261.722]],[0,["_lrot"],883,[3,0,0,0,1]],[0,["_euler"],883,[1,0,0,0]]]],1071]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2917,[5,"509x4Cm3xNT5ITMSnSSl9w",null,[[2,"cao-314",["_name"],884],[0,["_lpos"],884,[1,-114.968,0,-263.474]],[0,["_lrot"],884,[3,0,0,0,1]],[0,["_euler"],884,[1,0,0,0]]]],1072]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2918,[5,"3eCs/gbnxN16QeVrKCbIHK",null,[[2,"cao-315",["_name"],885],[0,["_lpos"],885,[1,-118.389,0,-265.611]],[0,["_lrot"],885,[3,0,0,0,1]],[0,["_euler"],885,[1,0,0,0]]]],1073]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2919,[5,"2cnjsyFb9Ja64Ix/PdDDgd",null,[[2,"cao-316",["_name"],886],[0,["_lpos"],886,[1,-102.264,0,-238.606]],[0,["_lrot"],886,[3,0,0,0,1]],[0,["_euler"],886,[1,0,0,0]]]],1074]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2920,[5,"b0EPg9ApdOkYFMYD7QD4d5",null,[[2,"cao-317",["_name"],887],[0,["_lpos"],887,[1,-98.843,0,-236.469]],[0,["_lrot"],887,[3,0,0,0,1]],[0,["_euler"],887,[1,0,0,0]]]],1075]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2921,[5,"33el5i9t9OBb4uU/xw8Inx",null,[[2,"cao-318",["_name"],888],[0,["_lpos"],888,[1,-100.969,0,-234.717]],[0,["_lrot"],888,[3,0,0,0,1]],[0,["_euler"],888,[1,0,0,0]]]],1076]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2922,[5,"1dNCkxiJhBhYAeq38+5+M1",null,[[2,"cao-319",["_name"],889],[0,["_lpos"],889,[1,-97.991,0,-240.632]],[0,["_lrot"],889,[3,0,0,0,1]],[0,["_euler"],889,[1,0,0,0]]]],1077]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2923,[5,"83jFPp+vtM+oSWmpFF4rdQ",null,[[2,"cao-320",["_name"],890],[0,["_lpos"],890,[1,-101.147,0,-240.204]],[0,["_lrot"],890,[3,0,0,0,1]],[0,["_euler"],890,[1,0,0,0]]]],1078]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2924,[5,"b3wWvf9H9BKrRhX9YQ8Q4h",null,[[2,"cao-321",["_name"],891],[0,["_lpos"],891,[1,-158.746,0,-256.645]],[0,["_lrot"],891,[3,0,0,0,1]],[0,["_euler"],891,[1,0,0,0]]]],1079]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2925,[5,"d7k3pHtVxGdYYy6CaIeRsM",null,[[2,"cao-322",["_name"],892],[0,["_lpos"],892,[1,-155.59,0,-257.073]],[0,["_lrot"],892,[3,0,0,0,1]],[0,["_euler"],892,[1,0,0,0]]]],1080]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2926,[5,"430GiVH1JLdYRVYLwmDocQ",null,[[2,"cao-323",["_name"],893],[0,["_lpos"],893,[1,-158.568,0,-251.158]],[0,["_lrot"],893,[3,0,0,0,1]],[0,["_euler"],893,[1,0,0,0]]]],1081]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2927,[5,"f3XLRYT6tIjJ5bkHIkozLl",null,[[2,"cao-324",["_name"],894],[0,["_lpos"],894,[1,-156.442,0,-252.91]],[0,["_lrot"],894,[3,0,0,0,1]],[0,["_euler"],894,[1,0,0,0]]]],1082]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2928,[5,"e4ntoWm45HWY/r7gseThAp",null,[[2,"cao-325",["_name"],895],[0,["_lpos"],895,[1,-159.863,0,-255.047]],[0,["_lrot"],895,[3,0,0,0,1]],[0,["_euler"],895,[1,0,0,0]]]],1083]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2929,[5,"69hsPMe8ZBdb+ixH3eHR11",null,[[2,"cao-326",["_name"],896],[0,["_lpos"],896,[1,-169.486,0,-239.808]],[0,["_lrot"],896,[3,0,0,0,1]],[0,["_euler"],896,[1,0,0,0]]]],1084]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2930,[5,"8cEB/7Y9xOL5ubxOprwnSq",null,[[2,"cao-327",["_name"],897],[0,["_lpos"],897,[1,-166.065,0,-237.671]],[0,["_lrot"],897,[3,0,0,0,1]],[0,["_euler"],897,[1,0,0,0]]]],1085]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2931,[5,"89EgxD3I5GvIGcJlpBdfSb",null,[[2,"cao-328",["_name"],898],[0,["_lpos"],898,[1,-168.191,0,-235.919]],[0,["_lrot"],898,[3,0,0,0,1]],[0,["_euler"],898,[1,0,0,0]]]],1086]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2932,[5,"cfNfK+fC9ETLtnDxxPGK4j",null,[[2,"cao-329",["_name"],899],[0,["_lpos"],899,[1,-165.213,0,-241.834]],[0,["_lrot"],899,[3,0,0,0,1]],[0,["_euler"],899,[1,0,0,0]]]],1087]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2933,[5,"b4yVBTnkNDH4NTQAyaJaJi",null,[[2,"cao-330",["_name"],900],[0,["_lpos"],900,[1,-168.369,0,-241.406]],[0,["_lrot"],900,[3,0,0,0,1]],[0,["_euler"],900,[1,0,0,0]]]],1088]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2934,[5,"18YYxE+VNHnbOpi29kMTlk",null,[[2,"cao-331",["_name"],901],[0,["_lpos"],901,[1,-181.054,0,-242.16]],[0,["_lrot"],901,[3,0,0,0,1]],[0,["_euler"],901,[1,0,0,0]]]],1089]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2935,[5,"ecoemEFBFHyqb7cnss5smB",null,[[2,"cao-332",["_name"],902],[0,["_lpos"],902,[1,-177.898,0,-242.588]],[0,["_lrot"],902,[3,0,0,0,1]],[0,["_euler"],902,[1,0,0,0]]]],1090]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2936,[5,"e8PotTX79DObnj7WNID9OB",null,[[2,"cao-333",["_name"],903],[0,["_lpos"],903,[1,-180.876,0,-236.673]],[0,["_lrot"],903,[3,0,0,0,1]],[0,["_euler"],903,[1,0,0,0]]]],1091]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2937,[5,"01p2f7m+hCyYBWYxqKIm5N",null,[[2,"cao-334",["_name"],904],[0,["_lpos"],904,[1,-178.75,0,-238.425]],[0,["_lrot"],904,[3,0,0,0,1]],[0,["_euler"],904,[1,0,0,0]]]],1092]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2938,[5,"f0Dozb7EdCZKNEp2ENy2QC",null,[[2,"cao-335",["_name"],905],[0,["_lpos"],905,[1,-182.171,0,-240.562]],[0,["_lrot"],905,[3,0,0,0,1]],[0,["_euler"],905,[1,0,0,0]]]],1093]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2939,[5,"682MoYtvJNhI/QwFyWCjnP",null,[[2,"cao-336",["_name"],906],[0,["_lpos"],906,[1,-157.441,0,-257.905]],[0,["_lrot"],906,[3,0,0,0,1]],[0,["_euler"],906,[1,0,0,0]]]],1094]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2940,[5,"bfqud/iJ5HFaLLpCv2aVaJ",null,[[2,"cao-337",["_name"],907],[0,["_lpos"],907,[1,-154.285,0,-258.333]],[0,["_lrot"],907,[3,0,0,0,1]],[0,["_euler"],907,[1,0,0,0]]]],1095]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2941,[5,"11iFzwSqxK3pzbaRt8PRHI",null,[[2,"cao-338",["_name"],908],[0,["_lpos"],908,[1,-157.263,0,-252.418]],[0,["_lrot"],908,[3,0,0,0,1]],[0,["_euler"],908,[1,0,0,0]]]],1096]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2942,[5,"255KYg+ehOXqT0ngyOn7Oq",null,[[2,"cao-339",["_name"],909],[0,["_lpos"],909,[1,-155.137,0,-254.17]],[0,["_lrot"],909,[3,0,0,0,1]],[0,["_euler"],909,[1,0,0,0]]]],1097]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2943,[5,"1cEbz4ZD1G44jJ+Jyt+UwM",null,[[2,"cao-340",["_name"],910],[0,["_lpos"],910,[1,-158.558,0,-256.307]],[0,["_lrot"],910,[3,0,0,0,1]],[0,["_euler"],910,[1,0,0,0]]]],1098]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2944,[5,"95hVYRJeRAkJS5Cey6ZRcK",null,[[2,"cao-341",["_name"],911],[0,["_lpos"],911,[1,-173.826,0,-256.278]],[0,["_lrot"],911,[3,0,0,0,1]],[0,["_euler"],911,[1,0,0,0]]]],1099]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2945,[5,"27FFqPN+NOEZleZPdf9as9",null,[[2,"cao-342",["_name"],912],[0,["_lpos"],912,[1,-170.405,0,-254.141]],[0,["_lrot"],912,[3,0,0,0,1]],[0,["_euler"],912,[1,0,0,0]]]],1100]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2946,[5,"a3KxWlDRNDJZDoA6yOxe/a",null,[[2,"cao-343",["_name"],913],[0,["_lpos"],913,[1,-172.531,0,-252.389]],[0,["_lrot"],913,[3,0,0,0,1]],[0,["_euler"],913,[1,0,0,0]]]],1101]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2947,[5,"03ckE/mvdA2oevnIQ3g1QY",null,[[2,"cao-344",["_name"],914],[0,["_lpos"],914,[1,-169.553,0,-258.304]],[0,["_lrot"],914,[3,0,0,0,1]],[0,["_euler"],914,[1,0,0,0]]]],1102]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2948,[5,"f3F8lNbJhCepaFoWnrxpW6",null,[[2,"cao-345",["_name"],915],[0,["_lpos"],915,[1,-172.709,0,-257.876]],[0,["_lrot"],915,[3,0,0,0,1]],[0,["_euler"],915,[1,0,0,0]]]],1103]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2949,[5,"76VhCv9iJLmpaC90ZC+fHO",null,[[2,"cao-346",["_name"],916],[0,["_lpos"],916,[1,-180.973,0,-271.297]],[0,["_lrot"],916,[3,0,0,0,1]],[0,["_euler"],916,[1,0,0,0]]]],1104]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2950,[5,"867E18OA9MvJdVwQw3pj02",null,[[2,"cao-347",["_name"],917],[0,["_lpos"],917,[1,-177.817,0,-271.725]],[0,["_lrot"],917,[3,0,0,0,1]],[0,["_euler"],917,[1,0,0,0]]]],1105]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2951,[5,"58aNj0YD9HFKeWFw8tm994",null,[[2,"cao-348",["_name"],918],[0,["_lpos"],918,[1,-180.795,0,-265.81]],[0,["_lrot"],918,[3,0,0,0,1]],[0,["_euler"],918,[1,0,0,0]]]],1106]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2952,[5,"3aCKVtrp5F9rySZKSq9pGW",null,[[2,"cao-349",["_name"],919],[0,["_lpos"],919,[1,-178.669,0,-267.562]],[0,["_lrot"],919,[3,0,0,0,1]],[0,["_euler"],919,[1,0,0,0]]]],1107]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2953,[5,"bbE/WyEdVJQJZESoMw5CmF",null,[[2,"cao-350",["_name"],920],[0,["_lpos"],920,[1,-182.09,0,-269.699]],[0,["_lrot"],920,[3,0,0,0,1]],[0,["_euler"],920,[1,0,0,0]]]],1108]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2954,[5,"a9G2gMMLlLjaArz2E6daYb",null,[[2,"cao-351",["_name"],921],[0,["_lpos"],921,[1,-190.572,0,-253.272]],[0,["_lrot"],921,[3,0,0,0,1]],[0,["_euler"],921,[1,0,0,0]]]],1109]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2955,[5,"18De6sk0ZOxqopODUNR0tP",null,[[2,"cao-352",["_name"],922],[0,["_lpos"],922,[1,-187.151,0,-251.135]],[0,["_lrot"],922,[3,0,0,0,1]],[0,["_euler"],922,[1,0,0,0]]]],1110]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2956,[5,"a0TRmgQ01E0L2hODfpKkrW",null,[[2,"cao-353",["_name"],923],[0,["_lpos"],923,[1,-189.277,0,-249.383]],[0,["_lrot"],923,[3,0,0,0,1]],[0,["_euler"],923,[1,0,0,0]]]],1111]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2957,[5,"952hrdFOdEJ5LD2C4PH7as",null,[[2,"cao-354",["_name"],924],[0,["_lpos"],924,[1,-186.299,0,-255.298]],[0,["_lrot"],924,[3,0,0,0,1]],[0,["_euler"],924,[1,0,0,0]]]],1112]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2958,[5,"28PvIdGiZDG6GDbiMPirPv",null,[[2,"cao-355",["_name"],925],[0,["_lpos"],925,[1,-189.455,0,-254.87]],[0,["_lrot"],925,[3,0,0,0,1]],[0,["_euler"],925,[1,0,0,0]]]],1113]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2959,[5,"67hJUdEYtOYrd9ZEgTsRmJ",null,[[2,"cao-356",["_name"],926],[0,["_lpos"],926,[1,-189.455,0,-254.87]],[0,["_lrot"],926,[3,0,0,0,1]],[0,["_euler"],926,[1,0,0,0]]]],1114]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2960,[5,"caNT4ssy1BkrPXa3uKeqyU",null,[[2,"cao-357",["_name"],927],[0,["_lpos"],927,[1,-186.299,0,-255.298]],[0,["_lrot"],927,[3,0,0,0,1]],[0,["_euler"],927,[1,0,0,0]]]],1115]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2961,[5,"1e0tULQ71I478onFP8NKDp",null,[[2,"cao-358",["_name"],928],[0,["_lpos"],928,[1,-189.277,0,-249.383]],[0,["_lrot"],928,[3,0,0,0,1]],[0,["_euler"],928,[1,0,0,0]]]],1116]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2962,[5,"e6MdLXcahNrLeikb1ckgBy",null,[[2,"cao-359",["_name"],929],[0,["_lpos"],929,[1,-187.151,0,-251.135]],[0,["_lrot"],929,[3,0,0,0,1]],[0,["_euler"],929,[1,0,0,0]]]],1117]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2963,[5,"80OQGXl6VK7bIu8ll0jwzm",null,[[2,"cao-360",["_name"],930],[0,["_lpos"],930,[1,-190.572,0,-253.272]],[0,["_lrot"],930,[3,0,0,0,1]],[0,["_euler"],930,[1,0,0,0]]]],1118]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2964,[5,"1bRAY0UqxHRKVN29fsGmxG",null,[[2,"cao-361",["_name"],931],[0,["_lpos"],931,[1,-187.089,0,-198.421]],[0,["_lrot"],931,[3,0,0,0,1]],[0,["_euler"],931,[1,0,0,0]]]],1119]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2965,[5,"b2U6z/jzpIlZa9+MgayI3o",null,[[2,"cao-362",["_name"],932],[0,["_lpos"],932,[1,-183.668,0,-196.284]],[0,["_lrot"],932,[3,0,0,0,1]],[0,["_euler"],932,[1,0,0,0]]]],1120]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2966,[5,"ceMJKLlTdBpbM6pqkdDUYc",null,[[2,"cao-363",["_name"],933],[0,["_lpos"],933,[1,-185.794,0,-194.532]],[0,["_lrot"],933,[3,0,0,0,1]],[0,["_euler"],933,[1,0,0,0]]]],1121]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2967,[5,"36Wef8mzBF7p84dXSmkZgy",null,[[2,"cao-364",["_name"],934],[0,["_lpos"],934,[1,-182.816,0,-200.447]],[0,["_lrot"],934,[3,0,0,0,1]],[0,["_euler"],934,[1,0,0,0]]]],1122]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2968,[5,"acO6DpbwZE7LNT6K4/BTR9",null,[[2,"cao-365",["_name"],935],[0,["_lpos"],935,[1,-185.972,0,-200.019]],[0,["_lrot"],935,[3,0,0,0,1]],[0,["_euler"],935,[1,0,0,0]]]],1123]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2969,[5,"14XfmAT55GEoPePTt9fZ+o",null,[[2,"cao-366",["_name"],936],[0,["_lpos"],936,[1,-183.471,0,-186.145]],[0,["_lrot"],936,[3,0,0,0,1]],[0,["_euler"],936,[1,0,0,0]]]],1124]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2970,[5,"feBKzcHN9NdLlMyA2LhhtI",null,[[2,"cao-367",["_name"],937],[0,["_lpos"],937,[1,-180.315,0,-186.573]],[0,["_lrot"],937,[3,0,0,0,1]],[0,["_euler"],937,[1,0,0,0]]]],1125]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2971,[5,"b4U/tHIHFEUJrU1IJI+vSl",null,[[2,"cao-368",["_name"],938],[0,["_lpos"],938,[1,-183.293,0,-180.658]],[0,["_lrot"],938,[3,0,0,0,1]],[0,["_euler"],938,[1,0,0,0]]]],1126]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2972,[5,"d78V8gd5NL0KcsGCE/HANS",null,[[2,"cao-369",["_name"],939],[0,["_lpos"],939,[1,-181.167,0,-182.41]],[0,["_lrot"],939,[3,0,0,0,1]],[0,["_euler"],939,[1,0,0,0]]]],1127]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2973,[5,"8aSaZ6aOBFIrKfp1GCw/ky",null,[[2,"cao-370",["_name"],940],[0,["_lpos"],940,[1,-184.588,0,-184.547]],[0,["_lrot"],940,[3,0,0,0,1]],[0,["_euler"],940,[1,0,0,0]]]],1128]],[4,512,null,1,[3,"c3Z2IusppTcZ0APAQQguLO",null,null,-2974,[5,"67/Xi0521O8qEhL7qfPQ4s",null,[[2,"cao-372",["_name"],941],[0,["_lpos"],941,[1,-123.079,0,-140.173]],[0,["_lrot"],941,[3,0,0,0,1]],[0,["_euler"],941,[1,0,0,0]]]],1129]],[72,"Warn1",4,[[23,"Cube<ModelComponent>",false,-2975,[1136],[9],1137],[27,-2976,[1,1,1,10]]],[1,6.153,0.5,-21.031],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[39,"Warn4",4,[[23,"Cube<ModelComponent>",false,-2977,[1138],[9],1139],[27,-2978,[1,1,1,10]]],[1,-69.456,0.5,-61.995]],[39,"Warn2",4,[[23,"Cube<ModelComponent>",false,-2979,[1140],[9],1141],[27,-2980,[1,10,1,1]]],[1,-142.623,0.5,-81.445]],[39,"Warn3",4,[[23,"Cube<ModelComponent>",false,-2981,[1142],[9],1143],[27,-2982,[1,10,1,1]]],[1,-142.623,0.5,-152.485]],[39,"Warn5",4,[[23,"Cube<ModelComponent>",false,-2983,[1144],[9],1145],[27,-2984,[1,10,1,1]]],[1,-142.623,0.5,-152.026]],[72,"Warn6",4,[[23,"Cube<ModelComponent>",false,-2985,[1146],[9],1147],[27,-2986,[1,1,1,10]]],[1,6.153,0.5,-2.655],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,90,0]],[138,"arrow",false,8388608,4,[[116,-2987,[1148],1149],[217,-2988,963,13]],[1,6.674,1.4739999999999998,62.69799999999999],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,-89.99999999999999,0,0]],[48,0,null,[3,"788ZDs7GpZlr15qKTxEgyo",null,null,-2989,[5,"97wIJDzHxC/pjVsBCoSWl1",null,[[2,"guanggao",["_name"],526],[0,["_lpos"],526,[1,-132,0,-75.055]],[0,["_lrot"],526,[3,0,0.5271931097595441,0,0.8497455060322834]],[0,["_euler"],526,[1,0,63.632,0]],[0,["_lscale"],526,[1,6,6,6]]]],1150]],[30,"Wandao1",8388608,13,[[23,"Cube<ModelComponent>",false,-2990,[1153],[9],1154],[46,-2991]],[1,6.726,0.2,-12.59],[1,0.2,0.2,0.2]],[32,"Wandao2",13,[[23,"Cube<ModelComponent>",false,-2992,[1155],[9],1156],[46,-2993]],[1,-37.265,0.2,-61.921],[1,0.2,0.2,0.2]],[32,"Wandao3",13,[[23,"Cube<ModelComponent>",false,-2994,[1157],[9],1158],[46,-2995]],[1,-130.83,0.2,-61.832],[1,0.2,0.2,0.2]],[32,"Wandao4",13,[[23,"Cube<ModelComponent>",false,-2996,[1159],[9],1160],[46,-2997]],[1,-142.391,0.2,-72.645],[1,0.2,0.2,0.2]],[4,0,null,23,[3,"46r5gLvaxZDLJuzbX9x3zW",null,null,-3000,[5,"9dQ2c1P/9FHKaJJ7ooO4G1",null,[[2,"endM",["_name"],527],[0,["_lpos"],527,[1,-142.623,0.5,-231.371]],[0,["_lrot"],527,[3,0,0,0,1]],[0,["_euler"],527,[1,0,0,0]],[0,["_lscale"],527,[1,5,5,5]],[0,["_lpos"],-2998,[1,0,0,0]],[0,["_lscale"],-2999,[1,5.5,5.5,15]]]],1161]],[30,"logo",33554432,18,[[12,-3001,[5,510,351]],[24,-3002,1166]],[1,0,255.978,0],[1,0.8,0.8,1]],[70,"bg",33554432,949,[[12,-3003,[5,596,193]],[24,-3004,1175]],[1,0.55,0.55,1]],[100,"lihua",33554432,19,[[44,-3005],[216,1,442.5,2,1,40,25,17,22,20,-1330,85,-1184,390,150,7,-58,885,-3006,[0,350,30],[0,0,-340],[4,4294967295],[4,4294967295],[4,4294967295],1177]],[1,0,-26.137,0]],[30,"logo",33554432,34,[[12,-3007,[5,510,351]],[24,-3008,1178]],[1,0,255.978,0],[1,0.8,0.8,1]],[70,"bg",33554432,952,[[12,-3009,[5,596,193]],[24,-3010,1187]],[1,0.55,0.55,1]],[4,0,{},10,[154,"18DHm6XMpAsr6zhFX96aQO",null,-3011,[5,"7exXf0HMROP4lPXxddvaOR",null,[[2,"loading",["_name"],530],[0,["_lpos"],530,[1,0,0,0]],[0,["_lrot"],530,[3,0,0,0,1]],[0,["_euler"],530,[1,0,0,0]],[2,true,["_active"],530],[6,["_lpos"],[1,["febgr6MPRCC4Fd0FK422g0","d16GGxojZHlb5gaunhqOxQ"]],[1,0,-460.304,0]],[6,["_contentSize"],[1,["84hCeYcTpE8JEqL6BlFj9w"]],[5,393.34,63]],[6,["_lpos"],[1,["aaySSlkM1OCK34UxJRLLrz"]],[1,-221.66999999999996,0,0]],[6,["_contentSize"],[1,["f5E2Zc43JCdYDl9FdY/xQi"]],[5,543.3399999999999,100]],[2,44,["_alignFlags"],953],[2,88.33000000000004,["_right"],953],[2,88.33000000000004,["_left"],953],[2,543.3399999999999,["_originalWidth"],953],[2,2,["_overflow"],954],[2,"플레이어블 광고 로드 중...",["_string"],954],[2,33,["_actualFontSize"],954],[2,false,["_enableWrapText"],954]]],[[109,["icon"],[1,["06QoCkDMBFgLt46yyG+Esl"]]],[109,["yingzi"],[1,["fcBLX4JEhH/rYw9x1dwzLo"]]]],1188]],[38,"SpriteSplash",512,33554432,531,[[12,-3012,[5,4000,4000]],[42,0,-3013,[4,2181038080],1189]]],[101,"light1",512,33554432,9,[[12,-3014,[5,253,253]],[107,3,2,0.5,-3015,[0,0.5,0.5],1191]],[1,0,-5.938,0],[3,0,0,0.7071067811865475,0.7071067811865476],[1,-1,1,1],[1,0,0,90]],[101,"light2",512,33554432,9,[[12,-3016,[5,253,253]],[107,3,2,0.5,-3017,[0,0.5,0.5],1192]],[1,0,-5.938,0],[3,0,0,0.7071067811865475,0.7071067811865476],[1,-1,-1,1],[1,0,0,90]],[68,"hand",512,33554432,9,[[12,-3018,[5,177,200]],[34,0,-3019,1211]],[1,103.787,-108.09,0]],[139,"Main Light",512,"c0y6F5f+pAvI805TdmxIjx",36,[[218,6593,50000,true,-3020,[219]]],[1,0,2.097,1.493],[3,-0.30497978226339195,0.36564222164453863,0.3064527195055888,0.8242450053649394],[1,-49.257,55.399,16.389]],[140,"Logic","3ek0c1NuNCvo59Uomzb0lt",36,[[113,-3021]]],[30,"Plane",8388608,37,[[26,"Plane<ModelComponent>",-3022,[0],[9],1]],[1,0,-0.1,0],[1,200,1,200]],[141,"che",12,[-3023],[3,0,1,0,6.123233995736766e-17],[1,0.7,0.7,0.7],[1,0,180,0]],[72,"Obj3d66-7523300-2-298",1898,[[156,-3024,[2],[9],3]],[1,0.069,0,-0.008],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]],[142,"arrow",8388608,12,[[116,-3025,[4],5]],[1,0,1,-4.703],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.49999999999999994,0.49999999999999994,0.49999999999999994],[1,-89.99999999999999,0,0]],[178,"100km/h",24,30,30,2,true,964,[4,4281428652]],[150,"Camera",512,16,[-3026],[1,0,0,1000]],[213,0,1073741824,640,2000,6,41943040,1902,[4,4278190080]],[1,["77ob6KtepTu7ENQ7YIoqka"]],[77,"Particle",50,[-3027],[3,0.7071067811865475,-3.323362370880657e-16,-1.7445471763153047e-16,0.7071067811865476],[1,90,-1.2792897718775483e-14,-4.106449488734006e-14]],[117,0,true,2,40,0,1905,[46],[25],[17,3.7],[17,6],[8],[17,2],[8],[8],[8],[8],[17,2],[8],[17,1],[8],[86,[25]],[59,true,0,[17,1],[1,0,0,0]],[87,[8],[8],[8],[8]],[60,[8],[8],[8],[17,1]],[61,[8],[8],[8]],[62,[8],[8],[8],[8]],[88,[8],[8],[8]],[63,[58,1,[89,[0,1],[[43,2,1],[43,2,1]]]],[8]],[64],[65,[17,1],[8],[25],[25],-3028],[90,2,47,48]],[73,"pic",996,[[26,"Plane<ModelComponent>",-3029,[49],[9],50]],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.3,0.3,0.15],[1,-90,0,0]],[74,"faguang",8388608,50,[-3030],[1,0,0.086,0],[1,0.15,0.2,3.7]],[75,"Cube",8388608,1908,[[26,"Cube<ModelComponent>",-3031,[51],[9],52]],[3,0,0.7071067811865475,0,0.7071067811865477],[1,1.5,0.05,6],[1,0,89.99999999999999,0]],[1,["efnHtaHOReOJecvNdkfvKd"]],[77,"Particle",51,[-3032],[3,0.7071067811865475,-2.533954773597981e-16,-2.533954773597981e-16,0.7071067811865476],[1,90,0,-4.106449488734006e-14]],[220,true,2,40,1911,[55],[25],[17,6],[17,11],[8],[17,1],[8],[8],[8],[8],[17,2],[8],[17,1],[8],[86,[25]],[59,true,0,[17,1],[1,0,0,0]],[87,[8],[8],[8],[8]],[60,[8],[8],[8],[17,1]],[61,[8],[8],[8]],[62,[8],[8],[8],[8]],[88,[8],[8],[8]],[63,[58,1,[89,[0,1],[[43,2,1],[43,2,1]]]],[8]],[64],[65,[17,1],[8],[25],[25],-3033],[90,2,56,57]],[73,"pic",997,[[26,"Plane<ModelComponent>",-3034,[58],[9],59]],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.3,0.3,0.15],[1,-90,0,0]],[74,"faguang",8388608,51,[-3035],[1,0,0.086,0],[1,0.15,0.2,3.7]],[75,"Cube",8388608,1914,[[26,"Cube<ModelComponent>",-3036,[60],[9],61]],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.5,0.05,6],[1,0,89.99999999999999,0]],[77,"Particle",53,[-3037],[3,0.7071067811865475,-3.323362370880657e-16,-1.7445471763153047e-16,0.7071067811865476],[1,90,-1.2792897718775483e-14,-4.106449488734006e-14]],[117,0,true,2,40,0,1916,[63],[25],[17,3.7],[17,6],[8],[17,2],[8],[8],[8],[8],[17,2],[8],[17,1],[8],[86,[25]],[59,true,0,[17,1],[1,0,0,0]],[87,[8],[8],[8],[8]],[60,[8],[8],[8],[17,1]],[61,[8],[8],[8]],[62,[8],[8],[8],[8]],[88,[8],[8],[8]],[63,[58,1,[89,[0,1],[[43,2,1],[43,2,1]]]],[8]],[64],[65,[17,1],[8],[25],[25],-3038],[90,2,64,65]],[73,"pic",998,[[26,"Plane<ModelComponent>",-3039,[66],[9],67]],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.3,0.3,0.15],[1,-90,0,0]],[74,"faguang",8388608,53,[-3040],[1,0,0.086,0],[1,0.15,0.2,3.7]],[75,"Cube",8388608,1919,[[26,"Cube<ModelComponent>",-3041,[68],[9],69]],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.5,0.05,6],[1,0,89.99999999999999,0]],[32,"Plane",1001,[[26,"Plane<ModelComponent>",-3042,[71],[9],72]],[1,-10.517,0,-2.455],[1,2,1,3]],[102,"Plane",1003,[[26,"Plane<ModelComponent>",-3043,[74],[9],75]],[1,0,0,5.736],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,1,3],[1,0,90,0]],[102,"Plane",1005,[[26,"Plane<ModelComponent>",-3044,[77],[9],78]],[1,0,0,-8.946],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,1,3],[1,0,90,0]],[32,"Plane",1007,[[26,"Plane<ModelComponent>",-3045,[80],[9],81]],[1,5.721,0,0],[1,2.5,1,2.5]],[32,"Plane",1009,[[26,"Plane<ModelComponent>",-3046,[83],[9],84]],[1,6.12,0,-2.106],[1,2.5,1,3]],[32,"Plane",1011,[[26,"Plane<ModelComponent>",-3047,[86],[9],87]],[1,-9.955,0,1.817],[1,2,1,2.5]],[32,"Plane",6,[[26,"Plane<ModelComponent>",-3048,[89],[9],90]],[1,-2.535,0,-4.746],[1,5,1,4]],[21,"startPos",79,[-3049],[1,0,0,-94.134]],[53,"1",1928,[[23,"Cube<ModelComponent>",false,-3050,[123],[9],124]]],[31,"endPos",79,[-3051]],[53,"1",1930,[[23,"Cube<ModelComponent>",false,-3052,[125],[9],126]]],[21,"startPos",80,[-3053],[1,0,0,-94.134]],[53,"1",1932,[[23,"Cube<ModelComponent>",false,-3054,[128],[9],129]]],[31,"endPos",80,[-3055]],[53,"1",1934,[[23,"Cube<ModelComponent>",false,-3056,[130],[9],131]]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[1,["abR9WWofVfW77+dYb0ZRQt"]],[76,"warnNode1",false,4,[1,-53.683,0.5,-48.15]],[76,"warnNode2",false,4,[1,-159.527,0.5,-128.938]],[76,"warnNode3",false,4,[1,-159.527,0.5,-222.952]],[31,"guanggao",4,[1879]],[1,["46r5gLvaxZDLJuzbX9x3zW"]]],0,[0,-1,1500,0,-2,1501,0,-3,1502,0,-4,1503,0,-5,1504,0,-6,1505,0,-7,1506,0,-8,1507,0,-9,1508,0,-10,1509,0,-11,1510,0,-12,1511,0,-13,1512,0,-14,1513,0,-15,1514,0,-16,1515,0,-17,1516,0,-18,1517,0,-19,1518,0,-20,1519,0,-21,1520,0,-22,1521,0,-23,1522,0,-24,1523,0,-25,1524,0,-26,1525,0,-27,1526,0,-28,1527,0,-29,1528,0,-30,1529,0,-31,1530,0,-32,1531,0,-33,1532,0,-34,1533,0,-35,1534,0,-36,1535,0,-37,1536,0,-38,1537,0,-39,1538,0,-40,1539,0,-41,1540,0,-42,1541,0,-43,1542,0,-44,1543,0,-45,1544,0,-46,1545,0,-47,1546,0,-48,1547,0,-49,1548,0,-50,1549,0,-51,1550,0,-52,1551,0,-53,1552,0,-54,1553,0,-55,1554,0,-56,1555,0,-57,1556,0,-58,1557,0,-59,1558,0,-60,1559,0,-61,1560,0,-62,1561,0,-63,1562,0,-64,1563,0,-65,1564,0,-66,1565,0,-67,1566,0,-68,1567,0,-69,1568,0,-70,1569,0,-71,1570,0,-72,1571,0,-73,1572,0,-74,1573,0,-75,1574,0,-76,1575,0,-77,1576,0,-78,1577,0,-79,1578,0,-80,1579,0,-81,1580,0,-82,1581,0,-83,1582,0,-84,1583,0,-85,1584,0,-86,1585,0,-87,1586,0,-88,1587,0,-89,1588,0,-90,1589,0,-91,1590,0,-92,1591,0,-93,1592,0,-94,1593,0,-95,1594,0,-96,1595,0,-97,1596,0,-98,1597,0,-99,1598,0,-100,1599,0,-101,1600,0,-102,1601,0,-103,1602,0,-104,1603,0,-105,1604,0,-106,1605,0,-107,1606,0,-108,1607,0,-109,1608,0,-110,1609,0,-111,1610,0,-112,1611,0,-113,1612,0,-114,1613,0,-115,1614,0,-116,1615,0,-117,1616,0,-118,1617,0,-119,1618,0,-120,1619,0,-121,1620,0,-122,1621,0,-123,1622,0,-124,1623,0,-125,1624,0,-126,1625,0,-127,1626,0,-128,1627,0,-129,1628,0,-130,1629,0,-131,1630,0,-132,1631,0,-133,1632,0,-134,1633,0,-135,1634,0,-136,1635,0,-137,1636,0,-138,1637,0,-139,1638,0,-140,1639,0,-141,1640,0,-142,1641,0,-143,1642,0,-144,1643,0,-145,1644,0,-146,1645,0,-147,1646,0,-148,1647,0,-149,1648,0,-150,1649,0,-151,1650,0,-152,1651,0,-153,1652,0,-154,1653,0,-155,1654,0,-156,1655,0,-157,1656,0,-158,1657,0,-159,1658,0,-160,1659,0,-161,1660,0,-162,1661,0,-163,1662,0,-164,1663,0,-165,1664,0,-166,1665,0,-167,1666,0,-168,1667,0,-169,1668,0,-170,1669,0,-171,1670,0,-172,1671,0,-173,1672,0,-174,1673,0,-175,1674,0,-176,1675,0,-177,1676,0,-178,1677,0,-179,1678,0,-180,1679,0,-181,1680,0,-182,1681,0,-183,1682,0,-184,1683,0,-185,1684,0,-186,1685,0,-187,1686,0,-188,1687,0,-189,1688,0,-190,1689,0,-191,1690,0,-192,1691,0,-193,1692,0,-194,1693,0,-195,1694,0,-196,1695,0,-197,1696,0,-198,1697,0,-199,1698,0,-200,1699,0,-201,1700,0,-202,1701,0,-203,1702,0,-204,1703,0,-205,1704,0,-206,1705,0,-207,1706,0,-208,1707,0,-209,1708,0,-210,1709,0,-211,1710,0,-212,1711,0,-213,1712,0,-214,1713,0,-215,1714,0,-216,1715,0,-217,1716,0,-218,1717,0,-219,1718,0,-220,1719,0,-221,1720,0,-222,1721,0,-223,1722,0,-224,1723,0,-225,1724,0,-226,1725,0,-227,1726,0,-228,1727,0,-229,1728,0,-230,1729,0,-231,1730,0,-232,1731,0,-233,1732,0,-234,1733,0,-235,1734,0,-236,1735,0,-237,1736,0,-238,1737,0,-239,1738,0,-240,1739,0,-241,1740,0,-242,1741,0,-243,1742,0,-244,1743,0,-245,1744,0,-246,1745,0,-247,1746,0,-248,1747,0,-249,1748,0,-250,1749,0,-251,1750,0,-252,1751,0,-253,1752,0,-254,1753,0,-255,1754,0,-256,1755,0,-257,1756,0,-258,1757,0,-259,1758,0,-260,1759,0,-261,1760,0,-262,1761,0,-263,1762,0,-264,1763,0,-265,1764,0,-266,1765,0,-267,1766,0,-268,1767,0,-269,1768,0,-270,1769,0,-271,1770,0,-272,1771,0,-273,1772,0,-274,1773,0,-275,1774,0,-276,1775,0,-277,1776,0,-278,1777,0,-279,1778,0,-280,1779,0,-281,1780,0,-282,1781,0,-283,1782,0,-284,1783,0,-285,1784,0,-286,1785,0,-287,1786,0,-288,1787,0,-289,1788,0,-290,1789,0,-291,1790,0,-292,1791,0,-293,1792,0,-294,1793,0,-295,1794,0,-296,1795,0,-297,1796,0,-298,1797,0,-299,1798,0,-300,1799,0,-301,1800,0,-302,1801,0,-303,1802,0,-304,1803,0,-305,1804,0,-306,1805,0,-307,1806,0,-308,1807,0,-309,1808,0,-310,1809,0,-311,1810,0,-312,1811,0,-313,1812,0,-314,1813,0,-315,1814,0,-316,1815,0,-317,1816,0,-318,1817,0,-319,1818,0,-320,1819,0,-321,1820,0,-322,1821,0,-323,1822,0,-324,1823,0,-325,1824,0,-326,1825,0,-327,1826,0,-328,1827,0,-329,1828,0,-330,1829,0,-331,1830,0,-332,1831,0,-333,1832,0,-334,1833,0,-335,1834,0,-336,1835,0,-337,1836,0,-338,1837,0,-339,1838,0,-340,1839,0,-341,1840,0,-342,1841,0,-343,1842,0,-344,1843,0,-345,1844,0,-346,1845,0,-347,1846,0,-348,1847,0,-349,1848,0,-350,1849,0,-351,1850,0,-352,1851,0,-353,1852,0,-354,1853,0,-355,1854,0,-356,1855,0,-357,1856,0,-358,1857,0,-359,1858,0,-360,1859,0,-361,1860,0,-362,1861,0,-363,1862,0,-364,1863,0,-365,1864,0,-366,1865,0,-367,1866,0,-368,1867,0,-369,1868,0,-370,1869,0,-371,1870,0,-372,1871,0,2,2,0,-1,1097,0,-2,1098,0,-3,1099,0,-4,1100,0,-5,1101,0,-6,1102,0,-7,1103,0,-8,1104,0,-9,1105,0,-10,1106,0,-11,1107,0,-12,1108,0,-13,1109,0,-14,1110,0,-15,1111,0,-16,1112,0,-17,1113,0,-18,1114,0,-19,1115,0,-20,1116,0,-21,1117,0,-22,1118,0,-23,1119,0,-24,1120,0,-25,1121,0,-26,1122,0,-27,1123,0,-28,1124,0,-29,1125,0,-30,1126,0,-31,1127,0,-32,1128,0,-33,1129,0,-34,1130,0,-35,1131,0,-36,1132,0,-37,1133,0,-38,1134,0,-39,1135,0,-40,1136,0,-41,1137,0,-42,1138,0,-43,1139,0,-44,1140,0,-45,1141,0,-46,1142,0,-47,1143,0,-48,1144,0,-49,1145,0,-50,1146,0,-51,1147,0,-52,1148,0,-53,1149,0,-54,1150,0,-55,1151,0,-56,1152,0,-57,1153,0,-58,1154,0,-59,1155,0,-60,1156,0,-61,1157,0,-62,1158,0,-63,1159,0,-64,1160,0,-65,1161,0,-66,1162,0,-67,1163,0,-68,1164,0,-69,1165,0,-70,1166,0,-71,1167,0,-72,1168,0,-73,1169,0,-74,1170,0,-75,1171,0,-76,1172,0,-77,1173,0,-78,1174,0,-79,1175,0,-80,1176,0,-81,1177,0,-82,1178,0,-83,1179,0,-84,1180,0,-85,1181,0,-86,1182,0,-87,1183,0,-88,1184,0,-89,1185,0,-90,1186,0,-91,1187,0,-92,1188,0,-93,1189,0,-94,1190,0,-95,1191,0,-96,1192,0,-97,1193,0,-98,1194,0,-99,1195,0,-100,1196,0,-101,1197,0,-102,1198,0,-103,1199,0,-104,1200,0,-105,1201,0,-106,1202,0,-107,1203,0,-108,1204,0,-109,1205,0,-110,1206,0,-111,1207,0,-112,1208,0,-113,1209,0,-114,1210,0,-115,1211,0,-116,1212,0,-117,1213,0,-118,1214,0,-119,1215,0,-120,1216,0,-121,1217,0,-122,1218,0,-123,1219,0,-124,1220,0,-125,1221,0,-126,1222,0,-127,1223,0,-128,1224,0,-129,1225,0,-130,1226,0,-131,1227,0,-132,1228,0,-133,1229,0,-134,1230,0,-135,1231,0,-136,1232,0,-137,1233,0,-138,1234,0,-139,1235,0,-140,1236,0,-141,1237,0,-142,1238,0,-143,1239,0,-144,1240,0,-145,1241,0,-146,1242,0,-147,1243,0,-148,1244,0,-149,1245,0,-150,1246,0,-151,1247,0,-152,1248,0,-153,1249,0,-154,1250,0,-155,1251,0,-156,1252,0,-157,1253,0,-158,1254,0,-159,1255,0,-160,1256,0,-161,1257,0,-162,1258,0,-163,1259,0,-164,1260,0,-165,1261,0,-166,1262,0,-167,1263,0,-168,1264,0,-169,1265,0,-170,1266,0,-171,1267,0,-172,1268,0,-173,1269,0,-174,1270,0,-175,1271,0,-176,1272,0,-177,1273,0,-178,1274,0,-179,1275,0,-180,1276,0,-181,1277,0,-182,1278,0,-183,1279,0,-184,1280,0,-185,1281,0,-186,1282,0,-187,1283,0,-188,1284,0,-189,1285,0,-190,1286,0,-191,1287,0,-192,1288,0,-193,1289,0,-194,1290,0,-195,1291,0,-196,1292,0,-197,1293,0,-198,1294,0,-199,1295,0,-200,1296,0,-201,1297,0,-202,1298,0,-203,1299,0,-204,1300,0,-205,1301,0,-206,1302,0,-207,1303,0,-208,1304,0,-209,1305,0,-210,1306,0,-211,1307,0,-212,1308,0,-213,1309,0,-214,1310,0,-215,1311,0,-216,1312,0,-217,1313,0,-218,1314,0,-219,1315,0,-220,1316,0,-221,1317,0,-222,1318,0,-223,1319,0,-224,1320,0,-225,1321,0,-226,1322,0,-227,1323,0,-228,1324,0,-229,1325,0,-230,1326,0,-231,1327,0,-232,1328,0,-233,1329,0,-234,1330,0,-235,1331,0,-236,1332,0,-237,1333,0,-238,1334,0,-239,1335,0,-240,1336,0,-241,1337,0,-242,1338,0,-243,1339,0,-244,1340,0,-245,1341,0,-246,1342,0,-247,1343,0,-248,1344,0,-249,1345,0,-250,1346,0,-251,1347,0,-252,1348,0,-253,1349,0,-254,1350,0,-255,1351,0,-256,1352,0,-257,1353,0,-258,1354,0,-259,1355,0,-260,1356,0,-261,1357,0,-262,1358,0,-263,1359,0,-264,1360,0,-265,1361,0,-266,1362,0,-267,1363,0,-268,1364,0,-269,1365,0,-270,1366,0,-271,1367,0,-272,1368,0,-273,1369,0,-274,1370,0,-275,1371,0,2,3,0,-1,1372,0,-2,1373,0,-3,1374,0,-4,1375,0,-5,1376,0,-6,1377,0,-7,1378,0,-8,1379,0,-9,1380,0,-10,1381,0,-11,1382,0,-12,1383,0,-13,1384,0,-14,1385,0,-15,1386,0,-16,1387,0,-17,1388,0,-18,1389,0,-19,1390,0,-20,1391,0,-21,1392,0,-22,1393,0,-23,1394,0,-24,1395,0,-25,1396,0,-26,1397,0,-27,1398,0,-28,1399,0,-29,1400,0,-30,1401,0,-31,1402,0,-32,1403,0,-33,1404,0,-34,1405,0,-35,1406,0,-36,1407,0,-37,1408,0,-38,1409,0,-39,1410,0,-40,1411,0,-41,1412,0,-42,1413,0,-43,1414,0,-44,1415,0,-45,1416,0,-46,1417,0,-47,1418,0,-48,1419,0,-49,1420,0,-50,1421,0,-51,1422,0,-52,1423,0,-53,1424,0,-54,1425,0,-55,1426,0,-56,1427,0,-57,1428,0,-58,1429,0,-59,1430,0,-60,1431,0,-61,1432,0,-62,1433,0,-63,1434,0,-64,1435,0,-65,1436,0,-66,1437,0,-67,1438,0,-68,1439,0,-69,1440,0,-70,1441,0,-71,1442,0,-72,1443,0,-73,1444,0,-74,1445,0,-75,1446,0,-76,1447,0,-77,1448,0,-78,1449,0,-79,1450,0,-80,1451,0,-81,1452,0,-82,1453,0,-83,1454,0,-84,1455,0,-85,1456,0,-86,1457,0,-87,1458,0,-88,1459,0,-89,1460,0,-90,1461,0,-91,1462,0,-92,1463,0,-93,1464,0,-94,1465,0,-95,1466,0,-96,1467,0,-97,1468,0,-98,1469,0,-99,1470,0,-100,1471,0,-101,1472,0,-102,1473,0,-103,1474,0,-104,1475,0,-105,1476,0,-106,1477,0,-107,1478,0,-108,1479,0,-109,1480,0,-110,1481,0,-111,1482,0,-112,1483,0,-113,1484,0,-114,1485,0,-115,1486,0,-116,1487,0,-117,1488,0,-118,1489,0,-119,1490,0,-120,1491,0,-121,1492,0,-122,1493,0,-123,1494,0,-124,1495,0,-125,1496,0,-126,1497,0,-127,1498,0,-128,1499,0,-1,41,0,-2,7,0,-3,567,0,-4,999,0,-5,15,0,-6,13,0,-7,78,0,-8,79,0,-9,80,0,-10,5,0,-14,942,0,-15,943,0,-16,944,0,-17,1872,0,-18,1873,0,-19,1874,0,-20,1875,0,-21,1876,0,-22,1877,0,-23,1943,0,-24,1944,0,-25,1945,0,-26,1878,0,-27,1946,0,-1,1034,0,-2,1037,0,-3,1040,0,-4,1043,0,-5,1046,0,-6,1049,0,-7,1052,0,-8,1055,0,-9,1058,0,-10,1061,0,-11,1064,0,-12,1067,0,-13,1070,0,-14,1073,0,-15,1076,0,-16,1079,0,-17,1082,0,-18,1085,0,-19,1088,0,-20,1091,0,-21,1094,0,-1,1927,0,-2,1013,0,-3,1014,0,-4,1015,0,-5,1016,0,-6,1017,0,-7,1018,0,-8,1019,0,-9,1020,0,-10,1021,0,-11,1022,0,-12,1023,0,-13,1024,0,-14,1025,0,-15,1026,0,-16,1028,0,-17,1030,0,-18,1032,0,-1,982,0,-2,983,0,-3,984,0,-4,985,0,-5,986,0,-6,987,0,-7,988,0,-8,989,0,-9,990,0,-10,991,0,-11,992,0,-12,993,0,-13,994,0,-14,995,0,2,9,0,23,9,0,2,9,0,2,9,0,2,9,0,-1,1892,0,-2,1893,0,-3,532,0,-4,533,0,-5,535,0,-6,1894,0,-7,534,0,2,10,0,2,10,0,-1,1943,0,-2,1944,0,-3,1945,0,-1,51,0,-2,53,0,20,962,0,24,12,0,2,10,0,-1,536,0,-2,538,0,-3,17,0,-4,19,0,-5,1890,0,2,11,0,2,11,0,25,12,0,14,23,0,2,11,0,-1,965,0,-2,539,0,-3,540,0,-4,542,0,-5,545,0,-6,969,0,2,12,0,-2,963,0,2,12,0,-1,961,0,-2,1898,0,-3,1900,0,-1,945,0,-2,1880,0,-3,1881,0,-4,1882,0,-5,1883,0,-6,23,0,2,14,0,2,14,0,26,50,0,20,962,0,27,963,0,2,14,0,-1,955,0,-3,35,0,-1,1001,0,-2,1003,0,-3,1005,0,-4,1007,0,-5,1009,0,-6,1011,0,2,16,0,28,1903,0,2,16,0,2,16,0,-1,1902,0,2,17,0,2,17,0,2,17,0,-1,946,0,-2,18,0,2,18,0,2,18,0,-1,947,0,-2,1885,0,-3,948,0,-4,949,0,2,19,0,2,19,0,2,19,0,-1,950,0,-2,1887,0,-3,34,0,2,20,0,2,20,0,2,20,0,2,20,0,-1,966,0,2,21,0,2,21,0,2,21,0,2,21,0,-1,967,0,2,22,0,2,22,0,2,22,0,2,22,0,-1,968,0,2,23,0,2,23,0,-1,1884,0,6,52,0,6,52,0,6,52,0,6,52,0,6,52,0,2,32,0,2,32,0,-1,51,0,0,32,0,6,54,0,6,54,0,6,54,0,6,54,0,6,54,0,2,33,0,2,33,0,-1,53,0,0,33,0,2,34,0,2,34,0,-1,1888,0,-2,951,0,-3,952,0,2,35,0,2,35,0,2,35,0,2,35,0,2,35,0,-1,971,0,-2,972,0,-3,974,0,-4,975,0,-5,977,0,-6,978,0,-7,980,0,-8,981,0,-9,982,0,-10,983,0,-11,984,0,-12,985,0,-13,986,0,-14,987,0,-15,988,0,-16,989,0,-17,990,0,-18,991,0,-19,992,0,-20,993,0,-21,994,0,-22,995,0,-23,49,0,-26,999,0,-27,1002,0,-28,1004,0,-29,1006,0,-30,1008,0,-31,1010,0,-32,1012,0,-33,1013,0,-34,1014,0,-35,1015,0,-36,1016,0,-37,1017,0,-38,1018,0,-39,1019,0,-40,1020,0,-41,1021,0,-42,1022,0,-43,1023,0,-44,1024,0,-45,1025,0,-46,1026,0,-47,1028,0,-48,1030,0,-49,1032,0,-50,1884,0,-51,1035,0,-52,1036,0,-53,1038,0,-54,1039,0,-55,1041,0,-56,1042,0,-57,1044,0,-58,1045,0,-59,1047,0,-60,1048,0,-61,1050,0,-62,1051,0,-63,1053,0,-64,1054,0,-65,1056,0,-66,1057,0,-67,1059,0,-68,1060,0,-69,1062,0,-70,1063,0,-71,1065,0,-72,1066,0,-73,1068,0,-74,1069,0,-75,1071,0,-76,1072,0,-77,1074,0,-78,1075,0,-79,1077,0,-80,1078,0,-81,1080,0,-82,1081,0,-83,1083,0,-84,1084,0,-85,1086,0,-86,1087,0,-87,1089,0,-88,1090,0,-89,1092,0,-90,1093,0,-91,1095,0,-92,1096,0,-93,1097,0,-94,1098,0,-95,1099,0,-96,1100,0,-97,1101,0,-98,1102,0,-99,1103,0,-100,1104,0,-101,1105,0,-102,1106,0,-103,1107,0,-104,1108,0,-105,1109,0,-106,1110,0,-107,1111,0,-108,1112,0,-109,1113,0,-110,1114,0,-111,1115,0,-112,1116,0,-113,1117,0,-114,1118,0,-115,1119,0,-116,1120,0,-117,1121,0,-118,1122,0,-119,1123,0,-120,1124,0,-121,1125,0,-122,1126,0,-123,1127,0,-124,1128,0,-125,1129,0,-126,1130,0,-127,1131,0,-128,1132,0,-129,1133,0,-130,1134,0,-131,1135,0,-132,1136,0,-133,1137,0,-134,1138,0,-135,1139,0,-136,1140,0,-137,1141,0,-138,1142,0,-139,1143,0,-140,1144,0,-141,1145,0,-142,1146,0,-143,1147,0,-144,1148,0,-145,1149,0,-146,1150,0,-147,1151,0,-148,1152,0,-149,1153,0,-150,1154,0,-151,1155,0,-152,1156,0,-153,1157,0,-154,1158,0,-155,1159,0,-156,1160,0,-157,1161,0,-158,1162,0,-159,1163,0,-160,1164,0,-161,1165,0,-162,1166,0,-163,1167,0,-164,1168,0,-165,1169,0,-166,1170,0,-167,1171,0,-168,1172,0,-169,1173,0,-170,1174,0,-171,1175,0,-172,1176,0,-173,1177,0,-174,1178,0,-175,1179,0,-176,1180,0,-177,1181,0,-178,1182,0,-179,1183,0,-180,1184,0,-181,1185,0,-182,1186,0,-183,1187,0,-184,1188,0,-185,1189,0,-186,1190,0,-187,1191,0,-188,1192,0,-189,1193,0,-190,1194,0,-191,1195,0,-192,1196,0,-193,1197,0,-194,1198,0,-195,1199,0,-196,1200,0,-197,1201,0,-198,1202,0,-199,1203,0,-200,1204,0,-201,1205,0,-202,1206,0,-203,1207,0,-204,1208,0,-205,1209,0,-206,1210,0,-207,1211,0,-208,1212,0,-209,1213,0,-210,1214,0,-211,1215,0,-212,1216,0,-213,1217,0,-214,1218,0,-215,1219,0,-216,1220,0,-217,1221,0,-218,1222,0,-219,1223,0,-220,1224,0,-221,1225,0,-222,1226,0,-223,1227,0,-224,1228,0,-225,1229,0,-226,1230,0,-227,1231,0,-228,1232,0,-229,1233,0,-230,1234,0,-231,1235,0,-232,1236,0,-233,1237,0,-234,1238,0,-235,1239,0,-236,1240,0,-237,1241,0,-238,1242,0,-239,1243,0,-240,1244,0,-241,1245,0,-242,1246,0,-243,1247,0,-244,1248,0,-245,1249,0,-246,1250,0,-247,1251,0,-248,1252,0,-249,1253,0,-250,1254,0,-251,1255,0,-252,1256,0,-253,1257,0,-254,1258,0,-255,1259,0,-256,1260,0,-257,1261,0,-258,1262,0,-259,1263,0,-260,1264,0,-261,1265,0,-262,1266,0,-263,1267,0,-264,1268,0,-265,1269,0,-266,1270,0,-267,1271,0,-268,1272,0,-269,1273,0,-270,1274,0,-271,1275,0,-272,1276,0,-273,1277,0,-274,1278,0,-275,1279,0,-276,1280,0,-277,1281,0,-278,1282,0,-279,1283,0,-280,1284,0,-281,1285,0,-282,1286,0,-283,1287,0,-284,1288,0,-285,1289,0,-286,1290,0,-287,1291,0,-288,1292,0,-289,1293,0,-290,1294,0,-291,1295,0,-292,1296,0,-293,1297,0,-294,1298,0,-295,1299,0,-296,1300,0,-297,1301,0,-298,1302,0,-299,1303,0,-300,1304,0,-301,1305,0,-302,1306,0,-303,1307,0,-304,1308,0,-305,1309,0,-306,1310,0,-307,1311,0,-308,1312,0,-309,1313,0,-310,1314,0,-311,1315,0,-312,1316,0,-313,1317,0,-314,1318,0,-315,1319,0,-316,1320,0,-317,1321,0,-318,1322,0,-319,1323,0,-320,1324,0,-321,1325,0,-322,1326,0,-323,1327,0,-324,1328,0,-325,1329,0,-326,1330,0,-327,1331,0,-328,1332,0,-329,1333,0,-330,1334,0,-331,1335,0,-332,1336,0,-333,1337,0,-334,1338,0,-335,1339,0,-336,1340,0,-337,1341,0,-338,1342,0,-339,1343,0,-340,1344,0,-341,1345,0,-342,1346,0,-343,1347,0,-344,1348,0,-345,1349,0,-346,1350,0,-347,1351,0,-348,1352,0,-349,1353,0,-350,1354,0,-351,1355,0,-352,1356,0,-353,1357,0,-354,1358,0,-355,1359,0,-356,1360,0,-357,1361,0,-358,1362,0,-359,1363,0,-360,1364,0,-361,1365,0,-362,1366,0,-363,1367,0,-364,1368,0,-365,1369,0,-366,1370,0,-367,1371,0,-368,1372,0,-369,1373,0,-370,1374,0,-371,1375,0,-372,1376,0,-373,1377,0,-374,1378,0,-375,1379,0,-376,1380,0,-377,1381,0,-378,1382,0,-379,1383,0,-380,1384,0,-381,1385,0,-382,1386,0,-383,1387,0,-384,1388,0,-385,1389,0,-386,1390,0,-387,1391,0,-388,1392,0,-389,1393,0,-390,1394,0,-391,1395,0,-392,1396,0,-393,1397,0,-394,1398,0,-395,1399,0,-396,1400,0,-397,1401,0,-398,1402,0,-399,1403,0,-400,1404,0,-401,1405,0,-402,1406,0,-403,1407,0,-404,1408,0,-405,1409,0,-406,1410,0,-407,1411,0,-408,1412,0,-409,1413,0,-410,1414,0,-411,1415,0,-412,1416,0,-413,1417,0,-414,1418,0,-415,1419,0,-416,1420,0,-417,1421,0,-418,1422,0,-419,1423,0,-420,1424,0,-421,1425,0,-422,1426,0,-423,1427,0,-424,1428,0,-425,1429,0,-426,1430,0,-427,1431,0,-428,1432,0,-429,1433,0,-430,1434,0,-431,1435,0,-432,1436,0,-433,1437,0,-434,1438,0,-435,1439,0,-436,1440,0,-437,1441,0,-438,1442,0,-439,1443,0,-440,1444,0,-441,1445,0,-442,1446,0,-443,1447,0,-444,1448,0,-445,1449,0,-446,1450,0,-447,1451,0,-448,1452,0,-449,1453,0,-450,1454,0,-451,1455,0,-452,1456,0,-453,1457,0,-454,1458,0,-455,1459,0,-456,1460,0,-457,1461,0,-458,1462,0,-459,1463,0,-460,1464,0,-461,1465,0,-462,1466,0,-463,1467,0,-464,1468,0,-465,1469,0,-466,1470,0,-467,1471,0,-468,1472,0,-469,1473,0,-470,1474,0,-471,1475,0,-472,1476,0,-473,1477,0,-474,1478,0,-475,1479,0,-476,1480,0,-477,1481,0,-478,1482,0,-479,1483,0,-480,1484,0,-481,1485,0,-482,1486,0,-483,1487,0,-484,1488,0,-485,1489,0,-486,1490,0,-487,1491,0,-488,1492,0,-489,1493,0,-490,1494,0,-491,1495,0,-492,1496,0,-493,1497,0,-494,1498,0,-495,1499,0,-496,1500,0,-497,1501,0,-498,1502,0,-499,1503,0,-500,1504,0,-501,1505,0,-502,1506,0,-503,1507,0,-504,1508,0,-505,1509,0,-506,1510,0,-507,1511,0,-508,1512,0,-509,1513,0,-510,1514,0,-511,1515,0,-512,1516,0,-513,1517,0,-514,1518,0,-515,1519,0,-516,1520,0,-517,1521,0,-518,1522,0,-519,1523,0,-520,1524,0,-521,1525,0,-522,1526,0,-523,1527,0,-524,1528,0,-525,1529,0,-526,1530,0,-527,1531,0,-528,1532,0,-529,1533,0,-530,1534,0,-531,1535,0,-532,1536,0,-533,1537,0,-534,1538,0,-535,1539,0,-536,1540,0,-537,1541,0,-538,1542,0,-539,1543,0,-540,1544,0,-541,1545,0,-542,1546,0,-543,1547,0,-544,1548,0,-545,1549,0,-546,1550,0,-547,1551,0,-548,1552,0,-549,1553,0,-550,1554,0,-551,1555,0,-552,1556,0,-553,1557,0,-554,1558,0,-555,1559,0,-556,1560,0,-557,1561,0,-558,1562,0,-559,1563,0,-560,1564,0,-561,1565,0,-562,1566,0,-563,1567,0,-564,1568,0,-565,1569,0,-566,1570,0,-567,1571,0,-568,1572,0,-569,1573,0,-570,1574,0,-571,1575,0,-572,1576,0,-573,1577,0,-574,1578,0,-575,1579,0,-576,1580,0,-577,1581,0,-578,1582,0,-579,1583,0,-580,1584,0,-581,1585,0,-582,1586,0,-583,1587,0,-584,1588,0,-585,1589,0,-586,1590,0,-587,1591,0,-588,1592,0,-589,1593,0,-590,1594,0,-591,1595,0,-592,1596,0,-593,1597,0,-594,1598,0,-595,1599,0,-596,1600,0,-597,1601,0,-598,1602,0,-599,1603,0,-600,1604,0,-601,1605,0,-602,1606,0,-603,1607,0,-604,1608,0,-605,1609,0,-606,1610,0,-607,1611,0,-608,1612,0,-609,1613,0,-610,1614,0,-611,1615,0,-612,1616,0,-613,1617,0,-614,1618,0,-615,1619,0,-616,1620,0,-617,1621,0,-618,1622,0,-619,1623,0,-620,1624,0,-621,1625,0,-622,1626,0,-623,1627,0,-624,1628,0,-625,1629,0,-626,1630,0,-627,1631,0,-628,1632,0,-629,1633,0,-630,1634,0,-631,1635,0,-632,1636,0,-633,1637,0,-634,1638,0,-635,1639,0,-636,1640,0,-637,1641,0,-638,1642,0,-639,1643,0,-640,1644,0,-641,1645,0,-642,1646,0,-643,1647,0,-644,1648,0,-645,1649,0,-646,1650,0,-647,1651,0,-648,1652,0,-649,1653,0,-650,1654,0,-651,1655,0,-652,1656,0,-653,1657,0,-654,1658,0,-655,1659,0,-656,1660,0,-657,1661,0,-658,1662,0,-659,1663,0,-660,1664,0,-661,1665,0,-662,1666,0,-663,1667,0,-664,1668,0,-665,1669,0,-666,1670,0,-667,1671,0,-668,1672,0,-669,1673,0,-670,1674,0,-671,1675,0,-672,1676,0,-673,1677,0,-674,1678,0,-675,1679,0,-676,1680,0,-677,1681,0,-678,1682,0,-679,1683,0,-680,1684,0,-681,1685,0,-682,1686,0,-683,1687,0,-684,1688,0,-685,1689,0,-686,1690,0,-687,1691,0,-688,1692,0,-689,1693,0,-690,1694,0,-691,1695,0,-692,1696,0,-693,1697,0,-694,1698,0,-695,1699,0,-696,1700,0,-697,1701,0,-698,1702,0,-699,1703,0,-700,1704,0,-701,1705,0,-702,1706,0,-703,1707,0,-704,1708,0,-705,1709,0,-706,1710,0,-707,1711,0,-708,1712,0,-709,1713,0,-710,1714,0,-711,1715,0,-712,1716,0,-713,1717,0,-714,1718,0,-715,1719,0,-716,1720,0,-717,1721,0,-718,1722,0,-719,1723,0,-720,1724,0,-721,1725,0,-722,1726,0,-723,1727,0,-724,1728,0,-725,1729,0,-726,1730,0,-727,1731,0,-728,1732,0,-729,1733,0,-730,1734,0,-731,1735,0,-732,1736,0,-733,1737,0,-734,1738,0,-735,1739,0,-736,1740,0,-737,1741,0,-738,1742,0,-739,1743,0,-740,1744,0,-741,1745,0,-742,1746,0,-743,1747,0,-744,1748,0,-745,1749,0,-746,1750,0,-747,1751,0,-748,1752,0,-749,1753,0,-750,1754,0,-751,1755,0,-752,1756,0,-753,1757,0,-754,1758,0,-755,1759,0,-756,1760,0,-757,1761,0,-758,1762,0,-759,1763,0,-760,1764,0,-761,1765,0,-762,1766,0,-763,1767,0,-764,1768,0,-765,1769,0,-766,1770,0,-767,1771,0,-768,1772,0,-769,1773,0,-770,1774,0,-771,1775,0,-772,1776,0,-773,1777,0,-774,1778,0,-775,1779,0,-776,1780,0,-777,1781,0,-778,1782,0,-779,1783,0,-780,1784,0,-781,1785,0,-782,1786,0,-783,1787,0,-784,1788,0,-785,1789,0,-786,1790,0,-787,1791,0,-788,1792,0,-789,1793,0,-790,1794,0,-791,1795,0,-792,1796,0,-793,1797,0,-794,1798,0,-795,1799,0,-796,1800,0,-797,1801,0,-798,1802,0,-799,1803,0,-800,1804,0,-801,1805,0,-802,1806,0,-803,1807,0,-804,1808,0,-805,1809,0,-806,1810,0,-807,1811,0,-808,1812,0,-809,1813,0,-810,1814,0,-811,1815,0,-812,1816,0,-813,1817,0,-814,1818,0,-815,1819,0,-816,1820,0,-817,1821,0,-818,1822,0,-819,1823,0,-820,1824,0,-821,1825,0,-822,1826,0,-823,1827,0,-824,1828,0,-825,1829,0,-826,1830,0,-827,1831,0,-828,1832,0,-829,1833,0,-830,1834,0,-831,1835,0,-832,1836,0,-833,1837,0,-834,1838,0,-835,1839,0,-836,1840,0,-837,1841,0,-838,1842,0,-839,1843,0,-840,1844,0,-841,1845,0,-842,1846,0,-843,1847,0,-844,1848,0,-845,1849,0,-846,1850,0,-847,1851,0,-848,1852,0,-849,1853,0,-850,1854,0,-851,1855,0,-852,1856,0,-853,1857,0,-854,1858,0,-855,1859,0,-856,1860,0,-857,1861,0,-858,1862,0,-859,1863,0,-860,1864,0,-861,1865,0,-862,1866,0,-863,1867,0,-864,1868,0,-865,1869,0,-866,1870,0,-867,1871,0,-868,1879,0,-869,1890,0,-1,1895,0,-2,1896,0,-3,37,0,2,37,0,-1,1897,0,2,38,0,2,38,0,2,38,0,2,38,0,2,39,0,2,39,0,-2,541,0,2,40,0,2,40,0,-2,546,0,-1,970,0,-2,973,0,-3,976,0,-4,979,0,6,1910,0,6,1910,0,2,49,0,-1,50,0,0,49,0,-1,1905,0,-2,996,0,-3,1908,0,-1,1911,0,-2,997,0,-3,1914,0,-1,1916,0,-2,998,0,-3,1919,0,2,78,0,8,78,0,8,78,0,8,78,0,2,79,0,-1,1928,0,-2,1930,0,8,79,0,2,80,0,-1,1932,0,-2,1934,0,8,80,0,2,528,0,2,528,0,2,528,0,2,528,0,2,529,0,2,529,0,2,529,0,2,529,0,2,531,0,2,531,0,2,531,0,-1,1891,0,2,532,0,2,532,0,-1,956,0,-2,957,0,2,533,0,2,533,0,-1,958,0,-2,959,0,2,534,0,2,534,0,2,534,0,-1,960,0,2,535,0,2,535,0,-1,964,0,2,536,0,2,536,0,-1,537,0,2,537,0,2,537,0,2,537,0,2,538,0,2,538,0,2,539,0,2,539,0,2,540,0,2,540,0,2,541,0,2,541,0,2,541,0,2,542,0,2,542,0,-1,543,0,2,543,0,-2,544,0,2,544,0,2,544,0,2,544,0,2,545,0,2,545,0,2,546,0,2,546,0,2,546,0,2,942,0,2,942,0,2,943,0,2,943,0,2,944,0,2,944,0,2,945,0,2,945,0,2,945,0,2,946,0,2,946,0,2,946,0,2,947,0,2,947,0,2,947,0,2,948,0,2,948,0,2,948,0,2,949,0,-1,1886,0,2,950,0,2,950,0,2,950,0,2,951,0,2,951,0,2,951,0,2,952,0,-1,1889,0,2,955,0,2,955,0,2,956,0,2,956,0,2,956,0,2,957,0,2,957,0,2,957,0,2,958,0,2,958,0,2,958,0,2,959,0,2,959,0,2,959,0,2,960,0,2,960,0,2,960,0,-1,962,0,2,961,0,2,964,0,-2,1901,0,2,965,0,2,965,0,2,966,0,2,966,0,2,967,0,2,967,0,2,968,0,2,968,0,2,969,0,2,969,0,-1,971,0,-2,972,0,0,971,0,0,972,0,-1,974,0,-2,975,0,0,974,0,0,975,0,-1,977,0,-2,978,0,0,977,0,0,978,0,-1,980,0,-2,981,0,0,980,0,0,981,0,6,1904,0,6,1904,0,0,982,0,0,983,0,0,984,0,0,985,0,0,986,0,0,987,0,0,988,0,0,989,0,0,990,0,0,991,0,0,992,0,0,993,0,0,994,0,0,995,0,2,996,0,-1,1907,0,2,997,0,-1,1913,0,2,998,0,-1,1918,0,6,1000,0,6,1000,0,6,1000,0,0,999,0,-1,1921,0,-2,1002,0,0,1002,0,-1,1922,0,-2,1004,0,0,1004,0,-1,1923,0,-2,1006,0,0,1006,0,-1,1924,0,-2,1008,0,0,1008,0,-1,1925,0,-2,1010,0,0,1010,0,-1,1926,0,-2,1012,0,0,1012,0,0,1013,0,0,1014,0,0,1015,0,0,1016,0,0,1017,0,0,1018,0,0,1019,0,0,1020,0,0,1021,0,0,1022,0,0,1023,0,0,1024,0,0,1025,0,6,1027,0,6,1027,0,6,1027,0,0,1026,0,6,1029,0,6,1029,0,6,1029,0,0,1028,0,6,1031,0,6,1031,0,6,1031,0,0,1030,0,6,1033,0,6,1033,0,6,1033,0,0,1032,0,-1,1035,0,-2,1036,0,6,1936,0,6,1936,0,0,1035,0,6,1937,0,6,1937,0,0,1036,0,-1,1038,0,-2,1039,0,0,1038,0,6,1938,0,6,1938,0,0,1039,0,-1,1041,0,-2,1042,0,6,1939,0,6,1939,0,0,1041,0,6,1940,0,6,1940,0,0,1042,0,-1,1044,0,-2,1045,0,6,1941,0,6,1941,0,0,1044,0,0,1045,0,-1,1047,0,-2,1048,0,0,1047,0,0,1048,0,-1,1050,0,-2,1051,0,0,1050,0,0,1051,0,-1,1053,0,-2,1054,0,0,1053,0,0,1054,0,-1,1056,0,-2,1057,0,0,1056,0,0,1057,0,-1,1059,0,-2,1060,0,0,1059,0,0,1060,0,-1,1062,0,-2,1063,0,0,1062,0,0,1063,0,-1,1065,0,-2,1066,0,0,1065,0,0,1066,0,-1,1068,0,-2,1069,0,0,1068,0,0,1069,0,-1,1071,0,-2,1072,0,0,1071,0,0,1072,0,-1,1074,0,-2,1075,0,0,1074,0,0,1075,0,-1,1077,0,-2,1078,0,0,1077,0,0,1078,0,-1,1080,0,-2,1081,0,0,1080,0,0,1081,0,-1,1083,0,-2,1084,0,0,1083,0,0,1084,0,-1,1086,0,-2,1087,0,0,1086,0,6,1942,0,6,1942,0,0,1087,0,-1,1089,0,-2,1090,0,0,1089,0,0,1090,0,-1,1092,0,-2,1093,0,0,1092,0,0,1093,0,-1,1095,0,-2,1096,0,0,1095,0,0,1096,0,0,1097,0,0,1098,0,0,1099,0,0,1100,0,0,1101,0,0,1102,0,0,1103,0,0,1104,0,0,1105,0,0,1106,0,0,1107,0,0,1108,0,0,1109,0,0,1110,0,0,1111,0,0,1112,0,0,1113,0,0,1114,0,0,1115,0,0,1116,0,0,1117,0,0,1118,0,0,1119,0,0,1120,0,0,1121,0,0,1122,0,0,1123,0,0,1124,0,0,1125,0,0,1126,0,0,1127,0,0,1128,0,0,1129,0,0,1130,0,0,1131,0,0,1132,0,0,1133,0,0,1134,0,0,1135,0,0,1136,0,0,1137,0,0,1138,0,0,1139,0,0,1140,0,0,1141,0,0,1142,0,0,1143,0,0,1144,0,0,1145,0,0,1146,0,0,1147,0,0,1148,0,0,1149,0,0,1150,0,0,1151,0,0,1152,0,0,1153,0,0,1154,0,0,1155,0,0,1156,0,0,1157,0,0,1158,0,0,1159,0,0,1160,0,0,1161,0,0,1162,0,0,1163,0,0,1164,0,0,1165,0,0,1166,0,0,1167,0,0,1168,0,0,1169,0,0,1170,0,0,1171,0,0,1172,0,0,1173,0,0,1174,0,0,1175,0,0,1176,0,0,1177,0,0,1178,0,0,1179,0,0,1180,0,0,1181,0,0,1182,0,0,1183,0,0,1184,0,0,1185,0,0,1186,0,0,1187,0,0,1188,0,0,1189,0,0,1190,0,0,1191,0,0,1192,0,0,1193,0,0,1194,0,0,1195,0,0,1196,0,0,1197,0,0,1198,0,0,1199,0,0,1200,0,0,1201,0,0,1202,0,0,1203,0,0,1204,0,0,1205,0,0,1206,0,0,1207,0,0,1208,0,0,1209,0,0,1210,0,0,1211,0,0,1212,0,0,1213,0,0,1214,0,0,1215,0,0,1216,0,0,1217,0,0,1218,0,0,1219,0,0,1220,0,0,1221,0,0,1222,0,0,1223,0,0,1224,0,0,1225,0,0,1226,0,0,1227,0,0,1228,0,0,1229,0,0,1230,0,0,1231,0,0,1232,0,0,1233,0,0,1234,0,0,1235,0,0,1236,0,0,1237,0,0,1238,0,0,1239,0,0,1240,0,0,1241,0,0,1242,0,0,1243,0,0,1244,0,0,1245,0,0,1246,0,0,1247,0,0,1248,0,0,1249,0,0,1250,0,0,1251,0,0,1252,0,0,1253,0,0,1254,0,0,1255,0,0,1256,0,0,1257,0,0,1258,0,0,1259,0,0,1260,0,0,1261,0,0,1262,0,0,1263,0,0,1264,0,0,1265,0,0,1266,0,0,1267,0,0,1268,0,0,1269,0,0,1270,0,0,1271,0,0,1272,0,0,1273,0,0,1274,0,0,1275,0,0,1276,0,0,1277,0,0,1278,0,0,1279,0,0,1280,0,0,1281,0,0,1282,0,0,1283,0,0,1284,0,0,1285,0,0,1286,0,0,1287,0,0,1288,0,0,1289,0,0,1290,0,0,1291,0,0,1292,0,0,1293,0,0,1294,0,0,1295,0,0,1296,0,0,1297,0,0,1298,0,0,1299,0,0,1300,0,0,1301,0,0,1302,0,0,1303,0,0,1304,0,0,1305,0,0,1306,0,0,1307,0,0,1308,0,0,1309,0,0,1310,0,0,1311,0,0,1312,0,0,1313,0,0,1314,0,0,1315,0,0,1316,0,0,1317,0,0,1318,0,0,1319,0,0,1320,0,0,1321,0,0,1322,0,0,1323,0,0,1324,0,0,1325,0,0,1326,0,0,1327,0,0,1328,0,0,1329,0,0,1330,0,0,1331,0,0,1332,0,0,1333,0,0,1334,0,0,1335,0,0,1336,0,0,1337,0,0,1338,0,0,1339,0,0,1340,0,0,1341,0,0,1342,0,0,1343,0,0,1344,0,0,1345,0,0,1346,0,0,1347,0,0,1348,0,0,1349,0,0,1350,0,0,1351,0,0,1352,0,0,1353,0,0,1354,0,0,1355,0,0,1356,0,0,1357,0,0,1358,0,0,1359,0,0,1360,0,0,1361,0,0,1362,0,0,1363,0,0,1364,0,0,1365,0,0,1366,0,0,1367,0,0,1368,0,0,1369,0,0,1370,0,0,1371,0,0,1372,0,0,1373,0,0,1374,0,0,1375,0,0,1376,0,0,1377,0,0,1378,0,0,1379,0,0,1380,0,0,1381,0,0,1382,0,0,1383,0,0,1384,0,0,1385,0,0,1386,0,0,1387,0,0,1388,0,0,1389,0,0,1390,0,0,1391,0,0,1392,0,0,1393,0,0,1394,0,0,1395,0,0,1396,0,0,1397,0,0,1398,0,0,1399,0,0,1400,0,0,1401,0,0,1402,0,0,1403,0,0,1404,0,0,1405,0,0,1406,0,0,1407,0,0,1408,0,0,1409,0,0,1410,0,0,1411,0,0,1412,0,0,1413,0,0,1414,0,0,1415,0,0,1416,0,0,1417,0,0,1418,0,0,1419,0,0,1420,0,0,1421,0,0,1422,0,0,1423,0,0,1424,0,0,1425,0,0,1426,0,0,1427,0,0,1428,0,0,1429,0,0,1430,0,0,1431,0,0,1432,0,0,1433,0,0,1434,0,0,1435,0,0,1436,0,0,1437,0,0,1438,0,0,1439,0,0,1440,0,0,1441,0,0,1442,0,0,1443,0,0,1444,0,0,1445,0,0,1446,0,0,1447,0,0,1448,0,0,1449,0,0,1450,0,0,1451,0,0,1452,0,0,1453,0,0,1454,0,0,1455,0,0,1456,0,0,1457,0,0,1458,0,0,1459,0,0,1460,0,0,1461,0,0,1462,0,0,1463,0,0,1464,0,0,1465,0,0,1466,0,0,1467,0,0,1468,0,0,1469,0,0,1470,0,0,1471,0,0,1472,0,0,1473,0,0,1474,0,0,1475,0,0,1476,0,0,1477,0,0,1478,0,0,1479,0,0,1480,0,0,1481,0,0,1482,0,0,1483,0,0,1484,0,0,1485,0,0,1486,0,0,1487,0,0,1488,0,0,1489,0,0,1490,0,0,1491,0,0,1492,0,0,1493,0,0,1494,0,0,1495,0,0,1496,0,0,1497,0,0,1498,0,0,1499,0,0,1500,0,0,1501,0,0,1502,0,0,1503,0,0,1504,0,0,1505,0,0,1506,0,0,1507,0,0,1508,0,0,1509,0,0,1510,0,0,1511,0,0,1512,0,0,1513,0,0,1514,0,0,1515,0,0,1516,0,0,1517,0,0,1518,0,0,1519,0,0,1520,0,0,1521,0,0,1522,0,0,1523,0,0,1524,0,0,1525,0,0,1526,0,0,1527,0,0,1528,0,0,1529,0,0,1530,0,0,1531,0,0,1532,0,0,1533,0,0,1534,0,0,1535,0,0,1536,0,0,1537,0,0,1538,0,0,1539,0,0,1540,0,0,1541,0,0,1542,0,0,1543,0,0,1544,0,0,1545,0,0,1546,0,0,1547,0,0,1548,0,0,1549,0,0,1550,0,0,1551,0,0,1552,0,0,1553,0,0,1554,0,0,1555,0,0,1556,0,0,1557,0,0,1558,0,0,1559,0,0,1560,0,0,1561,0,0,1562,0,0,1563,0,0,1564,0,0,1565,0,0,1566,0,0,1567,0,0,1568,0,0,1569,0,0,1570,0,0,1571,0,0,1572,0,0,1573,0,0,1574,0,0,1575,0,0,1576,0,0,1577,0,0,1578,0,0,1579,0,0,1580,0,0,1581,0,0,1582,0,0,1583,0,0,1584,0,0,1585,0,0,1586,0,0,1587,0,0,1588,0,0,1589,0,0,1590,0,0,1591,0,0,1592,0,0,1593,0,0,1594,0,0,1595,0,0,1596,0,0,1597,0,0,1598,0,0,1599,0,0,1600,0,0,1601,0,0,1602,0,0,1603,0,0,1604,0,0,1605,0,0,1606,0,0,1607,0,0,1608,0,0,1609,0,0,1610,0,0,1611,0,0,1612,0,0,1613,0,0,1614,0,0,1615,0,0,1616,0,0,1617,0,0,1618,0,0,1619,0,0,1620,0,0,1621,0,0,1622,0,0,1623,0,0,1624,0,0,1625,0,0,1626,0,0,1627,0,0,1628,0,0,1629,0,0,1630,0,0,1631,0,0,1632,0,0,1633,0,0,1634,0,0,1635,0,0,1636,0,0,1637,0,0,1638,0,0,1639,0,0,1640,0,0,1641,0,0,1642,0,0,1643,0,0,1644,0,0,1645,0,0,1646,0,0,1647,0,0,1648,0,0,1649,0,0,1650,0,0,1651,0,0,1652,0,0,1653,0,0,1654,0,0,1655,0,0,1656,0,0,1657,0,0,1658,0,0,1659,0,0,1660,0,0,1661,0,0,1662,0,0,1663,0,0,1664,0,0,1665,0,0,1666,0,0,1667,0,0,1668,0,0,1669,0,0,1670,0,0,1671,0,0,1672,0,0,1673,0,0,1674,0,0,1675,0,0,1676,0,0,1677,0,0,1678,0,0,1679,0,0,1680,0,0,1681,0,0,1682,0,0,1683,0,0,1684,0,0,1685,0,0,1686,0,0,1687,0,0,1688,0,0,1689,0,0,1690,0,0,1691,0,0,1692,0,0,1693,0,0,1694,0,0,1695,0,0,1696,0,0,1697,0,0,1698,0,0,1699,0,0,1700,0,0,1701,0,0,1702,0,0,1703,0,0,1704,0,0,1705,0,0,1706,0,0,1707,0,0,1708,0,0,1709,0,0,1710,0,0,1711,0,0,1712,0,0,1713,0,0,1714,0,0,1715,0,0,1716,0,0,1717,0,0,1718,0,0,1719,0,0,1720,0,0,1721,0,0,1722,0,0,1723,0,0,1724,0,0,1725,0,0,1726,0,0,1727,0,0,1728,0,0,1729,0,0,1730,0,0,1731,0,0,1732,0,0,1733,0,0,1734,0,0,1735,0,0,1736,0,0,1737,0,0,1738,0,0,1739,0,0,1740,0,0,1741,0,0,1742,0,0,1743,0,0,1744,0,0,1745,0,0,1746,0,0,1747,0,0,1748,0,0,1749,0,0,1750,0,0,1751,0,0,1752,0,0,1753,0,0,1754,0,0,1755,0,0,1756,0,0,1757,0,0,1758,0,0,1759,0,0,1760,0,0,1761,0,0,1762,0,0,1763,0,0,1764,0,0,1765,0,0,1766,0,0,1767,0,0,1768,0,0,1769,0,0,1770,0,0,1771,0,0,1772,0,0,1773,0,0,1774,0,0,1775,0,0,1776,0,0,1777,0,0,1778,0,0,1779,0,0,1780,0,0,1781,0,0,1782,0,0,1783,0,0,1784,0,0,1785,0,0,1786,0,0,1787,0,0,1788,0,0,1789,0,0,1790,0,0,1791,0,0,1792,0,0,1793,0,0,1794,0,0,1795,0,0,1796,0,0,1797,0,0,1798,0,0,1799,0,0,1800,0,0,1801,0,0,1802,0,0,1803,0,0,1804,0,0,1805,0,0,1806,0,0,1807,0,0,1808,0,0,1809,0,0,1810,0,0,1811,0,0,1812,0,0,1813,0,0,1814,0,0,1815,0,0,1816,0,0,1817,0,0,1818,0,0,1819,0,0,1820,0,0,1821,0,0,1822,0,0,1823,0,0,1824,0,0,1825,0,0,1826,0,0,1827,0,0,1828,0,0,1829,0,0,1830,0,0,1831,0,0,1832,0,0,1833,0,0,1834,0,0,1835,0,0,1836,0,0,1837,0,0,1838,0,0,1839,0,0,1840,0,0,1841,0,0,1842,0,0,1843,0,0,1844,0,0,1845,0,0,1846,0,0,1847,0,0,1848,0,0,1849,0,0,1850,0,0,1851,0,0,1852,0,0,1853,0,0,1854,0,0,1855,0,0,1856,0,0,1857,0,0,1858,0,0,1859,0,0,1860,0,0,1861,0,0,1862,0,0,1863,0,0,1864,0,0,1865,0,0,1866,0,0,1867,0,0,1868,0,0,1869,0,0,1870,0,0,1871,0,2,1872,0,2,1872,0,2,1873,0,2,1873,0,2,1874,0,2,1874,0,2,1875,0,2,1875,0,2,1876,0,2,1876,0,2,1877,0,2,1877,0,2,1878,0,2,1878,0,0,1879,0,2,1880,0,2,1880,0,2,1881,0,2,1881,0,2,1882,0,2,1882,0,2,1883,0,2,1883,0,6,1947,0,6,1947,0,0,1884,0,2,1885,0,2,1885,0,2,1886,0,2,1886,0,2,1887,0,2,1887,0,2,1888,0,2,1888,0,2,1889,0,2,1889,0,0,1890,0,2,1891,0,2,1891,0,2,1892,0,2,1892,0,2,1893,0,2,1893,0,2,1894,0,2,1894,0,2,1895,0,2,1896,0,2,1897,0,-1,1899,0,2,1899,0,2,1900,0,-1,1903,0,-1,1906,0,15,1906,0,2,1907,0,-1,1909,0,2,1909,0,-1,1912,0,15,1912,0,2,1913,0,-1,1915,0,2,1915,0,-1,1917,0,15,1917,0,2,1918,0,-1,1920,0,2,1920,0,2,1921,0,2,1922,0,2,1923,0,2,1924,0,2,1925,0,2,1926,0,2,1927,0,-1,1929,0,2,1929,0,-1,1931,0,2,1931,0,-1,1933,0,2,1933,0,-1,1935,0,2,1935,0,29,36,1,8,4,2,8,4,3,8,4,4,8,37,6,8,15,9,8,14,10,8,16,11,8,538,12,8,37,14,8,16,16,8,36,20,8,39,21,8,543,22,8,40,32,8,567,33,8,567,38,8,539,39,8,540,40,8,545,49,8,567,528,8,949,529,8,952,531,8,955,963,30,1901,1879,8,1946,3056],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,5,-1,5,-1,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,21,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,18,16,-1,5,-1,5,3,1,-1,18,16,-1,5,-1,5,1,-1,18,16,-1,5,-1,5,1,-1,5,1,-1,5,1,-1,5,1,-1,5,1,-1,5,1,-1,5,1,-1,5,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,19,-1,5,-1,5,19,-1,5,-1,5,19,1,3,3,1,3,3,1,3,3,3,1,3,3,1,3,3,1,3,3,1,3,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,1,3,1,3,1,3,1,3,1,3,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,5,-1,5,-1,5,-1,5,-1,5,-1,5,-1,5,-1,5,-1,5,-1,7,1,-1,5,-1,5,-1,5,-1,5,-1,5,1,-1,5,7,7,7,7,9,9,9,9,9,9,9,7,7,21,7,7,9,9,9,9,9,9,9,7,1,7,7,7,7,7,9,9,9,9,9,9,9,7,7,9,9,9,9,9,9,9,7,7,7,31,32,33,34,7,35],[125,11,126,127,43,44,128,129,130,15,18,28,18,15,18,28,18,15,18,28,18,45,131,22,23,22,23,22,23,22,23,132,133,10,10,10,10,10,10,10,10,10,10,10,10,29,19,19,24,30,11,25,7,25,29,19,19,24,30,11,25,7,29,19,19,24,30,11,25,7,134,16,11,20,16,11,20,16,11,20,16,11,20,16,11,20,16,11,20,16,11,46,135,36,9,9,9,9,9,9,9,9,9,9,9,9,9,46,14,14,14,14,14,14,14,14,14,47,31,47,31,31,32,8,7,8,7,32,8,7,8,7,32,5,6,17,5,6,17,5,6,136,17,5,6,17,5,6,17,5,6,17,5,6,17,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,137,5,6,5,6,5,6,5,6,5,6,5,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,35,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,7,8,7,8,7,8,7,8,7,8,7,8,7,8,7,8,7,43,44,138,8,7,8,7,8,7,8,7,8,7,139,8,7,15,140,48,49,141,142,143,144,145,49,146,147,15,45,48,50,148,149,150,151,152,50,153,154,155,15,156,51,51,26,52,53,54,55,56,26,57,157,26,52,53,54,55,56,26,57,158,159,160,58,58,161,162,163,164]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"shininessExponent":20},"mainColor",8,[4,4281496384],"specularColor",8,[4,4278725645]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[20],[22,"cao",[-2],[10,"c3Z2IusppTcZ0APAQQguLO",null,null,null,-1,0]],[29,"SM_GrassClump_04",1,[[18,-3,[13,"98esaY4zJcka6tpDdPgR8J"],[0],[9],1]],[10,"66OPxUN2ZTa5daokkjSEzw",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0],[-1,5],[165,166]],[[[16,".bin",331576739,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22400,"length":3624,"count":1812,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22400,"count":350,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8267132043838501,-0.6695334911346436,-0.0007082005031406879],"maxPosition",8,[1,0.8314026594161987,0.8796128630638123,0.8706878423690796]]],-1],0,0,[],[],[]],[[[16,".bin",3977945525,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":27776,"length":2544,"count":1272,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":27776,"count":434,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,30.375511169433594,-11.707297325134277,0.6476082801818848],"maxPosition",8,[1,32.51295471191406,-9.577851295471191,3.6476082801818848]]],-1],0,0,[],[],[]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4284444855]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[20],[22,"youtong",[-2],[10,"0dfQdkurNS9JUPbR94EdRO",null,null,null,-1,0]],[36,"对象003",1,[[18,-3,[13,"959RQj7etZgqLbPEFg0riR"],[0],[9],1]],[10,"c7fvJvEARZ0JW21aqwvTot",null,null,null,1,0],[1,-31.449682235717773,-2.147608757019043,-10.641125679016113],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0],[-1,5],[167,168]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":2},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4282559216],"specularColor",8,[4,4279134174]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[20],[22,"huowu",[-2],[10,"36uM83vtxVcJDIalQ1Trkb",null,null,null,-1,0]],[36,"对象001",1,[[18,-3,[13,"99qH6syW9XRohcmBdVGPx6"],[0,1],[9],2]],[10,"67UW1gZwlfnIIHS8Oc+slH",null,null,null,1,0],[1,0.7664013504981995,6.975218980187492e-7,-6.846621036529541],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0],[-1,-2,5],[169,170,171]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":2},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4293585128],"specularColor",8,[4,4292005582]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[16,".bin",4206934311,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":9216,"length":432,"count":216,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":11184,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":9216,"count":144,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":9648,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,29.476640701293945,14.228632926940918,0.003990265540778637],"maxPosition",8,[1,32.93425750732422,17.686250686645508,3.0002200603485107]]],-1],0,0,[],[],[]],[[{"name":"game","rect":{"x":0,"y":0,"width":100,"height":64},"offset":{"x":0,"y":0},"originalSize":{"width":100,"height":64},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-50,-32,0,50,-32,0,-50,32,0,50,32,0],"indexes":[0,1,2,2,1,3],"uv":[0,64,100,64,0,0,100,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-50,"y":-32,"z":0},"maxPos":{"x":50,"y":32,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[172]],[[[16,".bin",1731663730,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":7872,"length":492,"count":246,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":7872,"count":164,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-43.647605895996094,-0.867138683795929,-15.828217506408691],"maxPosition",8,[1,5.6795654296875,-0.5671371817588806,40.177120208740234]]],-1],0,0,[],[],[]],[[[20],[22,"wandao",[-2],[10,"77ob6KtepTu7ENQ7YIoqka",null,null,null,-1,0]],[143,"group1",1,[-3,-4],[10,"3f36pflnBR3YOEefkdGv1h",null,null,null,1,0],[1,-0.6529027819633484,0,-0.19927065074443817],[1,0.002534999744966626,0.002534999744966626,0.002534999744966626]],[54,"Box004",2,[[18,-5,[13,"35qmvx9NlXOqlUyTbsjYB3"],[0],[9],1]],[10,"42BBE5+mdcX6B1nJG0w92N",null,null,null,1,0],[1,257.55535888671875,-0.000024701743313926272,78.6077651977539],[1,14.507545471191406,14.418551445007324,14.418551445007324]],[54,"Box005",2,[[18,-6,[13,"e2QcaGf/tax6xgWE2hjTiG"],[2,3],[9],4]],[10,"84Ec4TbUhfOpi0Uik4Z5JF",null,null,null,1,0],[1,257.55535888671875,-0.000024414064682787284,78.60778045654297],[1,14.418551445007324,14.418551445007324,14.418551445007324]]],0,[0,0,1,0,-1,2,0,-1,3,0,-2,4,0,2,3,0,2,4,0,10,1,6],[0,0,0,0,0],[-1,5,-1,-2,5],[173,174,175,176,177]],[[[16,".bin",2477001793,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":30912,"length":1932,"count":966,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":63708,"length":1932,"count":966,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":30912,"count":644,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":32844,"length":30864,"count":643,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-43.95890808105469,-0.6266809105873108,-20.120134353637695],"maxPosition",8,[1,9.973261833190918,-0.32667964696884155,40.1771240234375]]],-1],0,0,[],[],[]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"albedoScale":5,"emissiveScale":0,"shininessExponent":20,"specularFactor":0.5},"mainColor",8,[4,4290559164],"tilingOffset",8,[2,1.6,0.5,0,0],"mainTexture",6,0,"transparencyMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[12,13,4],[21,178,4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5},"mainColor",8,[4,4290559164],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[59,4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"albedoScale":5,"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5},"tilingOffset",8,[2,1.9,-0.5,0,0],"mainTexture",6,0,"transparencyMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[12,13,4],[21,60,4]],[[[11,"Material.001",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":1,"metallic":1,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4286611584],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[16,".bin",1246881294,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":38736,"length":3438,"count":1719,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":38736,"count":538,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-2.08414888381958,-0.10724233835935593,-0.000006231757197383558],"maxPosition",8,[1,0.0982065424323082,0.10655147582292557,6.364027500152588]]],-1],0,0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[179]],[[[66,"OtherCar"],[144,"OtherCar",[-10,-11,-12],[[190,true,-7,[13,"e7iYkyenJMF43NLHT3QyDP"],[1,0,0.5,0],[1,2,1,5.5]],[193,false,-8,[13,"7aXZmw3flNvaNkARfH/P1l"]],[230,30,-9,[13,"c1p9g8Y9xI7oPcL7tThDyr"]]],[155,"43g/0Giq1G3rY97VtSqiIY",null,-6,0,[[172,["_trailModule","_particleSystem"],-5,[1,["0b7a7v3FVOCpzmec7amMlB"]],-4,[1,["0b7a7v3FVOCpzmec7amMlB"]]]],[-1,-2,-3]],[1,0.8,0.8,0.8]],[1,["0b7a7v3FVOCpzmec7amMlB"]],[1,["38Arsro4ZT5qpNdiQXl5Q8"]],[1,["d8NOYrfgpez5xNKGaynGpk"]],[4,0,null,1,[3,"dej8HfUnRLl5t/fEM9i0GO",null,null,-18,[82,"fbzUGtL0NGPqy8hkjCHkpk",1,[[2,"boxHit",["_name"],-13],[0,["_lpos"],-14,[1,0,0.2,4.44]],[0,["_lrot"],-15,[3,0,0,0,1]],[0,["_euler"],-16,[1,0,0,0]],[2,false,["loop"],2],[197,["_noiseModule"],2,[64]],[14,["renderer","_cpuMaterial"],2,3],[2,300,["_capacity"],2],[2,200,["rateOverTime","constant"],2],[2,3,["startSizeX","constant"],2],[2,2,["simulationSpeed"],2],[0,["_colorOverLifetimeModule","color","colorMin"],2,[4,4278255605]],[0,["_colorOverLifetimeModule","color","colorMax"],2,[4,4279501055]],[0,["_shapeModule","_scale"],2,[1,3,3,3]],[2,false,["_active"],-17]]],2]],[1,["dej8HfUnRLl5t/fEM9i0GO"]],[4,0,null,1,[3,"38Arsro4ZT5qpNdiQXl5Q8",null,null,-19,[82,"01EnM2ugVC174ALb0LYfTb",1,[[2,"xiaoche01",["_name"],3],[0,["_lpos"],3,[1,0,0.7,0]],[0,["_lrot"],3,[3,0,0,0,1]],[0,["_euler"],3,[1,0,0,0]],[0,["_lscale"],3,[1,100,100,100]],[2,false,["_active"],3]]],0]],[4,0,null,1,[3,"d8NOYrfgpez5xNKGaynGpk",null,null,-20,[82,"f5WJlLbEpM24V+YIaI95PF",1,[[2,"xiaoche02",["_name"],4],[0,["_lpos"],4,[1,0,0,0]],[0,["_lrot"],4,[3,0,0,0,1]],[0,["_euler"],4,[1,0,0,0]],[0,["_lscale"],4,[1,100,100,100]],[2,false,["_active"],4]]],1]]],0,[0,-1,5,0,-2,8,0,-3,7,0,14,5,0,17,5,0,0,1,0,2,1,0,2,1,0,2,1,0,-1,7,0,-2,8,0,-3,5,0,6,6,0,6,6,0,6,6,0,6,6,0,6,6,0,0,5,0,0,7,0,0,8,0,10,1,20],[0,0,0,0],[1,1,1,3],[180,181,182,61]],[[{"name":"gou","rect":{"x":0,"y":0,"width":132,"height":107},"offset":{"x":0,"y":0},"originalSize":{"width":132,"height":107},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-66,-53.5,0,66,-53.5,0,-66,53.5,0,66,53.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,107,132,107,0,0,132,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-66,"y":-53.5,"z":0},"maxPos":{"x":66,"y":53.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[183]],[[[11,"Material_004",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[34,42]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"shininessExponent":20},"mainColor",8,[4,4288914339]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[16,".bin",471436662,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":40320,"length":4032,"count":2016,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":40320,"count":630,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-43.30299758911133,-21.124046325683594,0.09999946504831314],"maxPosition",8,[1,43.3029899597168,21.124046325683594,0.24999946355819702]]],-1],0,0,[],[],[]],[[[20],[22,"banmaxian",[-2],[10,"c94BwCxEhVOp4wiRMeeyXy",null,null,null,-1,0]],[29,"斑马线",1,[[18,-3,[13,"5f7BTpSgVWR5Ftviglu25h"],[0],[9],1]],[10,"03iojcdjpR4aPNBLAclc0+",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0],[-1,5],[184,185]],[[[11,"Material",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"albedoScale":1,"specularFactor":1,"shininessExponent":20,"emissiveScale":1},"mainColor",8,[4,4286611584],"specularColor",8,[4,4286348412],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"shininessExponent":20},"mainColor",8,[4,4278233839],"specularColor",8,[4,4278216668]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[20],[22,"jiansudai",[-2],[10,"d2TjgTD/1aGbQ0jo2pMXya",null,null,null,-1,0]],[29,"jiansudai",1,[[18,-3,[13,"efnHtaHOReOJecvNdkfvKd"],[0,1],[9],2]],[10,"abGJHp8AlZS7UyGki127PX",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0],[-1,-2,5],[186,187,188]],[[[16,".bin",483779418,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1318592,"length":56154,"count":28077,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":2677466,"length":54648,"count":27324,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1318592,"count":20603,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":1374746,"length":1302720,"count":20355,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.36467787623405457,-5.543724536895752,-0.059211164712905884],"maxPosition",8,[1,0.36467787623405457,5.543724536895752,0.059211164712905884]]],-1],0,0,[],[],[]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"shininessExponent":20},"mainColor",8,[4,4278190080],"specularColor",8,[4,4278190080]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[55,"../Effect/outLine/outline",[{"hash":191954869,"name":"../Effect/outLine/outline|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":16,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":17,"defines":[]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD"]}],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nuniform samplerCube cc_environment;\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHT_PROBE\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #else\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity, vec2 screenUV) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        vec4 biased = fragTextureLod(cc_reflectionProbeCubemap, R, mip + mipBias);\n     \t  vec4 filtered = texture(cc_reflectionProbeCubemap, R);\n      #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n        vec4 biased = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mip + mipBias);\n        vec4 filtered = texture(cc_reflectionProbePlanarMap, screenUV);\n      #else\n        vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \t  vec4 filtered = texture(cc_environment, R);\n      #endif\n      #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n        biased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    float reflectionProbeId;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      #endif\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      #endif\n    }\n  #endif\n  vec3 finalColor = vec3(0.0);\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    #if CC_USE_LIGHTMAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n      shadow *= s.lightmap.a;\n      finalColor += diffuse * lightmap.rgb;\n    #else\n      finalColor += diffuse * lightmap.rgb * shadow;\n    #endif\n    s.occlusion *= s.lightmap_test;\n  #endif\n  #if !CC_DISABLE_DIRECTIONAL_LIGHT\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 lightingColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor += lightingColor * dirlightContrib;\n  #endif\n  float fAmb = max(EPSILON, 0.5 - N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  vec3 env = vec3(0.0), rotationDir;\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      rotationDir = RotationVecFromAxisY(N.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    #if !CC_USE_REFLECTION_PROBE\n      vec3 R = normalize(reflect(-V, N));\n      rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6, vec2(0.0));\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n        #if CC_USE_IBL == 2\n          env = unpackRGBE(envmap);\n        #else\n          env = SRGBToLinear(envmap.rgb);\n          #endif\n      #endif\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    vec4 probe = vec4(0.0);\n    vec3 R = normalize(reflect(-V, N));\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      if(s.reflectionProbeId < 0.0){\n        probe = fragTextureLod(cc_reflectionProbeCubemap, R, s.roughness * (cc_ambientGround.w - 1.0));\n      }else{\n        vec3 centerPos, boxHalfSize;\n        float mipCount;\n        GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, s.reflectionProbeId);\n        vec4 fixedR = CalculateBoxProjectedDirection(R, position, centerPos, boxHalfSize);\n        probe = mix(fragTextureLod(cc_environment, R, s.roughness * (cc_ambientGround.w - 1.0)),\n          fragTextureLod(cc_reflectionProbeCubemap, fixedR.xyz, s.roughness * (mipCount - 1.0)), fixedR.w);\n      }\n    #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n      if(s.reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(s.position, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0);\n      }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, s.reflectionProbeId);\n        R = normalize(CalculateReflectDirection(N, V, max(abs(dot(N, V)), 0.0)));\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(N, V, s.position, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount);\n      }\n    #endif\n    env = unpackRGBE(probe);\n  #endif\n  finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#if CC_USE_LIGHT_PROBE\n  finalColor += SHEvaluate(N) * diffuse * s.occlusion;\n#endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_RGBE_OUTPUT\n    color = packRGBE(color.rgb);\n  #elif !CC_USE_FLOAT_OUTPUT\n    #if CC_USE_HDR && CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap.a = lightColor.a;\n    s.lightmap.rgb = lightColor.rgb;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    #if CC_USE_FOG != 4\n      CC_APPLY_FOG(color, s.position.xyz);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\nuniform samplerCube cc_environment;\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHT_PROBE\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #else\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity, vec2 screenUV) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        vec4 biased = fragTextureLod(cc_reflectionProbeCubemap, R, mip + mipBias);\n     \t  vec4 filtered = textureCube(cc_reflectionProbeCubemap, R);\n      #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n        vec4 biased = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mip + mipBias);\n        vec4 filtered = texture2D(cc_reflectionProbePlanarMap, screenUV);\n      #else\n        vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \t  vec4 filtered = textureCube(cc_environment, R);\n      #endif\n      #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n        biased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    float reflectionProbeId;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      #endif\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      #endif\n    }\n  #endif\n  vec3 finalColor = vec3(0.0);\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    #if CC_USE_LIGHTMAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n      shadow *= s.lightmap.a;\n      finalColor += diffuse * lightmap.rgb;\n    #else\n      finalColor += diffuse * lightmap.rgb * shadow;\n    #endif\n    s.occlusion *= s.lightmap_test;\n  #endif\n  #if !CC_DISABLE_DIRECTIONAL_LIGHT\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 lightingColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor += lightingColor * dirlightContrib;\n  #endif\n  float fAmb = max(EPSILON, 0.5 - N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  vec3 env = vec3(0.0), rotationDir;\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      rotationDir = RotationVecFromAxisY(N.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    #if !CC_USE_REFLECTION_PROBE\n      vec3 R = normalize(reflect(-V, N));\n      rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6, vec2(0.0));\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n        #if CC_USE_IBL == 2\n          env = unpackRGBE(envmap);\n        #else\n          env = SRGBToLinear(envmap.rgb);\n          #endif\n      #endif\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    vec4 probe = vec4(0.0);\n    vec3 R = normalize(reflect(-V, N));\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      if(s.reflectionProbeId < 0.0){\n        probe = fragTextureLod(cc_reflectionProbeCubemap, R, s.roughness * (cc_ambientGround.w - 1.0));\n      }else{\n        vec3 centerPos, boxHalfSize;\n        float mipCount;\n        GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, s.reflectionProbeId);\n        vec4 fixedR = CalculateBoxProjectedDirection(R, position, centerPos, boxHalfSize);\n        probe = mix(fragTextureLod(cc_environment, R, s.roughness * (cc_ambientGround.w - 1.0)),\n          fragTextureLod(cc_reflectionProbeCubemap, fixedR.xyz, s.roughness * (mipCount - 1.0)), fixedR.w);\n      }\n    #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n      if(s.reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(s.position, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0);\n      }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, s.reflectionProbeId);\n        R = normalize(CalculateReflectDirection(N, V, max(abs(dot(N, V)), 0.0)));\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(N, V, s.position, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount);\n      }\n    #endif\n    env = unpackRGBE(probe);\n  #endif\n  finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#if CC_USE_LIGHT_PROBE\n  finalColor += SHEvaluate(N) * diffuse * s.occlusion;\n#endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_RGBE_OUTPUT\n    color = packRGBE(color.rgb);\n  #elif !CC_USE_FLOAT_OUTPUT\n    #if CC_USE_HDR && CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap.a = lightColor.a;\n    s.lightmap.rgb = lightColor.rgb;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    #if CC_USE_FOG != 4\n      CC_APPLY_FOG(color, s.position.xyz);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":135,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":124}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"number","range":[0,3]},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"SAMPLE_FROM_RT","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SURFACES_ENABLE_DEBUG_VIEW","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"}]},{"hash":88784448,"name":"../Effect/outLine/outline|fx-outline-vs:vert|fx-outline-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"rimColor","type":16,"count":1},{"name":"outlineParams","type":16,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"rimColor","type":16,"count":1},{"name":"outlineParams","type":16,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if CC_USE_FOG != 4\n#endif\n#if !CC_USE_ACCURATE_FOG\nout mediump float v_fog_factor;\n#endif\nout vec3 scNormal;\nout vec4 scWorldPos;\nlayout(std140) uniform Constants {\n  vec4 rimColor;\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  scNormal = In.normal;\n  vec4 pos = In.position;\n  pos.w = 1.;\n  vec3 posDir = normalize(pos.xyz);\n  pos.xyz += posDir * outlineParams.z;\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  scWorldPos = matWorld * pos;\n  scNormal = normalize((matWorldIT * vec4(scNormal, 0.0)).xyz);\n  pos = cc_matProj * (cc_matView * matWorld) * pos;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\n#if CC_USE_FOG != 4\n#endif\n#if !CC_USE_ACCURATE_FOG\nin mediump float v_fog_factor;\n#endif\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nin vec3 scNormal;\nin vec4 scWorldPos;\nlayout(std140) uniform Constants {\n  vec4 rimColor;\n  vec4 outlineParams;\n};\nvec4 frag () {\n  vec4 color = rimColor;\n  vec3 V = normalize(cc_cameraPos.xyz - scWorldPos.xyz);\n  vec3 N = normalize(scNormal);\n  float dotVal = dot(V, N);\n  dotVal = saturate(dotVal);\n  color.a = pow(dotVal, outlineParams.x);\n  color.a *=  outlineParams.y * dotVal;\n  color.a = clamp(color.a, 0., 0.8);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if CC_USE_FOG != 4\n#endif\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvarying vec3 scNormal;\nvarying vec4 scWorldPos;\n   uniform vec4 outlineParams;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  scNormal = In.normal;\n  vec4 pos = In.position;\n  pos.w = 1.;\n  vec3 posDir = normalize(pos.xyz);\n  pos.xyz += posDir * outlineParams.z;\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  scWorldPos = matWorld * pos;\n  scNormal = normalize((matWorldIT * vec4(scNormal, 0.0)).xyz);\n  pos = cc_matProj * (cc_matView * matWorld) * pos;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_debug_view_mode;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\n#if CC_USE_FOG != 4\n#endif\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvarying vec3 scNormal;\nvarying vec4 scWorldPos;\n   uniform vec4 rimColor;\n   uniform vec4 outlineParams;\nvec4 frag () {\n  vec4 color = rimColor;\n  vec3 V = normalize(cc_cameraPos.xyz - scWorldPos.xyz);\n  vec3 N = normalize(scNormal);\n  float dotVal = dot(V, N);\n  dotVal = saturate(dotVal);\n  color.a = pow(dotVal, outlineParams.x);\n  color.a *=  outlineParams.y * dotVal;\n  color.a = clamp(color.a, 0., 0.8);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":74,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":44}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"}]},{"hash":1775319926,"name":"../Effect/outLine/outline|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":16,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\n  precision highp float;\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_POINT 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define LIGHT_TYPE_SPHERE 3.0\n  #define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n  #define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n  #define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n  #define TONE_MAPPING_ACES 0\n  #define TONE_MAPPING_LINEAR 1\n  #define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n  struct StandardVertInput {\n    highp vec4 position;\n    vec3 normal;\n    vec4 tangent;\n  };\n  in vec3 a_position;\n  in vec3 a_normal;\n  in vec2 a_texCoord;\n  in vec4 a_tangent;\n  #if CC_USE_SKINNING\n      in vec4 a_joints;\n    in vec4 a_weights;\n  #endif\n  #if USE_INSTANCING\n    #if CC_USE_BAKED_ANIMATION\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    in vec4 a_matWorld0;\n    in vec4 a_matWorld1;\n    in vec4 a_matWorld2;\n    #if CC_USE_LIGHTMAP\n      in vec4 a_lightingMapUVParam;\n    #endif\n    #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n      #if CC_RECEIVE_SHADOW\n      #endif\n      in vec4 a_localShadowBiasAndProbeId;\n    #endif\n    #if CC_USE_LIGHT_PROBE\n      in vec4 a_sh_linear_const_r;\n      in vec4 a_sh_linear_const_g;\n      in vec4 a_sh_linear_const_b;\n    #endif\n  #endif\n  #if CC_USE_MORPH\n      in float a_vertexId;\n      int getVertexId() {\n        return int(a_vertexId);\n      }\n  #endif\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n    highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n    highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n  #if CC_USE_MORPH\n    layout(std140) uniform CCMorph {\n      vec4 cc_displacementWeights[15];\n      vec4 cc_displacementTextureInfo;\n    };\n    #if CC_MORPH_TARGET_HAS_POSITION\n      uniform sampler2D cc_PositionDisplacements;\n    #endif\n    #if CC_MORPH_TARGET_HAS_NORMAL\n      uniform sampler2D cc_NormalDisplacements;\n    #endif\n    #if CC_MORPH_TARGET_HAS_TANGENT\n      uniform sampler2D cc_TangentDisplacements;\n    #endif\n    vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n      float pixelIndexF = float(pixelIndex);\n      float x = mod(pixelIndexF, textureResolution.x);\n      float y = floor(pixelIndexF / textureResolution.x);\n      return vec2(x, y);\n    }\n    vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n      return (vec2(location.x, location.y) + .5) / textureResolution;\n    }\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n          ivec2 texSize = textureSize(tex, 0);\n          return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n    #else\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n          decode32(texture(tex, x)),\n          decode32(texture(tex, y)),\n          decode32(texture(tex, z)),\n          1.0\n        );\n      }\n    #endif\n    float getDisplacementWeight(int index) {\n      int quot = index / 4;\n      int remainder = index - quot * 4;\n      if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n      } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n      } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n      } else {\n        return cc_displacementWeights[quot].w;\n      }\n    }\n    vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n    #if CC_MORPH_PRECOMPUTED\n      return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n    #else\n      vec3 result = vec3(0, 0, 0);\n      int nVertices = int(cc_displacementTextureInfo.z);\n      for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n      }\n      return result;\n    #endif\n    }\n    #if CC_MORPH_TARGET_HAS_POSITION\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n    #endif\n    #if CC_MORPH_TARGET_HAS_NORMAL\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n    #endif\n    #if CC_MORPH_TARGET_HAS_TANGENT\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n    #endif\n    void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n      int vertexId = getVertexId();\n    #if CC_MORPH_TARGET_HAS_POSITION\n      position.xyz = position.xyz + getPositionDisplacement(vertexId);\n    #endif\n    #if CC_MORPH_TARGET_HAS_NORMAL\n      normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n    #endif\n    #if CC_MORPH_TARGET_HAS_TANGENT\n      tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n    #endif\n    }\n    void applyMorph (inout vec4 position) {\n    #if CC_MORPH_TARGET_HAS_POSITION\n      position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n    #endif\n    }\n  #endif\n  #if CC_USE_SKINNING\n    #if CC_USE_BAKED_ANIMATION\n      layout(std140) uniform CCSkinningTexture {\n        highp vec4 cc_jointTextureInfo;\n      };\n      layout(std140) uniform CCSkinningAnimation {\n        highp vec4 cc_jointAnimInfo;\n      };\n      uniform highp sampler2D cc_jointTexture;\n      void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n      {\n        #if USE_INSTANCING\n          highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n        #else\n          highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n        #endif\n        invSize = cc_jointTextureInfo.w;\n        highp float tempY = floor(temp * invSize);\n        x = floor(temp - tempY * cc_jointTextureInfo.x);\n        y = (tempY + 0.5) * invSize;\n      }\n    #else\n      #if CC_USE_REAL_TIME_JOINT_TEXTURE\n        uniform highp sampler2D cc_realtimeJoint;\n      #else\n        layout(std140) uniform CCSkinning {\n          highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n        };\n      #endif\n    #endif\n    #if CC_USE_BAKED_ANIMATION\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          highp float x, y, invSize;\n          CCGetJointTextureCoords(3.0, i, x, y, invSize);\n          vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n          vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n          vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n          highp float x, y, invSize;\n          CCGetJointTextureCoords(12.0, i, x, y, invSize);\n          vec4 v1 = vec4(\n            decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n            decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      #if CC_USE_REAL_TIME_JOINT_TEXTURE\n        #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n          mat4 getJointMatrix (float i) {\n            float x = i;\n            vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n            vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n            vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n            return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n          }\n        #else\n          mat4 getJointMatrix (float i) {\n           float x = 4.0 * i;\n            vec4 v1 = vec4(\n              decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n            );\n            vec4 v2 = vec4(\n              decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n            );\n            vec4 v3 = vec4(\n              decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n              decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n            );\n            return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n          }\n        #endif\n      #else\n        mat4 getJointMatrix (float i) {\n          int idx = int(i);\n          vec4 v1 = cc_joints[idx * 3];\n          vec4 v2 = cc_joints[idx * 3 + 1];\n          vec4 v3 = cc_joints[idx * 3 + 2];\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #endif\n    mat4 skinMatrix () {\n      vec4 joints = vec4(a_joints);\n      return getJointMatrix(joints.x) * a_weights.x\n           + getJointMatrix(joints.y) * a_weights.y\n           + getJointMatrix(joints.z) * a_weights.z\n           + getJointMatrix(joints.w) * a_weights.w;\n    }\n    void CCSkin (inout vec4 position) {\n      mat4 m = skinMatrix();\n      position = m * position;\n    }\n    void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n      mat4 m = skinMatrix();\n      position = m * position;\n      normal = (m * vec4(normal, 0.0)).xyz;\n      tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n    }\n  #endif\n  void CCVertInput(inout StandardVertInput In)\n  {\n        In.position = vec4(a_position, 1.0);\n        In.normal = a_normal;\n        In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In.position, In.normal, In.tangent);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In.position, In.normal, In.tangent);\n    #endif\n  }\n  #if !USE_INSTANCING\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n      highp vec4 cc_reflectionProbeData1;\n      highp vec4 cc_reflectionProbeData2;\n    };\n  #endif\n  void CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n  {\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  }\n  layout(std140) uniform Constants {\n    vec4 tilingOffset;\n    vec4 albedo;\n    vec4 albedoScaleAndCutoff;\n    vec4 pbrParams;\n    vec4 emissive;\n    vec4 emissiveScaleParam;\n  };\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    mediump vec4 cc_shadowNFLSInfo;\n    mediump vec4 cc_shadowWHPBInfo;\n    mediump vec4 cc_shadowLPNNInfo;\n    lowp vec4 cc_shadowColor;\n    mediump vec4 cc_planarNDInfo;\n  };\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n  #if HAS_SECOND_UV || CC_USE_LIGHTMAP\n    in vec2 a_texCoord1;\n  #endif\n  out vec2 v_uv;\n  out vec2 v_uv1;\n  out vec4 v_worldPos;\n  out float v_clip_depth;\n  vec4 vert () {\n    StandardVertInput In;\n    CCVertInput(In);\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    v_worldPos = matWorld * In.position;\n    vec4 clipPos = cc_matLightViewProj * v_worldPos;\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if HAS_SECOND_UV\n      v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #endif\n    v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n    return clipPos;\n  }\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  layout(std140) uniform Constants {\n    vec4 tilingOffset;\n    vec4 albedo;\n    vec4 albedoScaleAndCutoff;\n    vec4 pbrParams;\n    vec4 emissive;\n    vec4 emissiveScaleParam;\n  };\n  vec4 packDepthToRGBA (float depth) {\n    vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    ret = fract(ret);\n    ret -= vec4(ret.yzw, 0.0) / 255.0;\n    return ret;\n  }\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    mediump vec4 cc_shadowNFLSInfo;\n    mediump vec4 cc_shadowWHPBInfo;\n    mediump vec4 cc_shadowLPNNInfo;\n    lowp vec4 cc_shadowColor;\n    mediump vec4 cc_planarNDInfo;\n  };\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n  in vec2 v_uv;\n  in vec2 v_uv1;\n  in vec4 v_worldPos;\n  in float v_clip_depth;\n  #if USE_ALBEDO_MAP\n    uniform sampler2D albedoMap;\n  #endif\n  #if USE_ALPHA_TEST\n  #endif\n  vec4 frag () {\n    vec4 baseColor = albedo;\n    #if USE_ALBEDO_MAP\n      baseColor *= texture(albedoMap, ALBEDO_UV);\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n    #endif\n    if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        vec4 viewStartPos = cc_matLightView * v_worldPos;\n        float dist = length(viewStartPos.xyz);\n        float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n        return vec4(linearDepth, 1.0, 1.0, 1.0);\n      }\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      return packDepthToRGBA(v_clip_depth);\n    }\n    return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\n  precision highp float;\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_POINT 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define LIGHT_TYPE_SPHERE 3.0\n  #define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n  #define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n  #define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n  #define TONE_MAPPING_ACES 0\n  #define TONE_MAPPING_LINEAR 1\n  #define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n  struct StandardVertInput {\n    highp vec4 position;\n    vec3 normal;\n    vec4 tangent;\n  };\n  attribute vec3 a_position;\n  attribute vec3 a_normal;\n  attribute vec2 a_texCoord;\n  attribute vec4 a_tangent;\n  #if CC_USE_SKINNING\n      attribute vec4 a_joints;\n    attribute vec4 a_weights;\n  #endif\n  #if USE_INSTANCING\n    #if CC_USE_BAKED_ANIMATION\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    attribute vec4 a_matWorld0;\n    attribute vec4 a_matWorld1;\n    attribute vec4 a_matWorld2;\n    #if CC_USE_LIGHTMAP\n      attribute vec4 a_lightingMapUVParam;\n    #endif\n    #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n      #if CC_RECEIVE_SHADOW\n      #endif\n      attribute vec4 a_localShadowBiasAndProbeId;\n    #endif\n    #if CC_USE_LIGHT_PROBE\n      attribute vec4 a_sh_linear_const_r;\n      attribute vec4 a_sh_linear_const_g;\n      attribute vec4 a_sh_linear_const_b;\n    #endif\n  #endif\n  #if CC_USE_MORPH\n      attribute float a_vertexId;\n      int getVertexId() {\n        return int(a_vertexId);\n      }\n  #endif\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n    highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n    highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n  #if CC_USE_MORPH\n    uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n    #if CC_MORPH_TARGET_HAS_POSITION\n      uniform sampler2D cc_PositionDisplacements;\n    #endif\n    #if CC_MORPH_TARGET_HAS_NORMAL\n      uniform sampler2D cc_NormalDisplacements;\n    #endif\n    #if CC_MORPH_TARGET_HAS_TANGENT\n      uniform sampler2D cc_TangentDisplacements;\n    #endif\n    vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n      float pixelIndexF = float(pixelIndex);\n      float x = mod(pixelIndexF, textureResolution.x);\n      float y = floor(pixelIndexF / textureResolution.x);\n      return vec2(x, y);\n    }\n    vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n      return (vec2(location.x, location.y) + .5) / textureResolution;\n    }\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n          int pixelIndex = elementIndex;\n          vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n          vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n          return texture2D(tex, uv);\n        }\n    #else\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n          decode32(texture2D(tex, x)),\n          decode32(texture2D(tex, y)),\n          decode32(texture2D(tex, z)),\n          1.0\n        );\n      }\n    #endif\n    float getDisplacementWeight(int index) {\n      int quot = index / 4;\n      int remainder = index - quot * 4;\n      if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n      } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n      } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n      } else {\n        return cc_displacementWeights[quot].w;\n      }\n    }\n    vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n    #if CC_MORPH_PRECOMPUTED\n      return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n    #else\n      vec3 result = vec3(0, 0, 0);\n      int nVertices = int(cc_displacementTextureInfo.z);\n      for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n      }\n      return result;\n    #endif\n    }\n    #if CC_MORPH_TARGET_HAS_POSITION\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n    #endif\n    #if CC_MORPH_TARGET_HAS_NORMAL\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n    #endif\n    #if CC_MORPH_TARGET_HAS_TANGENT\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n    #endif\n    void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n      int vertexId = getVertexId();\n    #if CC_MORPH_TARGET_HAS_POSITION\n      position.xyz = position.xyz + getPositionDisplacement(vertexId);\n    #endif\n    #if CC_MORPH_TARGET_HAS_NORMAL\n      normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n    #endif\n    #if CC_MORPH_TARGET_HAS_TANGENT\n      tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n    #endif\n    }\n    void applyMorph (inout vec4 position) {\n    #if CC_MORPH_TARGET_HAS_POSITION\n      position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n    #endif\n    }\n  #endif\n  #if CC_USE_SKINNING\n    #if CC_USE_BAKED_ANIMATION\n      uniform highp vec4 cc_jointTextureInfo;\n      uniform highp vec4 cc_jointAnimInfo;\n      uniform highp sampler2D cc_jointTexture;\n      void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n      {\n        #if USE_INSTANCING\n          highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n        #else\n          highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n        #endif\n        invSize = cc_jointTextureInfo.w;\n        highp float tempY = floor(temp * invSize);\n        x = floor(temp - tempY * cc_jointTextureInfo.x);\n        y = (tempY + 0.5) * invSize;\n      }\n    #else\n      #if CC_USE_REAL_TIME_JOINT_TEXTURE\n        uniform highp sampler2D cc_realtimeJoint;\n      #else\n        uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      #endif\n    #endif\n    #if CC_USE_BAKED_ANIMATION\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          highp float x, y, invSize;\n          CCGetJointTextureCoords(3.0, i, x, y, invSize);\n          vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n          vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n          vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n          highp float x, y, invSize;\n          CCGetJointTextureCoords(12.0, i, x, y, invSize);\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n            decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      #if CC_USE_REAL_TIME_JOINT_TEXTURE\n        #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n          mat4 getJointMatrix (float i) {\n            float x = i;\n            vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n            vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n            vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n            return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n          }\n        #else\n          mat4 getJointMatrix (float i) {\n           float x = 4.0 * i;\n            vec4 v1 = vec4(\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n            );\n            vec4 v2 = vec4(\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n            );\n            vec4 v3 = vec4(\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n              decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n            );\n            return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n          }\n        #endif\n      #else\n        mat4 getJointMatrix (float i) {\n          int idx = int(i);\n          vec4 v1 = cc_joints[idx * 3];\n          vec4 v2 = cc_joints[idx * 3 + 1];\n          vec4 v3 = cc_joints[idx * 3 + 2];\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #endif\n    mat4 skinMatrix () {\n      vec4 joints = vec4(a_joints);\n      return getJointMatrix(joints.x) * a_weights.x\n           + getJointMatrix(joints.y) * a_weights.y\n           + getJointMatrix(joints.z) * a_weights.z\n           + getJointMatrix(joints.w) * a_weights.w;\n    }\n    void CCSkin (inout vec4 position) {\n      mat4 m = skinMatrix();\n      position = m * position;\n    }\n    void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n      mat4 m = skinMatrix();\n      position = m * position;\n      normal = (m * vec4(normal, 0.0)).xyz;\n      tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n    }\n  #endif\n  void CCVertInput(inout StandardVertInput In)\n  {\n        In.position = vec4(a_position, 1.0);\n        In.normal = a_normal;\n        In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In.position, In.normal, In.tangent);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In.position, In.normal, In.tangent);\n    #endif\n  }\n  #if !USE_INSTANCING\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n  void CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n  {\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  }\n            uniform vec4 tilingOffset;\n  uniform highp mat4 cc_matLightViewProj;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n  #if HAS_SECOND_UV || CC_USE_LIGHTMAP\n    attribute vec2 a_texCoord1;\n  #endif\n  varying vec2 v_uv;\n  varying vec2 v_uv1;\n  varying vec4 v_worldPos;\n  varying float v_clip_depth;\n  vec4 vert () {\n    StandardVertInput In;\n    CCVertInput(In);\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    v_worldPos = matWorld * In.position;\n    vec4 clipPos = cc_matLightViewProj * v_worldPos;\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if HAS_SECOND_UV\n      v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #endif\n    v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n    return clipPos;\n  }\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n         uniform vec4 albedo;\n       uniform vec4 albedoScaleAndCutoff;\n  vec4 packDepthToRGBA (float depth) {\n    vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    ret = fract(ret);\n    ret -= vec4(ret.yzw, 0.0) / 255.0;\n    return ret;\n  }\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  uniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n  varying vec2 v_uv;\n  varying vec2 v_uv1;\n  varying vec4 v_worldPos;\n  varying float v_clip_depth;\n  #if USE_ALBEDO_MAP\n    uniform sampler2D albedoMap;\n  #endif\n  #if USE_ALPHA_TEST\n  #endif\n  vec4 frag () {\n    vec4 baseColor = albedo;\n    #if USE_ALBEDO_MAP\n      baseColor *= texture2D(albedoMap, ALBEDO_UV);\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n    #endif\n    if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n      if (cc_shadowNFLSInfo.z > 0.000001) {\n        vec4 viewStartPos = cc_matLightView * v_worldPos;\n        float dist = length(viewStartPos.xyz);\n        float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n        return vec4(linearDepth, 1.0, 1.0, 1.0);\n      }\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      return packDepthToRGBA(v_clip_depth);\n    }\n    return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n  }\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":93,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":63}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"../Effect/outLine/outline|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}},{"program":"../Effect/outLine/outline|fx-outline-vs:vert|fx-outline-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"properties":{"rimColor":{"type":16,"value":[1,0,0,1]},"outlineParams":{"type":16,"value":[0.1,0.8,0.1,1]}}},{"phase":"deferred","propertyIndex":0,"program":"../Effect/outLine/outline|standard-vs|standard-fs","blendState":{"targets":[{"blend":false},{"blend":false},{"blend":false},{"blend":false}]},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"forward-add","propertyIndex":0,"program":"../Effect/outLine/outline|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"shadow-caster","propertyIndex":0,"program":"../Effect/outLine/outline|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"../Effect/outLine/outline|fx-outline-vs:vert|fx-outline-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"properties":{"rimColor":{"type":16,"value":[1,0,0,1]},"outlineParams":{"type":16,"value":[0.1,0.8,0.1,1]}}},{"program":"../Effect/outLine/outline|standard-vs|standard-fs","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"forward-add","propertyIndex":0,"program":"../Effect/outLine/outline|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"shadow-caster","propertyIndex":0,"program":"../Effect/outLine/outline|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]],[[{"name":"progress","rect":{"x":0,"y":0,"width":715,"height":66},"offset":{"x":0,"y":0},"originalSize":{"width":715,"height":66},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-357.5,-33,0,357.5,-33,0,-357.5,33,0,357.5,33,0],"indexes":[0,1,2,2,1,3],"uv":[0,66,715,66,0,0,715,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-357.5,"y":-33,"z":0},"maxPos":{"x":357.5,"y":33,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[189]],[[[55,"for2d/builtin-sprite-renderer",[{"hash":2111869669,"name":"for2d/builtin-sprite-renderer|spriteRender-vs:vert|spriteRender-fs:frag","blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":[]}],"samplerTextures":[{"name":"cc_spriteTexture","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n  highp vec4 cc_reflectionProbeData1;\n  highp vec4 cc_reflectionProbeData2;\n};\nin vec3 a_position;\nin vec2 a_texCoord;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  uv0 = vec2(a_texCoord.x, 1.0 - a_texCoord.y);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  o *= texture(cc_spriteTexture, uv0);\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  uv0 = vec2(a_texCoord.x, 1.0 - a_texCoord.y);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  o *= texture2D(cc_spriteTexture, uv0);\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":[]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":54,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":0}},"defines":[]}],[{"name":"default","passes":[{"program":"for2d/builtin-sprite-renderer|spriteRender-vs:vert|spriteRender-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":true,"depthWrite":false}}]}]]],0,0,[],[],[]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"71/aTxlgxADJAEXUaaWFrw@b47c0@e9a6d","back":"71/aTxlgxADJAEXUaaWFrw@b47c0@40c10","left":"71/aTxlgxADJAEXUaaWFrw@b47c0@8fd34","right":"71/aTxlgxADJAEXUaaWFrw@b47c0@74afd","top":"71/aTxlgxADJAEXUaaWFrw@b47c0@bb97f","bottom":"71/aTxlgxADJAEXUaaWFrw@b47c0@7d38f"}]}],[34],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[[11,"Material",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{},{}],[[[{"roughness":0,"specularIntensity":0},"mainColor",8,[4,4278226943]],{},{},{}],11,0,0,0]]],0,0,[0],[4],[12]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-1,-1,0,1,-1,0,-1,1,0,1,1,0],"indexes":[0,1,2,2,1,3],"uv":[0,2,2,2,0,0,2,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-1,"y":-1,"z":0},"maxPos":{"x":1,"y":1,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[190]],[[{"name":"mask","rect":{"x":0,"y":0,"width":1920,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1920,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-960,-540,0,960,-540,0,-960,540,0,960,540,0],"indexes":[0,1,2,2,1,3],"uv":[0,1080,1920,1080,0,0,1920,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-960,"y":-540,"z":0},"maxPos":{"x":960,"y":540,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[191]],[[{"name":"logo","rect":{"x":5,"y":0,"width":510,"height":351},"offset":{"x":-0.5,"y":4.5},"originalSize":{"width":521,"height":360},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-255,-175.5,0,255,-175.5,0,-255,175.5,0,255,175.5,0],"indexes":[0,1,2,2,1,3],"uv":[5,360,515,360,5,9,515,9],"nuv":[0.009596928982725527,0.025,0.9884836852207294,0.025,0.009596928982725527,1,0.9884836852207294,1],"minPos":{"x":-255,"y":-175.5,"z":0},"maxPos":{"x":255,"y":175.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[192]],[[{"name":"btn3","rect":{"x":0,"y":0,"width":596,"height":193},"offset":{"x":0,"y":0},"originalSize":{"width":596,"height":193},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-298,-96.5,0,298,-96.5,0,-298,96.5,0,298,96.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,193,596,193,0,0,596,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-298,"y":-96.5,"z":0},"maxPos":{"x":298,"y":96.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[193]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[194]],[[[11,"crash",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{},{}],[[[{},"mainColor",8,[4,4278190335]],{},{},{}],11,0,0,0]]],0,0,[0],[4],[12]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"albedoScale":5,"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5},"mainColor",8,[4,4290559164],"tilingOffset",8,[2,1.4,28,0,0],"mainTexture",6,0,"transparencyMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[12,13,4],[21,195,4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5},"mainColor",8,[4,4290559164],"tilingOffset",8,[2,1,5,0,0],"mainTexture",6,0,"transparencyMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[12,13,4],[59,196,4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"albedoScale":5,"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5},"mainColor",8,[4,4290559164],"tilingOffset",8,[2,1.4,28,0,0],"mainTexture",6,0,"transparencyMap",6,1,"metallicMap",6,2],{},{}],11,0,0]]],0,0,[0,0,0,0],[12,13,36,4],[21,197,62,4]],[[[20],[22,"road",[-2,-3],[10,"7d3EgS01FZQJSKcQt6rjmm",null,null,null,-1,0]],[54,"对象002",1,[[18,-4,[13,"62lCX11a9QnJ/jqKNxIjoa"],[0,1],[9],2]],[10,"24chbNxvBYS7czBaASEwyX",null,null,null,1,0],[1,7.808134938613875e-8,0.03469036892056465,-1.687172532081604],[1,0.03655099868774414,0.07277599722146988,0.03655099868774414]],[54,"对象003",1,[[18,-5,[13,"5dCfBSbWZevIfKpH8PYLx3"],[3],[9],4]],[10,"d5LqUkk8tZyLWrjPTlBiOQ",null,null,null,1,0],[1,0.00027469603810459375,0.0327720046043396,-1.6871654987335205],[1,0.036649998277425766,0.04569900035858154,0.03655099868774414]]],0,[0,0,1,0,-1,2,0,-2,3,0,2,2,0,2,3,0,10,1,5],[0,0,0,0,0],[-1,-2,5,-1,5],[198,199,200,201,202]],[[[16,".bin",909912962,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":72,"count":36,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":2376,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1224,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-9.971484184265137,-0.6266834139823914,40.177120208740234],"maxPosition",8,[1,9.971479415893555,-0.32667964696884155,52.141700744628906]]],-1],0,0,[],[],[]],[[[16,".bin",1095602492,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5.694555759429932,-0.8671424984931946,40.177120208740234],"maxPosition",8,[1,5.6795654296875,-0.567138671875,52.14132308959961]]],-1],0,0,[],[],[]],[[{"name":"btn1","rect":{"x":0,"y":0,"width":222,"height":233},"offset":{"x":0,"y":0},"originalSize":{"width":222,"height":233},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-111,-116.5,0,111,-116.5,0,-111,116.5,0,111,116.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,233,222,233,0,0,222,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-111,"y":-116.5,"z":0},"maxPos":{"x":111,"y":116.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[203]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"shininessExponent":20},"mainColor",8,[4,4293388263],"specularColor",8,[4,4286348412],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[204,4]],[[[20],[22,"saichedao",[-2],[10,"46r5gLvaxZDLJuzbX9x3zW",null,null,null,-1,0]],[29,"赛车道",1,[[18,-3,[13,"17M1/iHw9aFJ/XDRzqZLGq"],[0],[9],1]],[10,"feNP1dtaVYXZnyOAS2GRdm",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0],[-1,5],[205,206]],[[[16,".bin",358525958,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1536,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1536,"count":24,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9086277484893799,-0.10048572719097137,-6.199023859370398e-18],"maxPosition",8,[1,0.9993144273757935,0.10198976844549179,0.008869299665093422]]],-1],0,0,[],[],[]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0,"specularIntensity":0},"tilingOffset",8,[2,6,1,0,0],"albedoScale",8,[1,5,5,5],"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[12,4],[21,12]],[[[20],[22,"shizilukou",[-2],[10,"6fOOGLjVRaoLsvft6rhFYH",null,null,null,-1,0]],[29,"十字路口_Box007",1,[[18,-3,[13,"e6uT5XKPNYuqBqWXHaMqJi"],[0,1,2,3,4],[9],5]],[10,"08r2uOdedZAY4XzwQS0vJw",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0,0,0,0],[-1,-2,-3,-4,-5,5],[207,27,27,27,27,208]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0,"specularIntensity":0},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[12,4],[62,12]],[[[16,".bin",1977079007,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16896,"length":936,"count":468,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":21928,"length":312,"count":156,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":26336,"length":312,"count":156,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":30744,"length":312,"count":156,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":35152,"length":312,"count":156,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":16896,"count":264,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":17832,"length":4096,"count":64,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":22240,"length":4096,"count":64,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":26648,"length":4096,"count":64,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":31056,"length":4096,"count":64,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-150.40904235839844,-150.54388427734375,-2.904284715652466],"maxPosition",8,[1,150.68756103515625,150.44525146484375,2.746025323867798]]],-1],0,0,[],[],[]],[[[11,"map",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{},{}],[[[{},"tilingOffset",8,[2,10,10,1,0],"mainColor",8,[4,4284197514]],{},{},{}],11,0,0,0]]],0,0,[0],[4],[12]],[[{"name":"btn4","rect":{"x":0,"y":0,"width":596,"height":193},"offset":{"x":0,"y":0},"originalSize":{"width":596,"height":193},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-298,-96.5,0,298,-96.5,0,-298,96.5,0,298,96.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,193,596,193,0,0,596,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-298,"y":-96.5,"z":0},"maxPos":{"x":298,"y":96.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[209]],[[[16,".bin",1782259543,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22680,"length":732,"count":366,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":68052,"length":1320,"count":660,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22680,"count":315,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":23412,"length":44640,"count":620,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-2.2704498767852783,-2.3522286415100098,0.262917697429657],"maxPosition",8,[1,2.270451307296753,2.3522286415100098,12.83564567565918]]],-1],0,0,[],[],[]],[[[20],[22,"tree1",[-2],[10,"190htkDPdRkobYqiVDMX6F",null,null,null,-1,0]],[29,"tree2_对象001",1,[[18,-3,[13,"21fB9uDHVWrLfuJ0fmHi5C"],[0,1],[9],2]],[10,"5fuw5TTlVfKpAJoO7WyrfU",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0],[-1,-2,5],[210,211,212]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"shininessExponent":20},"mainColor",8,[4,4288914339]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[[20],[22,"shizilukoubanmaxian",[-2],[10,"d7IH3ppWxXaI0zjnWyO1Q8",null,null,null,-1,0]],[29,"十字路口_Plane004",1,[[18,-3,[13,"4c4/LWJlFTCLHFSX1rC6Up"],[0],[9],1]],[10,"85/b2BuTtTXKl+Eb0ulLG5",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0],[-1,5],[213,214]],[[[16,".bin",76252532,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":44800,"length":5376,"count":2688,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":44800,"count":700,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-107.98180389404297,-115.00939178466797,1.209999442100525],"maxPosition",8,[1,107.93851470947266,115.00939178466797,1.209999442100525]]],-1],0,0,[],[],[]],[[[11,"CarLP_COLLECTION_M3.004",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4283321934],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M7.004",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4283451454],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M4.004",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4289128421],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M6.004",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4284440501],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M2.004",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4288190588],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[16,".bin",1986750151,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":32112,"length":1476,"count":738,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":35796,"length":108,"count":54,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":48480,"length":696,"count":348,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":57624,"length":540,"count":270,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":60180,"length":96,"count":48,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":61428,"length":48,"count":24,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":32112,"count":669,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":33588,"length":2208,"count":46,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":35904,"length":12576,"count":262,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":49176,"length":8448,"count":176,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":58164,"length":2016,"count":42,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":60276,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.056536879390478134,-0.09945318102836609,-0.007401449140161276],"maxPosition",8,[1,-0.020541973412036896,-0.01863229088485241,0.017196049913764]]],-1],0,0,[],[],[]],[[[16,".bin",2768116304,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":44256,"length":2628,"count":1314,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":91860,"length":3696,"count":1848,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":44256,"count":922,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":46884,"length":44976,"count":937,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.055356550961732864,-0.0912574753165245,-0.010686376132071018],"maxPosition",8,[1,-0.021675128489732742,-0.07887320220470428,0.0016782485181465745]]],-1],0,0,[],[],[]],[[[20],[22,"xiaoche01",[-2],[10,"38Arsro4ZT5qpNdiQXl5Q8",null,null,null,-1,0]],[94,"组001",1,[-3,-4,-5],[10,"054ocLjc1Q/IrhWnauKrki",null,null,null,1,0],[1,0,0.003248554654419422,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]],[40,"Car_002",2,[[18,-6,[13,"67Mz3q4k1VN5pIz7oQczdv"],[0,1,2,3,4,5],[9],6]],[10,"f6uGqJH+lUipDU+70WaByt",null,null,null,1,0],[1,0.038539424538612366,0.05902747064828873,-0.003248554654419422]],[40,"Whells1_002",2,[[18,-7,[13,"50o7YdcflbP5txjqq4zL+j"],[7,8],[9],9]],[10,"c1ZaThXLtXJISCiDxtHtm1",null,null,null,1,0],[1,0.038539424538612366,0.05902747064828873,-0.003248554654419422]],[40,"Whells2_002",2,[[18,-8,[13,"cfRgRkYh9Qxb5p1mCmECAA"],[10,11],[9],12]],[10,"dapstKMgZdWp6tyT2yok1g",null,null,null,1,0],[1,0.038539424538612366,0.05902747064828873,-0.003248554654419422]]],0,[0,0,1,0,-1,2,0,-1,3,0,-2,4,0,-3,5,0,2,3,0,2,4,0,2,5,0,10,1,8],[0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,5,-1,-2,5,-1,-2,5],[215,216,217,218,219,220,221,63,64,222,63,64,223]],[[[11,"CarLP_COLLECTION_M5.004",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4289192679],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"CarLP_COLLECTION_M1_3.002",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4282333487],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[16,".bin",2254888086,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":37632,"length":2352,"count":1176,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":82320,"length":3528,"count":1764,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":37632,"count":784,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":39984,"length":42336,"count":882,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.055356550961732864,-0.03802284225821495,-0.010686376132071018],"maxPosition",8,[1,-0.021675128489732742,-0.02563856542110443,0.0016782480524852872]]],-1],0,0,[],[],[]],[[[11,"CarLP_COLLECTION_M9.004",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":19.99999952104794,"emissiveScale":0,"metallic":0,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4282669721],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[{"name":"tip","rect":{"x":0,"y":0,"width":1010,"height":523},"offset":{"x":0,"y":0},"originalSize":{"width":1010,"height":523},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-505,-261.5,0,505,-261.5,0,-505,261.5,0,505,261.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,523,1010,523,0,0,1010,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-505,"y":-261.5,"z":0},"maxPos":{"x":505,"y":261.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[224]],[[[120,"default-sprite-renderer-material",[{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}]]],0,0,[0],[4],[225]],[[[11,"oulai",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294967295],"mainTexture",6,0]],11]]],0,0,[0,0],[12,4],[24,38]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0,"specularIntensity":0},"tilingOffset",8,[2,4,1,0,0],"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[12,4],[60,12]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"albedoScale":5},"mainColor",8,[4,4286611584],"tilingOffset",8,[2,2,10,0,0],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[21,4]],[[[16,".bin",305859219,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":89600,"length":13842,"count":6921,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":138130,"length":5562,"count":2781,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":89600,"count":1400,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":103442,"length":34688,"count":542,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-9.94309139251709,-6,-0.15000000596046448],"maxPosition",8,[1,9.94309139251709,6,0.15000000596046448]]],-1],0,0,[],[],[]],[[[20],[22,"road",[-2],[10,"7d3EgS01FZQJSKcQt6rjmm",null,null,null,-1,0]],[29,"Merge_356763E2",1,[[18,-3,[13,"59wwe5+GNX1ra5orWBwwxQ"],[0,1],[9],2]],[10,"7eFneUAwtbjbQdKhS9AAGB",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0],[-1,-2,5],[226,227,228]],[[[20],[22,"lamp",[-2],[10,"88VDQVisBbw5m9OxjU+gSN",null,null,null,-1,0]],[29,"路灯",1,[[18,-3,[13,"abR9WWofVfW77+dYb0ZRQt"],[0],[9],1]],[10,"33fTAOch9WmJPJI1jQqnBQ",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0],[-1,5],[229,230]],[[[16,".bin",4112460021,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":137520,"length":17244,"count":8622,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":137520,"count":1910,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-2.086688995361328,-0.10615807771682739,-1.3194913606184855e-8],"maxPosition",8,[1,0.0982065424323082,0.1061585322022438,6.364027500152588]]],-1],0,0,[],[],[]],[[{"name":"red","rect":{"x":0,"y":0,"width":399,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":399,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-199.5,-540,0,199.5,-540,0,-199.5,540,0,199.5,540,0],"indexes":[0,1,2,2,1,3],"uv":[0,1080,399,1080,0,0,399,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-199.5,"y":-540,"z":0},"maxPos":{"x":199.5,"y":540,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[231]],[[[91,"outline",1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{},{}],[[[{},"outlineParams",8,[2,0.1,0.8,1,1]],{},{},{}],11,0,0,0]]],0,0,[0],[4],[232]],[[{"name":"shacheBg","rect":{"x":0,"y":0,"width":253,"height":253},"offset":{"x":0,"y":0},"originalSize":{"width":253,"height":253},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-126.5,-126.5,0,126.5,-126.5,0,-126.5,126.5,0,126.5,126.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,253,253,253,0,0,253,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-126.5,"y":-126.5,"z":0},"maxPos":{"x":126.5,"y":126.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[233]],[[[66,"boxHit"],[151,"boxHit",[-2],[10,"dej8HfUnRLl5t/fEM9i0GO",null,null,null,-1,0],[1,0,0.2,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,89.99999999999999,0,0]],[221,0.4,80,1,[13,"0b7a7v3FVOCpzmec7amMlB"],[0],[25],[17,0.8],[8],[8],[223,1,8,[118,2,[0,1],[[227,2,0.15,0.52],[119,2,0.42,-0.13]]]],[8],[8],[8],[8],[17,0.3],[8],[17,80],[8],[224,true,[222,2,[4,4294603007],[4,4291952870]]],[59,true,3,[17,1],[1,0.4,0.4,0.4]],[225,true,[58,1,[118,2,[0,1],[[228,2,0.53,2.1,2],[119,2,0.07,-1.95]]]],[8],[8],[8]],[60,[8],[8],[8],[17,1]],[61,[8],[8],[8]],[62,[8],[8],[8],[8]],[226,true,true,[8],[8],[17,6.283185307179586]],[63,[8],[8]],[65,[17,1],[8],[25],[25],-3],[229,6,1]]],0,[0,0,1,0,-1,2,0,15,2,0,10,1,3],[0,0],[-1,16],[61,37]],[[{"name":"arrow","rect":{"x":0,"y":0,"width":168,"height":323},"offset":{"x":0,"y":0},"originalSize":{"width":168,"height":323},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-84,-161.5,0,84,-161.5,0,-84,161.5,0,84,161.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,323,168,323,0,0,168,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-84,"y":-161.5,"z":0},"maxPos":{"x":84,"y":161.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[234]],[[{"name":"guide_finger","rect":{"x":0,"y":0,"width":221,"height":248},"offset":{"x":0,"y":0},"originalSize":{"width":221,"height":248},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-110.5,-124,0,110.5,-124,0,-110.5,124,0,110.5,124,0],"indexes":[0,1,2,2,1,3],"uv":[0,248,221,248,0,0,221,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-110.5,"y":-124,"z":0},"maxPos":{"x":110.5,"y":124,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[235]],[[{"name":"yingzi","rect":{"x":0,"y":0,"width":89,"height":21},"offset":{"x":0,"y":0},"originalSize":{"width":89,"height":21},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-44.5,-10.5,0,44.5,-10.5,0,-44.5,10.5,0,44.5,10.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,21,89,21,0,0,89,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-44.5,"y":-10.5,"z":0},"maxPos":{"x":44.5,"y":10.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[236]],[[[11,"Material",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"albedoScale":1,"specularFactor":1,"shininessExponent":20,"emissiveScale":1},"mainColor",8,[4,4286611584],"specularColor",8,[4,4286348412],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[4],[4]],[[[11,"Material",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"shininessExponent":20,"specularFactor":0.5,"transparencyFactor":0,"metallic":1},"mainColor",8,[4,4286611584]],{},{}],11,0,0]]],0,0,[0],[4],[4]],[[{"name":"time","rect":{"x":0,"y":0,"width":160,"height":160},"offset":{"x":0,"y":0},"originalSize":{"width":160,"height":160},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-80,-80,0,80,-80,0,-80,80,0,80,80,0],"indexes":[0,1,2,2,1,3],"uv":[0,160,160,160,0,0,160,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-80,"y":-80,"z":0},"maxPos":{"x":80,"y":80,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[237]],[[[20],[22,"guanggao",[-2],[10,"788ZDs7GpZlr15qKTxEgyo",null,null,null,-1,0]],[36,"AM246_006_AdStand",1,[[18,-3,[13,"e5reTN6sZfp7jghGyYTliq"],[0,1],[9],2]],[10,"53gG8DufFbbJ7pWhzTEv2P",null,null,null,1,0],[1,0,-0.036453861743211746,-1.5934489283608855e-9],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,-90.00000965934633,0,0]]],0,[0,0,1,0,-1,2,0,2,2,0,10,1,3],[0,0,0],[-1,-2,5],[238,239,240]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true,"USE_TRANSPARENCY_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5},"mainColor",8,[4,4290559164],"mainTexture",6,0,"transparencyMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[12,13,4],[65,241,4]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":2,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":19.99999952104794,"specularFactor":0.5,"transparencyFactor":0},"mainColor",8,[4,4290559164],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,4],[65,4]],[[[16,".bin",912860450,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4896,"length":660,"count":330,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":13620,"length":810,"count":405,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":4896,"count":102,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":5556,"length":8064,"count":168,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.43534794449806213,-0.0128208938986063,0.04064997285604477],"maxPosition",8,[1,0.43534794449806213,0.01179113145917654,1.6085728406906128]]],-1],0,0,[],[],[]],[[[55,"util/dcc/imported-specular-glossiness",[{"hash":3452512057,"name":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      envSpec = mix(envmap, envSpec, fixedR.w);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = mix(envmap, EnvReflection(tex, R, roughness, mipCount), fixedR.w);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize);\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_IOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) ||\n            ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColorX = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_RGBE_OUTPUT || CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    #if !CC_USE_RGBE_OUTPUT && !CC_USE_FLOAT_OUTPUT && !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      fragColor0 = CCSurfacesDeferredOutput0(surfaceData);\n      fragColor1 = CCSurfacesDeferredOutput1(surfaceData);\n      fragColor2 = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColor0 = debugColor;\n      }\n    #endif\n    }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 specularColor;\n    uniform vec4 emissive;\n    uniform float emissiveScale;\n    uniform float alphaThreshold;\n    uniform float shininessExponent;\n    uniform float glossiness;\n    uniform float metallic;\n    uniform float normalScale;\n    uniform float transparencyFactor;\n    uniform float diffuseFactor;\n    uniform float specularFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture2D(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture2D(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture2D(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      envSpec = mix(envmap, envSpec, fixedR.w);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = mix(envmap, EnvReflection(tex, R, roughness, mipCount), fixedR.w);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize);\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_IOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) ||\n            ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_RGBE_OUTPUT || CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    #if !CC_USE_RGBE_OUTPUT && !CC_USE_FLOAT_OUTPUT && !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutput0(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutput1(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":101,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":131}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean"},{"name":"GLOSSINESS_MAP_USE_SINGLE_CHANNEL","type":"boolean"},{"name":"HAS_EXPORTED_METALLIC","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_DIFFUSE","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_SPECULAR","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":3337831580,"name":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["CC_SURFACES_USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 emissive;\n    uniform float alphaThreshold;\n    uniform float metallic;\n    uniform float transparencyFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture2D(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvarying highp vec2 v_clip_depth;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":101,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":131}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]],[[{"name":"bar","rect":{"x":0,"y":0,"width":338,"height":33},"offset":{"x":0,"y":0},"originalSize":{"width":338,"height":33},"rotated":false,"capInsets":[15,15,15,15],"vertices":{"rawPosition":[-169,-16.5,0,169,-16.5,0,-169,16.5,0,169,16.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,33,338,33,0,0,338,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-169,"y":-16.5,"z":0},"maxPos":{"x":169,"y":16.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[242]],[[{"name":"lukou","rect":{"x":0,"y":0,"width":125,"height":124},"offset":{"x":0,"y":0},"originalSize":{"width":125,"height":124},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-62.5,-62,0,62.5,-62,0,-62.5,62,0,62.5,62,0],"indexes":[0,1,2,2,1,3],"uv":[0,124,125,124,0,0,125,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-62.5,"y":-62,"z":0},"maxPos":{"x":62.5,"y":62,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[1],0,[0],[11],[243]]]]
